/**
 * 自动修复导入路径脚本
 * 由rename-helper.js自动生成
 */

const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const writeFile = promisify(fs.writeFile);

// 需要修复的文件
const filesToFix = [
  {
    "path": "app\\api\\user\\avatar\\route.ts",
    "newContent": "import { NextRequest, NextResponse } from 'next/server';\r\nimport { getServerSession } from 'next-auth';\r\nimport { prisma } from '@/app/lib/database';\r\nimport { authOptions } from '@/app/lib/auth';\r\nimport { writeFile, mkdir, unlink } from 'fs/promises';\r\nimport { join } from 'path';\r\nimport crypto from 'crypto';\r\nimport fs from 'fs';\r\n\r\n// 确保上传目录存在\r\nconst ensureUploadDir = async () => {\r\n  const uploadDir = join(process.cwd(), 'public', 'uploads', 'avatars');\r\n  if (!fs.existsSync(uploadDir)) {\r\n    console.log('创建头像上传目录:', uploadDir);\r\n    await mkdir(uploadDir, { recursive: true });\r\n  }\r\n  return uploadDir;\r\n};\r\n\r\n// 获取用户当前头像文件路径\r\nconst getUserAvatarPath = async (userId: string) => {\r\n  const user = await prisma.user-profile.findUnique({\r\n    where: { userId },\r\n    select: { avatarUrl: true }\r\n  });\r\n  \r\n  if (!user?.avatarUrl) return null;\r\n  \r\n  // 从URL提取文件名\r\n  const fileName = user.avatarUrl.split('/').pop();\r\n  if (!fileName) return null;\r\n  \r\n  return join(process.cwd(), 'public', 'uploads', 'avatars', fileName);\r\n};\r\n\r\n// 获取用户当前头像\r\nexport async function GET() {\r\n  try {\r\n    const session = await getServerSession(authOptions);\r\n    \r\n    if (!session?.user?.email) {\r\n      return NextResponse.json(\r\n        { success: false, error: '未授权访问' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { email: session.user.email },\r\n      include: { profile: true }\r\n    });\r\n\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { success: false, error: '用户不存在' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      avatarUrl: user.profile?.avatarUrl || session.user.image || null\r\n    });\r\n  } catch (error) {\r\n    console.error('获取头像失败:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: '获取头像失败' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// 上传用户头像\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await getServerSession(authOptions);\r\n    \r\n    if (!session?.user?.email) {\r\n      return NextResponse.json(\r\n        { success: false, error: '未授权访问' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 获取用户ID\r\n    const user = await prisma.user.findUnique({\r\n      where: { email: session.user.email },\r\n      select: { id: true }\r\n    });\r\n\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { success: false, error: '用户不存在' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // 处理表单数据\r\n    const formData = await request.formData();\r\n    const file = formData.get('avatar') as File;\r\n    \r\n    if (!file) {\r\n      return NextResponse.json(\r\n        { success: false, error: '未提供头像文件' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 验证文件类型\r\n    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\r\n    if (!validTypes.includes(file.type)) {\r\n      return NextResponse.json(\r\n        { success: false, error: '不支持的文件类型，请上传JPEG、PNG、GIF或WEBP图片' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 验证文件大小（最大2MB）\r\n    const maxSize = 2 * 1024 * 1024; // 2MB\r\n    if (file.size > maxSize) {\r\n      return NextResponse.json(\r\n        { success: false, error: '文件大小超过限制（最大2MB）' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 生成唯一文件名\r\n    const fileExt = file.name.split('.').pop() || 'jpg';\r\n    const fileName = `${crypto.randomUUID()}.${fileExt}`;\r\n    \r\n    // 确保上传目录存在\r\n    const uploadDir = await ensureUploadDir();\r\n    const filePath = join(uploadDir, fileName);\r\n    const fileUrl = `/uploads/avatars/${fileName}`;\r\n\r\n    console.log('准备写入文件:', filePath);\r\n    console.log('对应的URL:', fileUrl);\r\n\r\n    // 读取文件内容\r\n    const buffer = Buffer.from(await file.arrayBuffer());\r\n    \r\n    // 删除旧头像文件\r\n    try {\r\n      const oldAvatarPath = await getUserAvatarPath(user.id);\r\n      if (oldAvatarPath && fs.existsSync(oldAvatarPath)) {\r\n        console.log('删除旧头像文件:', oldAvatarPath);\r\n        await unlink(oldAvatarPath);\r\n      }\r\n    } catch (deleteError) {\r\n      console.error('删除旧头像文件失败', deleteError);\r\n      // 继续执行，不中断上传流程\r\n    }\r\n    \r\n    // 写入文件\r\n    try {\r\n      await writeFile(filePath, buffer);\r\n      console.log('文件写入成功:', filePath);\r\n    } catch (writeError) {\r\n      console.error('文件写入失败:', writeError);\r\n      return NextResponse.json(\r\n        { success: false, error: '文件保存失败，请重试' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 更新用户资料\r\n    await prisma.user-profile.upsert({\r\n      where: { userId: user.id },\r\n      update: { avatarUrl: fileUrl },\r\n      create: {\r\n        userId: user.id,\r\n        avatarUrl: fileUrl,\r\n        displayName: session.user.name || ''\r\n      }\r\n    });\r\n\r\n    return NextResponse.json({ \r\n      success: true,\r\n      avatarUrl: fileUrl\r\n    });\r\n  } catch (error) {\r\n    console.error('头像上传失败:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: '头像上传失败' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// 删除自定义头像，恢复默认头像\r\nexport async function DELETE() {\r\n  try {\r\n    const session = await getServerSession(authOptions);\r\n    \r\n    if (!session?.user?.email) {\r\n      return NextResponse.json(\r\n        { success: false, error: '未授权访问' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { email: session.user.email },\r\n      select: { id: true }\r\n    });\r\n\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { success: false, error: '用户不存在' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n    \r\n    // 删除头像文件\r\n    try {\r\n      const avatarPath = await getUserAvatarPath(user.id);\r\n      if (avatarPath && fs.existsSync(avatarPath)) {\r\n        console.log('删除头像文件:', avatarPath);\r\n        await unlink(avatarPath);\r\n      }\r\n    } catch (deleteError) {\r\n      console.error('删除头像文件失败:', deleteError);\r\n      // 继续执行，不中断删除流程\r\n    }\r\n\r\n    // 更新用户资料，删除自定义头像\r\n    await prisma.user-profile.update({\r\n      where: { userId: user.id },\r\n      data: { avatarUrl: null }\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      avatarUrl: session.user.image || null\r\n    });\r\n  } catch (error) {\r\n    console.error('删除头像失败:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: '删除头像失败' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} \r\n"
  },
  {
    "path": "app\\api\\user\\profile\\route.ts",
    "newContent": "import { NextRequest, NextResponse } from 'next/server'\r\nimport { getServerSession } from 'next-auth'\r\nimport { prisma } from '@/app/lib/database'\r\n\r\n// 获取当前认证配置\r\nimport { authOptions } from '@/app/lib/auth'\r\n\r\n// 从前端获取的用户资料接口\r\ninterface UserProfileInput {\r\n  displayName?: string\r\n  bio?: string\r\n  location?: string\r\n  website?: string\r\n  company?: string\r\n  avatarUrl?: string\r\n  theme?: string\r\n}\r\n\r\n// 返回给前端的用户资料接口\r\ninterface UserProfileResponse {\r\n  id: string\r\n  email: string\r\n  name: string | null\r\n  avatarUrl?: string | null\r\n  theme?: string | null\r\n  bio?: string | null\r\n  location?: string | null\r\n  website?: string | null\r\n  company?: string | null\r\n  storageUsed: number\r\n  storageLimit: number\r\n  createdAt: string\r\n  updatedAt: string\r\n}\r\n\r\n// 获取用户资料\r\nexport async function GET() {\r\n  console.log('GET /api/user/profile 请求开始')\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    console.log('获取到用户会话:', session ? '成功' : '失败')\r\n    \r\n    if (!session?.user?.email) {\r\n      console.log('未授权访问: 没有找到用户邮箱')\r\n      return NextResponse.json(\r\n        { success: false, error: '未授权访问' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    console.log('查询用户信息，邮箱:', session.user.email)\r\n    // 查询用户，并包含用户资料\r\n    const user = await prisma.user.findUnique({\r\n      where: {\r\n        email: session.user.email\r\n      },\r\n      include: {\r\n        profile: true\r\n      }\r\n    })\r\n\r\n    if (!user) {\r\n      console.log('用户不存在:', session.user.email)\r\n      return NextResponse.json(\r\n        { success: false, error: '用户不存在' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    // 构建用户资料响应\r\n    const user-profile: UserProfileResponse = {\r\n      id: user.id,\r\n      email: user.email,\r\n      name: user.name,\r\n      avatarUrl: user.profile?.avatarUrl || null, \r\n      theme: user.profile?.theme || null,\r\n      bio: user.profile?.bio || null,\r\n      location: user.profile?.location || null,\r\n      website: user.profile?.website || null,\r\n      company: user.profile?.company || null,\r\n      storageUsed: user.storageUsed,\r\n      storageLimit: user.storageLimit,\r\n      createdAt: user.createdAt.toISOString(),\r\n      updatedAt: user.updatedAt.toISOString()\r\n    }\r\n\r\n    console.log('成功获取用户信息:', user.id)\r\n    return NextResponse.json({\r\n      success: true,\r\n      profile: user-profile\r\n    })\r\n  } catch (error) {\r\n    console.error('获取用户信息失败:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: '获取用户信息失败' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n// 更新用户资料\r\nexport async function PUT(request: NextRequest) {\r\n  console.log('PUT /api/user/profile 请求开始')\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    console.log('获取到用户会话:', session ? '成功' : '失败')\r\n    \r\n    if (!session?.user?.email) {\r\n      console.log('未授权访问: 没有找到用户邮箱')\r\n      return NextResponse.json(\r\n        { success: false, error: '未授权访问' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    const data = await request.json() as UserProfileInput\r\n    console.log('接收到的数据:', data)\r\n\r\n    // 获取用户\r\n    const user = await prisma.user.findUnique({\r\n      where: {\r\n        email: session.user.email\r\n      },\r\n      include: {\r\n        profile: true\r\n      }\r\n    })\r\n\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { success: false, error: '用户不存在' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    // 更新用户名称\r\n    const updatedUser = await prisma.user.update({\r\n      where: {\r\n        id: user.id\r\n      },\r\n      data: {\r\n        name: data.displayName || user.name\r\n      }\r\n    })\r\n\r\n    // 更新或创建用户资料\r\n    console.log('开始更新用户资料，用户ID:', user.id);\r\n    console.log('当前用户Profile数据:', user.profile || '无');\r\n    \r\n    const profile = await prisma.user-profile.upsert({\r\n      where: {\r\n        userId: user.id\r\n      },\r\n      update: {\r\n        avatarUrl: data.avatarUrl !== undefined ? data.avatarUrl : user.profile?.avatarUrl,\r\n        theme: data.theme !== undefined ? data.theme : user.profile?.theme,\r\n        displayName: data.displayName || user.profile?.displayName || user.name,\r\n        bio: data.bio !== undefined ? data.bio : user.profile?.bio,\r\n        location: data.location !== undefined ? data.location : user.profile?.location,\r\n        website: data.website !== undefined ? data.website : user.profile?.website,\r\n        company: data.company !== undefined ? data.company : user.profile?.company\r\n      },\r\n      create: {\r\n        userId: user.id,\r\n        displayName: data.displayName || user.name || '',\r\n        avatarUrl: data.avatarUrl,\r\n        theme: data.theme,\r\n        bio: data.bio || '',\r\n        location: data.location || '',\r\n        website: data.website || '',\r\n        company: data.company || ''\r\n      }\r\n    });\r\n    \r\n    console.log('用户资料更新/创建成功:', profile);\r\n\r\n    // 构建用户资料响应\r\n    const user-profile: UserProfileResponse = {\r\n      id: updatedUser.id,\r\n      email: updatedUser.email,\r\n      name: updatedUser.name,\r\n      avatarUrl: profile.avatarUrl,\r\n      theme: profile.theme,\r\n      bio: profile.bio,\r\n      location: profile.location,\r\n      website: profile.website,\r\n      company: profile.company,\r\n      storageUsed: updatedUser.storageUsed,\r\n      storageLimit: updatedUser.storageLimit,\r\n      createdAt: updatedUser.createdAt.toISOString(),\r\n      updatedAt: updatedUser.updatedAt.toISOString()\r\n    }\r\n\r\n    console.log('成功更新用户信息:', user.id)\r\n    return NextResponse.json({\r\n      success: true,\r\n      profile: user-profile\r\n    })\r\n  } catch (error) {\r\n    console.error('更新用户信息失败:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: '更新用户信息失败' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n} "
  },
  {
    "path": "app\\api\\user\\theme\\route.ts",
    "newContent": "import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { prisma } from '@/app/lib/database';\nimport { authOptions } from '@/app/lib/auth';\n\n// 获取用户当前主题\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      return NextResponse.json(\n        { success: false, error: '未授权访问' },\n        { status: 401 }\n      );\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      include: { profile: true }\n    });\n\n    if (!user) {\n      return NextResponse.json(\n        { success: false, error: '用户不存在' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json({\n      success: true,\n      theme: user.profile?.theme || 'default'\n    });\n  } catch (error) {\n    console.error('获取主题失败:', error);\n    return NextResponse.json(\n      { success: false, error: '获取主题失败' },\n      { status: 500 }\n    );\n  }\n}\n\n// 更新用户主题\nexport async function PUT(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      return NextResponse.json(\n        { success: false, error: '未授权访问' },\n        { status: 401 }\n      );\n    }\n\n    // 获取请求体\n    const data = await request.json();\n    const { theme } = data;\n    \n    if (!theme) {\n      return NextResponse.json(\n        { success: false, error: '未提供主题参数' },\n        { status: 400 }\n      );\n    }\n\n    // 验证主题是否有效\n    const validThemes = [\n      // 基础色彩主题\n      'default', 'violet', 'emerald', 'amber', 'rose',\n      // 渐变主题\n      'ocean', 'sunset', 'forest', 'galaxy', \n      // 季节主题\n      'spring', 'summer', 'autumn', 'winter',\n      // 柔和主题 - 浅色系列\n      'pastel_pink', 'pastel_blue', 'pastel_lavender', 'pastel_mint', \n      'pastel_peach', 'pastel_lemon', 'pastel_teal'\n    ];\n    if (!validThemes.includes(theme)) {\n      return NextResponse.json(\n        { success: false, error: '无效的主题' },\n        { status: 400 }\n      );\n    }\n\n    // 获取用户ID\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true }\n    });\n\n    if (!user) {\n      return NextResponse.json(\n        { success: false, error: '用户不存在' },\n        { status: 404 }\n      );\n    }\n\n    // 更新用户主题\n    await prisma.user-profile.upsert({\n      where: { userId: user.id },\n      update: { theme },\n      create: {\n        userId: user.id,\n        displayName: session.user.name || '',\n        theme\n      }\n    });\n\n    return NextResponse.json({\n      success: true,\n      theme\n    });\n  } catch (error) {\n    console.error('更新主题失败:', error);\n    return NextResponse.json(\n      { success: false, error: '更新主题失败' },\n      { status: 500 }\n    );\n  }\n} \n"
  },
  {
    "path": "app\\components\\features\\file-management\\actionBar\\TopActionBar\\TopActionBar.tsx",
    "newContent": "import React from 'react';\r\nimport { \r\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \r\n} from 'lucide-react';\r\nimport styles from '@/app/file-management/styles/shared.module.css';\r\nimport { SortDropdown } from '@/app/components/features/file-management/actionBar/SortDropdown';\r\nimport { UploadButton } from '@/app/components/features/file-management/upload/UploadButton';\r\nimport { FileSortInterface } from '@/app/types';\r\n\r\ninterface TopActionBarProps {\r\n  selectedFiles: string[];\r\n  onClearSelection: () => void;\r\n  onDownload: () => void;\r\n  onRename: () => void;\r\n  onMove: () => void;\r\n  onDelete: () => void;\r\n  onClearFilter: () => void;\r\n  onCreateFolder: () => void;\r\n  selectedFileType: string | null;\r\n  showSearchView: boolean;\r\n  isInRootFolder: boolean;\r\n  sortOrder: FileSortInterface;\r\n  setSortOrder: (order: FileSortInterface) => void;\r\n  showUploadDropdown: boolean;\r\n  setShowUploadDropdown: (show: boolean) => void;\r\n  setIsUploadModalOpen: (open: boolean) => void;\r\n  setIsFolderUploadModalOpen: (open: boolean) => void;\r\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\r\n}\r\n\r\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\r\n  selectedFiles,\r\n  onClearSelection,\r\n  onDownload,\r\n  onRename,\r\n  onMove,\r\n  onDelete,\r\n  onClearFilter,\r\n  onCreateFolder,\r\n  selectedFileType,\r\n  showSearchView,\r\n  isInRootFolder,\r\n  sortOrder,\r\n  setSortOrder,\r\n  showUploadDropdown,\r\n  setShowUploadDropdown,\r\n  setIsUploadModalOpen,\r\n  setIsFolderUploadModalOpen,\r\n  uploadDropdownRef\r\n}) => {\r\n  return (\r\n    <div className={styles.topBar}>\r\n      <div className={styles.buttonGroup}>\r\n        {selectedFiles.length > 0 ? (\r\n          <>\r\n            <button className={styles.topButton} onClick={onClearSelection}>\r\n              <X className=\"w-4 h-4\" />\r\n              取消选择\r\n            </button>\r\n            <button className={styles.topButton} onClick={onDownload}>\r\n              <Download className=\"w-4 h-4\" />\r\n              下载\r\n            </button>\r\n            <button \r\n              className={styles.topButton}\r\n              onClick={onRename}\r\n            >\r\n              <Edit className=\"w-4 h-4\" />\r\n              重命名\r\n            </button>\r\n            <button className={styles.topButton} onClick={onMove}>\r\n              <Move className=\"w-4 h-4\" />\r\n              移动\r\n            </button>\r\n            <button className={styles.topButton} onClick={onDelete}>\r\n              <Trash2 className=\"w-4 h-4\" />\r\n              删除\r\n            </button>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <button \r\n              className={styles.topButton}\r\n              onClick={onClearFilter}\r\n              disabled={isInRootFolder}\r\n            >\r\n              <span>📁</span>\r\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\r\n            </button>\r\n\r\n            {/* 添加当前过滤状态指示器 */}\r\n            {selectedFileType && (\r\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\r\n                {(() => {\r\n                  switch(selectedFileType) {\r\n                    case 'image': return <ImageIcon className=\"w-4 h-4 mr-2\" />;\r\n                    case 'document': return <FileText className=\"w-4 h-4 mr-2\" />;\r\n                    case 'video': return <Video className=\"w-4 h-4 mr-2\" />;\r\n                    case 'audio': return <Music className=\"w-4 h-4 mr-2\" />;\r\n                    case 'other': return <File className=\"w-4 h-4 mr-2\" />;\r\n                    default: return null;\r\n                  }\r\n                })()}\r\n                当前浏览：\r\n                {selectedFileType === 'image' && '仅图片'}\r\n                {selectedFileType === 'document' && '仅文档'}\r\n                {selectedFileType === 'video' && '仅视频'}\r\n                {selectedFileType === 'audio' && '仅音频'}\r\n                {selectedFileType === 'other' && '其他文件'}\r\n              </div>\r\n            )}\r\n\r\n            {/* 排序下拉菜单 */}\r\n            <SortDropdown \r\n              sortOrder={sortOrder}\r\n              onSortChange={setSortOrder}\r\n            />\r\n            \r\n            {/* 上传按钮 */}\r\n            <UploadButton \r\n              showDropdown={showUploadDropdown}\r\n              setShowDropdown={setShowUploadDropdown}\r\n              setIsModalOpen={setIsUploadModalOpen}\r\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\r\n              uploadDropdownRef={uploadDropdownRef}\r\n            />\r\n            \r\n            <button \r\n              className={styles.folderButton} \r\n              onClick={onCreateFolder}\r\n            >\r\n              <FolderUp className=\"w-4 h-4 mr-2\" />\r\n              新建文件夹\r\n            </button>\r\n          </>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TopActionBar; "
  },
  {
    "path": "app\\components\\features\\file-management\\MiniSidebar.tsx",
    "newContent": "/**\r\n * @deprecated 此组件已迁移到新的组件架构中。\r\n * 请使用 @/app/components/features/file-management/navigation/MiniSidebar 组件。\r\n */\r\n\r\nimport React from 'react';\r\nimport Image from 'next/image';\r\nimport { Home, LogOut, Palette } from 'lucide-react';\r\nimport styles from '../styles/shared.module.css';\r\n\r\ninterface MiniSidebarProps {\r\n  avatarUrl: string | null;\r\n  userName: string | null;\r\n  userEmail: string | null;\r\n  onHomeClick: () => void;\r\n  onLogoutClick: () => void;\r\n  onAvatarClick: () => void;\r\n  currentTheme?: string | null;\r\n  onThemeClick: () => void;\r\n}\r\n\r\nconst MiniSidebar: React.FC<MiniSidebarProps> = ({\r\n  avatarUrl,\r\n  userName,\r\n  userEmail,\r\n  onHomeClick,\r\n  onLogoutClick,\r\n  onAvatarClick,\r\n  currentTheme = 'default',\r\n  onThemeClick\r\n}) => {\r\n  return (\r\n    <div className={styles.miniSidebar}>\r\n      <div className={styles.patternOverlay}></div>\r\n      <div className={styles.avatarContainer}>\r\n        <button \r\n          className={styles.miniSidebarButton}\r\n          onClick={onAvatarClick}\r\n        >\r\n          {avatarUrl ? (\r\n            <Image\r\n              src={`${avatarUrl}?t=${Date.now()}`}\r\n              alt=\"用户头像\"\r\n              width={38}\r\n              height={38}\r\n              className=\"rounded-full ring-1 ring-white/50 transition-all duration-300 hover:ring-2\"\r\n            />\r\n          ) : (\r\n            <div \r\n              className={styles.avatarPlaceholder}\r\n              style={{ width: '38px', height: '38px', fontSize: '16px' }}\r\n            >\r\n              {userName?.[0]?.toUpperCase() || userEmail?.[0]?.toUpperCase() || '?'}\r\n            </div>\r\n          )}\r\n        </button>\r\n      </div>\r\n      <div className={styles.miniSidebarDivider}></div>\r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onHomeClick}\r\n      >\r\n        <Home className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n      \r\n      {/* 主题选择按钮 */}\r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onThemeClick}\r\n        title=\"主题设置\"\r\n      >\r\n        <Palette className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n      \r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onLogoutClick}\r\n      >\r\n        <LogOut className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MiniSidebar; "
  },
  {
    "path": "app\\components\\features\\file-management\\NewFolderForm.tsx",
    "newContent": "/**\r\n * @deprecated 此组件已迁移到新的组件架构中。\r\n * 请使用 @/app/components/features/file-management/folderManagement/NewFolderForm 组件。\r\n */\r\n\r\nimport React, { useRef, useState, useEffect } from 'react';\r\nimport { Folder, AlertCircle } from 'lucide-react';\r\nimport styles from '../styles/shared.module.css';\r\n\r\ninterface NewFolderFormProps {\r\n  folderName: string;\r\n  setFolderName: (name: string) => void;\r\n  folderTags: string[];\r\n  setFolderTags: (tags: string[]) => void;\r\n  onCreateFolder: () => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nconst NewFolderForm: React.FC<NewFolderFormProps> = ({\r\n  folderName,\r\n  setFolderName,\r\n  folderTags,\r\n  setFolderTags,\r\n  onCreateFolder,\r\n  onCancel\r\n}) => {\r\n  const [newTag, setNewTag] = useState('');\r\n  const [nameError, setNameError] = useState<string | null>(null);\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // 检查文件夹名称是否有效\r\n  useEffect(() => {\r\n    const trimmedName = folderName.trim();\r\n    \r\n    if (trimmedName === '') {\r\n      setNameError(null); // 空名称不显示错误，但创建按钮会处理\r\n      return;\r\n    }\r\n\r\n    // 检查特殊字符\r\n    const invalidChars = /[\\/\\\\:*?\"<>|]/;\r\n    if (invalidChars.test(trimmedName)) {\r\n      setNameError('文件夹名称不能包含下列字符: / \\\\ : * ? \" < > |');\r\n      return;\r\n    }\r\n\r\n    setNameError(null);\r\n  }, [folderName]);\r\n\r\n  // 处理回车键创建文件夹\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (e.key === 'Enter' && !nameError && folderName.trim()) {\r\n      onCreateFolder();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.newFolderRow} p-4 border border-gray-200 rounded-lg bg-white shadow-sm mb-4`}>\r\n      <div className={`${styles.newFolderForm} flex flex-col space-y-4`}>\r\n        <div className={`flex items-center`}>\r\n          <Folder className=\"w-6 h-6 text-blue-500 flex-shrink-0 mr-3\" />\r\n          <div className={`${styles.newFolderNameContainer} flex-grow relative`}>\r\n            <input\r\n              type=\"text\"\r\n              ref={inputRef}\r\n              className={`${styles.newFolderInput} h-10 px-3 rounded-md border ${nameError ? 'border-red-500' : 'border-gray-300'} w-full text-base`}\r\n              value={folderName}\r\n              onChange={(e) => setFolderName(e.target.value)}\r\n              placeholder=\"新文件夹名称\"\r\n              autoFocus\r\n              onKeyDown={handleKeyDown}\r\n            />\r\n            {nameError && (\r\n              <div className=\"text-red-500 text-xs mt-1 flex items-center\">\r\n                <AlertCircle className=\"w-3 h-3 mr-1\" />\r\n                <span>{nameError}</span>\r\n              </div>\r\n            )}\r\n            {!nameError && (\r\n              <div className=\"text-gray-500 text-xs mt-1\">\r\n                相同目录下不能存在同名文件夹\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={`${styles.newFolderTagsContainer} ml-9`}>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">添加标签</label>\r\n          <div className={`${styles.tagsWrapper} h-10 flex items-center flex-wrap gap-2 border border-gray-300 rounded-md px-3 py-1 overflow-y-auto`}>\r\n            {folderTags.map((tag, index) => (\r\n              <div key={index} className={`${styles.tagItem} h-7 flex items-center bg-blue-100 text-blue-800 px-2 rounded-md`}>\r\n                <span className=\"text-sm\">{tag}</span>\r\n                <button\r\n                  className={`${styles.removeTagButton} ml-1 text-blue-600 hover:text-blue-800 w-5 h-5 flex items-center justify-center rounded-full hover:bg-blue-200`}\r\n                  onClick={() => {\r\n                    const updatedTags = [...folderTags];\r\n                    updatedTags.splice(index, 1);\r\n                    setFolderTags(updatedTags);\r\n                  }}\r\n                >\r\n                  ×\r\n                </button>\r\n              </div>\r\n            ))}\r\n            <input\r\n              type=\"text\"\r\n              className={`${styles.tagInput} flex-grow h-7 border-0 outline-none text-sm bg-transparent`}\r\n              value={newTag}\r\n              onChange={(e) => setNewTag(e.target.value)}\r\n              onKeyDown={(e) => {\r\n                if (e.key === 'Enter' && newTag.trim()) {\r\n                  setFolderTags([...folderTags, newTag.trim()]);\r\n                  setNewTag('');\r\n                  e.preventDefault();\r\n                }\r\n              }}\r\n              placeholder=\"添加标签...\"\r\n            />\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={`${styles.newFolderActions} flex items-center gap-3 ml-9`}>\r\n          <button \r\n            className={`${styles.confirmButton} h-10 px-4 ${nameError || !folderName.trim() ? 'bg-blue-300 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white rounded-md flex items-center justify-center`}\r\n            onClick={onCreateFolder}\r\n            disabled={!!nameError || !folderName.trim()}\r\n          >\r\n            创建\r\n          </button>\r\n          <button \r\n            className={`${styles.cancelButton} h-10 px-4 bg-gray-100 hover:bg-gray-200 text-gray-800 rounded-md flex items-center justify-center border border-gray-300`}\r\n            onClick={onCancel}\r\n          >\r\n            取消\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NewFolderForm; "
  },
  {
    "path": "app\\components\\features\\file-management\\RenameModal\\index.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/fileOperations/RenameModal 组件。\n */\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport styles from '@/app/shared/themes/components/renameModal.module.css';\nimport { CloseOutlined, TagOutlined, PlusOutlined } from '@ant-design/icons';\n\ninterface RenameModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onRename: (newName: string, tags?: string[]) => void;\n  initialName: string;\n  initialTags?: string[];\n  fileType: 'file' | 'folder';\n}\n\nconst RenameModal: React.FC<RenameModalProps> = ({\n  isOpen,\n  onClose,\n  onRename,\n  initialName,\n  initialTags = [],\n  fileType\n}) => {\n  const [newName, setNewName] = useState(initialName);\n  const [tags, setTags] = useState<string[]>(initialTags);\n  const [tagInput, setTagInput] = useState('');\n  \n  const inputRef = useRef<HTMLInputElement>(null);\n  const tagInputRef = useRef<HTMLInputElement>(null);\n  const modalRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    setNewName(initialName);\n    // 确保初始标签不包含重复项\n    setTags(Array.from(new Set(initialTags)));\n  }, [initialName, initialTags]);\n\n  useEffect(() => {\n    if (isOpen && inputRef.current) {\n      // 自动聚焦输入框并选中文件名（不包括扩展名）\n      inputRef.current.focus();\n      \n      const extension = fileType === 'file' ? initialName.lastIndexOf('.') : -1;\n      if (extension !== -1) {\n        inputRef.current.setSelectionRange(0, extension);\n      } else {\n        inputRef.current.select();\n      }\n    }\n  }, [isOpen, initialName, fileType]);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n    \n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen, onClose]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    // 首先确保新名称是有效的非空字符串\n    if (newName && typeof newName === 'string' && newName.trim() && \n        (newName !== initialName || JSON.stringify(tags) !== JSON.stringify(initialTags))) {\n      onRename(newName, tags);\n    } else if (!newName || !newName.trim()) {\n      // 如果名称为空，显示错误信息但不关闭模态框\n      return;\n    }\n    onClose();\n  };\n\n  const handleAddTag = () => {\n    if (!tagInput.trim()) return;\n    \n    // 避免添加重复标签\n    if (!tags.includes(tagInput.trim())) {\n      setTags([...tags, tagInput.trim()]);\n    }\n    \n    setTagInput('');\n    \n    // 添加后自动聚焦回标签输入框\n    setTimeout(() => {\n      if (tagInputRef.current) {\n        tagInputRef.current.focus();\n      }\n    }, 0);\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(tag => tag !== tagToRemove));\n  };\n\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      handleAddTag();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div className={styles['modal-overlay']}>\n      <div ref={modalRef} className={`${styles['modal-content']} ${styles['rename-modal']}`}>\n        <div className={styles['modal-header']}>\n          <h3 className={styles['modal-title']}>\n            {fileType === 'folder' ? '重命名文件夹' : '重命名文件'}\n          </h3>\n          <button \n            className={styles['modal-close']} \n            onClick={onClose}\n            aria-label=\"关闭\"\n          >\n            <CloseOutlined />\n          </button>\n        </div>\n        \n        <form className={styles['rename-form']} onSubmit={handleSubmit}>\n          <div className={styles['form-group']}>\n            <label className={styles['form-label']}>名称</label>\n            <input\n              ref={inputRef}\n              type=\"text\"\n              className={styles['rename-input']}\n              value={newName}\n              onChange={(e) => setNewName(e.target.value)}\n              placeholder=\"输入新名称\"\n              autoFocus\n            />\n          </div>\n          \n          <div className={styles['form-group']}>\n            <label className={styles['form-label']}>标签</label>\n            <div className={styles['tags-container']}>\n              {tags.map((tag, index) => (\n                <div key={index} className={styles['tag']}>\n                  <span>{tag}</span>\n                  <button \n                    type=\"button\"\n                    className={styles['tag-remove']}\n                    onClick={() => handleRemoveTag(tag)}\n                  >\n                    &times;\n                  </button>\n                </div>\n              ))}\n            </div>\n            <div className={styles['tag-input-container']}>\n              <TagOutlined className={styles['tag-icon']} />\n              <input\n                ref={tagInputRef}\n                type=\"text\"\n                className={styles['tag-input']}\n                value={tagInput}\n                onChange={(e) => setTagInput(e.target.value)}\n                onKeyDown={handleTagInputKeyDown}\n                placeholder=\"输入标签，按回车添加\"\n              />\n              <button\n                type=\"button\"\n                className={styles['tag-add-button']}\n                onClick={handleAddTag}\n                disabled={!tagInput.trim()}\n              >\n                <PlusOutlined />\n              </button>\n            </div>\n          </div>\n\n          <div className={styles['modal-footer']}>\n            <button \n              type=\"button\" \n              className={`${styles['modal-button']} ${styles.cancel}`}\n              onClick={onClose}\n            >\n              取消\n            </button>\n            <button \n              type=\"submit\" \n              className={`${styles['modal-button']} ${styles.confirm}`}\n              disabled={!newName.trim() || (newName === initialName && JSON.stringify(tags) === JSON.stringify(initialTags))}\n            >\n              确认\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default RenameModal; "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\Breadcrumb.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/navigation/Breadcrumb 组件。\n */\n\nimport React from 'react';\nimport { Home, ChevronRight, ChevronLeft } from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { FolderPathItem } from '@/app/types';\n\ninterface BreadcrumbProps {\n  folderPath: FolderPathItem[];\n  showHome?: boolean;\n  onNavigate?: (folderId: string | null) => void;\n  onPathClick: (folderId: string | null) => void;\n  onBackClick?: () => void;\n}\n\nexport function Breadcrumb({ \n  folderPath, \n  showHome = true, \n  onNavigate, \n  onPathClick,\n  onBackClick\n}: BreadcrumbProps) {\n  // 向下兼容：如果有onNavigate但没有onPathClick，就使用onNavigate\n  const handlePathClick = onPathClick || onNavigate;\n\n  if (!handlePathClick) {\n    console.error('Breadcrumb组件缺少必要的onPathClick或onNavigate回调函数');\n    return null;\n  }\n\n  return (\n    <div className={styles.breadcrumb}>\n      {onBackClick && folderPath.length > 0 && (\n        <button \n          className={styles.breadcrumbBackButton}\n          onClick={onBackClick}\n          title=\"返回上一级\"\n        >\n          <ChevronLeft size={16} />\n        </button>\n      )}\n      \n      {showHome && (\n        <div className={styles.breadcrumbItem}>\n          <button\n            className={styles.breadcrumbLink}\n            onClick={() => handlePathClick(null)}\n          >\n            <Home size={16} className={styles.breadcrumbIcon} />\n            根目录\n          </button>\n        </div>\n      )}\n      \n      {folderPath.map((folder) => (\n        <React.Fragment key={folder.id}>\n          <span className={styles.breadcrumbSeparator}>\n            <ChevronRight size={14} />\n          </span>\n          <div className={styles.breadcrumbItem}>\n            <button\n              className={styles.breadcrumbLink}\n              onClick={() => handlePathClick(folder.id)}\n            >\n              {folder.name}\n            </button>\n          </div>\n        </React.Fragment>\n      ))}\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\ErrorDisplay.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/shared/ErrorDisplay 组件。\n */\n\n'use client';\n\nimport React from 'react';\nimport { AlertTriangle, RefreshCw, Wifi, Server, CloudOff } from 'lucide-react';\nimport styles from '../../../../file-management/styles/shared.module.css';\n\ninterface ErrorDisplayProps {\n  title?: string;\n  message?: string;\n  errorType?: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown';\n  onRetry?: () => void;\n  retryText?: string;\n}\n\n/**\n * 显示友好的错误提示，支持不同类型的错误\n */\nexport const ErrorDisplay: React.FC<ErrorDisplayProps> = ({\n  title,\n  message = '请刷新页面重试或联系管理员',\n  errorType = 'unknown',\n  onRetry,\n  retryText = '重试'\n}) => {\n  // 根据错误类型获取图标和标题\n  const getErrorInfo = () => {\n    switch (errorType) {\n      case 'network':\n        return {\n          icon: <Wifi className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '网络连接错误'\n        };\n      case 'auth':\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '身份验证失败'\n        };\n      case 'server':\n        return {\n          icon: <Server className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '服务器错误'\n        };\n      case 'data':\n        return {\n          icon: <CloudOff className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '数据加载失败'\n        };\n      case 'timeout':\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '请求超时'\n        };\n      default:\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '加载出错'\n        };\n    }\n  };\n\n  const { icon, defaultTitle } = getErrorInfo();\n  const displayTitle = title || defaultTitle;\n\n  return (\n    <div className={styles.errorContainer}>\n      <div className={styles.errorCard}>\n        <div className={styles.errorIcon}>\n          {icon}\n        </div>\n        <h3 className={styles.errorTitle}>{displayTitle}</h3>\n        <p className={styles.errorText}>{message}</p>\n        {onRetry && (\n          <button \n            className={styles.retryButton}\n            onClick={onRetry}\n          >\n            <RefreshCw className=\"w-4 h-4\" />\n            {retryText}\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}; "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\FileList.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/fileList/FileList 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { \n  File as FileIcon, \n  Folder, \n  Image as ImageIcon, \n  FileText, \n  Video, \n  Music, \n  MoreVertical,\n  Tag as TagIcon,\n  SearchX,\n  Filter,\n  Check,\n  X,\n  Plus\n} from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { getFileType as getFileTypeDisplay } from '@/app/utils/file/type';\nimport { getFileNameAndExtension } from '@/app/utils/file/path';\nimport { FileInfo } from '@/app/types';\n\ninterface FileListProps {\n  files: FileInfo[];\n  selectedFiles: string[];\n  onFileClick: (file: FileInfo) => void;\n  onFileDoubleClick?: (file: FileInfo) => void;\n  onFileContextMenu?: (event: React.MouseEvent, file: FileInfo) => void;\n  onSelectFiles?: (fileIds: string[]) => void;\n  onFileSelect?: (file: FileInfo, checked: boolean) => void;\n  onSelectAll?: () => void;\n  onDeselectAll?: () => void;\n  onSelectAllFiles?: () => void;\n  onDeselectAllFiles?: () => void;\n  fileTypeFilter?: string | null;\n  isLoading?: boolean;\n  error?: string | null;\n  onBackClick?: () => void;\n  editingFileId?: string | null;\n  editingFile?: string | null;\n  editingName?: string;\n  editingTags?: string[];\n  newTag?: string;\n  onNewTagChange?: (value: string) => void;\n  onEditNameChange?: (value: string) => void;\n  onStartEdit?: (file: FileInfo) => void;\n  onConfirmEdit?: (fileId: string, newName: string, newTags: string[]) => void;\n  onCancelEdit?: () => void;\n  onAddTag?: (tag: string) => void;\n  onRemoveTag?: (tag: string) => void;\n  showCheckboxes?: boolean;\n  areAllSelected?: boolean;\n}\n\nexport function FileList({\n  files,\n  selectedFiles,\n  onFileClick,\n  onFileDoubleClick,\n  onFileContextMenu,\n  onSelectFiles,\n  onFileSelect,\n  onSelectAll,\n  onDeselectAll,\n  onSelectAllFiles,\n  onDeselectAllFiles,\n  fileTypeFilter,\n  isLoading,\n  error,\n  onBackClick,\n  editingFileId,\n  editingFile,\n  editingName: providedEditingName,\n  editingTags: providedEditingTags,\n  newTag: providedNewTag,\n  onNewTagChange,\n  onEditNameChange,\n  onStartEdit,\n  onConfirmEdit,\n  onCancelEdit,\n  onAddTag,\n  onRemoveTag,\n  showCheckboxes = true,\n  areAllSelected\n}: FileListProps) {\n  const actualEditingFileId = editingFileId || editingFile;\n\n  const [localEditName, setLocalEditName] = useState<string>('');\n  const [localEditTags, setLocalEditTags] = useState<string[]>([]);\n  const [localNewTag, setLocalNewTag] = useState<string>('');\n  \n  const editName = providedEditingName !== undefined ? providedEditingName : localEditName;\n  const editTags = providedEditingTags !== undefined ? providedEditingTags : localEditTags;\n  const newTagValue = providedNewTag !== undefined ? providedNewTag : localNewTag;\n  \n  const setEditName = (value: string) => {\n    if (onEditNameChange) {\n      onEditNameChange(value);\n    } else {\n      setLocalEditName(value);\n    }\n  };\n  \n  const setEditTags = (tags: string[]) => {\n    setLocalEditTags(tags);\n  };\n  \n  const setNewTag = (value: string) => {\n    if (onNewTagChange) {\n      onNewTagChange(value);\n    } else {\n      setLocalNewTag(value);\n    }\n  };\n\n  const editNameInputRef = useRef<HTMLInputElement>(null);\n  const newTagInputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (actualEditingFileId && providedEditingName === undefined) {\n      const file = files.find(f => f.id === actualEditingFileId);\n      if (file) {\n        setLocalEditName(file.name);\n        setLocalEditTags(file.tags || []);\n      }\n    }\n    \n    if (actualEditingFileId) {\n      setTimeout(() => {\n        if (editNameInputRef.current) {\n          editNameInputRef.current.focus();\n          editNameInputRef.current.select();\n        }\n      }, 0);\n    }\n  }, [actualEditingFileId, files, providedEditingName]);\n\n  const handleEditKeyDown = (e: React.KeyboardEvent, fileId: string) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      onConfirmEdit && onConfirmEdit(fileId, editName, editTags);\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancelEdit && onCancelEdit();\n    }\n  };\n\n  const handleAddTag = () => {\n    const trimmedTag = newTagValue.trim();\n    if (!trimmedTag) return;\n    \n    if (!editTags.includes(trimmedTag)) {\n      if (onAddTag) {\n        onAddTag(trimmedTag);\n      } else {\n        setEditTags([...editTags, trimmedTag]);\n      }\n      setNewTag('');\n      \n      setTimeout(() => {\n        if (newTagInputRef.current) {\n          newTagInputRef.current.focus();\n        }\n      }, 0);\n    }\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    if (onRemoveTag) {\n      onRemoveTag(tagToRemove);\n    } else {\n      setEditTags(editTags.filter(tag => tag !== tagToRemove));\n    }\n  };\n\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      handleAddTag();\n    }\n  };\n\n  const handleFileCheckboxChange = (file: FileInfo, checked: boolean) => {\n    if (onFileSelect) {\n      onFileSelect(file, checked);\n      return;\n    }\n    \n    if (onSelectFiles) {\n      if (checked) {\n        onSelectFiles([...selectedFiles, file.id]);\n      } else {\n        onSelectFiles(selectedFiles.filter(id => id !== file.id));\n      }\n    } else {\n      console.error('FileList: 缺少必要的onSelectFiles或onFileSelect回调函数');\n    }\n  };\n\n  const handleSelectAll = onSelectAll || onSelectAllFiles;\n  const handleDeselectAll = onDeselectAll || onDeselectAllFiles;\n\n  const renderFileIcon = (type?: string, extension?: string, isFolder?: boolean) => {\n    if (isFolder) return <Folder className={styles.fileIcon} />;\n    \n    const getFileIconType = () => {\n      if (!type) return 'file';\n      \n      if (type.includes('image')) return 'image';\n      if (type.includes('text') || type.includes('document') || extension?.match(/docx?|pdf|txt|md/i)) return 'file-text';\n      if (type.includes('video')) return 'video';\n      if (type.includes('audio')) return 'music';\n      if (extension?.match(/zip|rar|7z|tar|gz/i)) return 'archive';\n      if (extension?.match(/js|ts|jsx|tsx|py|java|c|cpp|go|rb|php|html|css/i)) return 'code';\n      \n      return 'file';\n    };\n    \n    const iconType = getFileIconType();\n    const IconComponent = {\n      'folder': Folder,\n      'file': FileIcon,\n      'image': ImageIcon,\n      'file-text': FileText,\n      'video': Video,\n      'music': Music,\n      'archive': FileIcon,\n      'code': FileIcon\n    }[iconType] || FileIcon;\n\n    return <IconComponent className={styles.fileIcon} />;\n  };\n\n  const renderTags = (file: FileInfo) => {\n    const tags = file.tags || [];\n    \n    if (actualEditingFileId === file.id) {\n      return (\n        <div className={styles.tagEditContainer}>\n          <div className={styles.editTagsList}>\n            {editTags.map((tag, index) => (\n              <div key={index} className={styles.editTag}>\n                <span>{tag}</span>\n                <button \n                  className={styles.removeTagButton}\n                  onClick={() => handleRemoveTag(tag)}\n                >\n                  <X size={12} />\n                </button>\n              </div>\n            ))}\n          </div>\n          <div className={styles.addTagInput}>\n            <input\n              ref={newTagInputRef}\n              type=\"text\"\n              placeholder=\"添加标签...\"\n              value={localNewTag}\n              onChange={(e) => setNewTag(e.target.value)}\n              onKeyDown={handleTagKeyDown}\n              className={styles.tagInput}\n            />\n            <button \n              className={styles.addTagButton}\n              onClick={handleAddTag}\n            >\n              <Plus size={14} />\n            </button>\n          </div>\n        </div>\n      );\n    }\n    \n    if (!tags || tags.length === 0) return <span className={styles.emptyText}>-</span>;\n    \n    const maxTagsToShow = 3;\n    const visibleTags = tags.slice(0, maxTagsToShow);\n    const extraTagsCount = tags.length - maxTagsToShow;\n    \n    return (\n      <div className={styles.tagContainer}>\n        {visibleTags.map((tag, index) => (\n          <span key={index} className={styles.tag}>\n            {tag}\n          </span>\n        ))}\n        {extraTagsCount > 0 && (\n          <span className={styles.extraTagsCount}>+{extraTagsCount}</span>\n        )}\n      </div>\n    );\n  };\n\n  const isAllSelected = areAllSelected !== undefined \n    ? areAllSelected \n    : (files.length > 0 && selectedFiles.length === files.length);\n\n  if (!Array.isArray(files) || files.length === 0) {\n    const getEmptyStateMessage = () => {\n      if (fileTypeFilter) {\n        switch(fileTypeFilter) {\n          case 'image':\n            return `您的存储空间中没有找到图片文件`;\n          case 'document':\n            return `您的存储空间中没有找到文档文件`;\n          case 'video':\n            return `您的存储空间中没有找到视频文件`;\n          case 'audio':\n            return `您的存储空间中没有找到音频文件`;\n          case 'other':\n            return `您的存储空间中没有找到其他类型的文件`;\n          default:\n            return `没有找到${fileTypeFilter}类型的文件`;\n        }\n      }\n      return '没有文件';\n    };\n\n    const getEmptyStateIcon = () => {\n      if (fileTypeFilter) {\n        return <Filter size={50} stroke=\"#CBD5E0\" />;\n      }\n      return <FileIcon size={50} stroke=\"#CBD5E0\" />;\n    };\n\n    const getEmptyStateHint = () => {\n      if (fileTypeFilter) {\n        return `系统已搜索所有文件夹，未找到${\n          fileTypeFilter === 'image' ? '图片' : \n          fileTypeFilter === 'document' ? '文档' : \n          fileTypeFilter === 'video' ? '视频' :\n          fileTypeFilter === 'audio' ? '音频' : '该类型'\n        }文件，您可以上传一些，或选择其他文件类型查看。`;\n      }\n      return '上传文件或创建文件夹以开始管理您的文件';\n    };\n\n    return (\n      <div className={styles.emptyState}>\n        {getEmptyStateIcon()}\n        <p className={styles.emptyStateText}>{getEmptyStateMessage()}</p>\n        <p className={styles.emptyStateHint}>\n          {getEmptyStateHint()}\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.fileListWrapper}>\n      <div className={styles.fileListContainer}>\n        <table className={styles.fileTable}>\n          <thead>\n            <tr>\n              <th>\n                <input\n                  type=\"checkbox\"\n                  checked={isAllSelected}\n                  onChange={isAllSelected ? \n                    () => handleDeselectAll && handleDeselectAll() : \n                    () => handleSelectAll && handleSelectAll()}\n                  disabled={!showCheckboxes}\n                />\n              </th>\n              <th>名称</th>\n              <th>类型</th>\n              <th>大小</th>\n              <th>标签</th>\n              <th>修改日期</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            {files.map((file) => {\n              const isSelected = selectedFiles.includes(file.id);\n              const isEditing = actualEditingFileId === file.id;\n              \n              return (\n                <tr\n                  key={file.id}\n                  className={`${styles.fileRow} ${isSelected ? styles.selectedRow : ''} ${isEditing ? styles.editingRow : ''}`}\n                  onClick={() => !isEditing && onFileClick(file)}\n                  onDoubleClick={() => {\n                    if (!isEditing && onStartEdit && !file.isFolder) {\n                      onStartEdit(file);\n                    } else if (!isEditing && onFileDoubleClick) {\n                      onFileDoubleClick(file);\n                    }\n                  }}\n                  onContextMenu={(e) => !isEditing && onFileContextMenu && onFileContextMenu(e, file)}\n                >\n                  <td>\n                    {showCheckboxes && (\n                      <input\n                        type=\"checkbox\"\n                        checked={isSelected}\n                        onChange={(e) => handleFileCheckboxChange(file, e.target.checked)}\n                        onClick={(e) => e.stopPropagation()}\n                        disabled={isEditing}\n                      />\n                    )}\n                  </td>\n                  <td className={styles.fileNameCell}>\n                    <span className={styles.fileIcon}>\n                      {renderFileIcon(file.type, file.extension, file.isFolder)}\n                    </span>\n                    {isEditing ? (\n                      <input\n                        ref={editNameInputRef}\n                        type=\"text\"\n                        className={styles.fileNameInput}\n                        value={editName}\n                        onChange={(e) => setEditName(e.target.value)}\n                        onKeyDown={(e) => handleEditKeyDown(e, file.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        autoComplete=\"off\"\n                      />\n                    ) : (\n                      <span className={styles.fileName}>{file.name}</span>\n                    )}\n                    {isEditing && (\n                      <div className={styles.editActions}>\n                        <button \n                          className={styles.editActionButton}\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            onConfirmEdit && onConfirmEdit(file.id, editName, editTags);\n                          }}\n                        >\n                          <Check size={16} />\n                        </button>\n                        <button \n                          className={styles.editActionButton}\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            onCancelEdit && onCancelEdit();\n                          }}\n                        >\n                          <X size={16} />\n                        </button>\n                      </div>\n                    )}\n                  </td>\n                  <td>{file.isFolder ? '文件夹' : \n                     file.type === 'document' ? '文档' : \n                     getFileTypeDisplay(file.type || null, file.extension)}</td>\n                  <td>{file.size ? `${Math.round(file.size / 1024)} KB` : '-'}</td>\n                  <td className={styles.tagsCell}>{renderTags(file)}</td>\n                  <td>\n                    {file.createdAt \n                      ? new Date(file.createdAt).toLocaleString() \n                      : '-'\n                    }\n                  </td>\n                  <td>\n                    {!isEditing ? (\n                      <button \n                        className={styles.actionButton}\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          if (onStartEdit) {\n                            onStartEdit(file);\n                          } else if (onFileContextMenu) {\n                            onFileContextMenu(e, file);\n                          }\n                        }}\n                      >\n                        <MoreVertical size={16} />\n                      </button>\n                    ) : (\n                      <span className={styles.editingMessage}>编辑中</span>\n                    )}\n                  </td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n}"
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\index.ts",
    "newContent": "export * from './Sidebar';\nexport * from './Breadcrumb';\nexport * from './FileList';\n// export * from './UploadModal'; // 已迁移到 @/app/components/features/file-management/upload/UploadModal\n// export * from './UploadButton'; // 已迁移到 @/app/components/features/file-management/upload/UploadButton\nexport * from './Skeleton';\nexport * from './ErrorDisplay'; "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\Sidebar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/navigation/Sidebar 组件。\n */\n\nimport React, { useEffect } from 'react';\nimport { \n  Folder, Files, Image as ImageIcon, FileText, \n  Video, Music, File, Search, ChevronDown, \n  Star, Clock, Tag, Download, Settings,\n  CheckCircle\n} from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\n\nexport type FileType = 'image' | 'document' | 'video' | 'audio' | 'other' | null;\n\ninterface SidebarProps {\n  selectedFileType: FileType;\n  onTypeClick: (type: FileType) => void;\n  onSearchClick?: () => void;\n}\n\nexport function Sidebar({ selectedFileType, onTypeClick, onSearchClick }: SidebarProps) {\n  const fileTypes: { type: FileType; label: string; icon: React.ElementType }[] = [\n    { type: null, label: '全部文件', icon: Files },\n    { type: 'image', label: '图片', icon: ImageIcon },\n    { type: 'document', label: '文档', icon: FileText },\n    { type: 'video', label: '视频', icon: Video },\n    { type: 'audio', label: '音频', icon: Music },\n    { type: 'other', label: '其他', icon: File }\n  ];\n\n  const [quickAccessExpanded, setQuickAccessExpanded] = React.useState(true);\n  const [myFilesExpanded, setMyFilesExpanded] = React.useState(true);\n  const [settingsExpanded, setSettingsExpanded] = React.useState(false);\n\n  // 监听文件类型变化并记录日志\n  useEffect(() => {\n    console.log('侧边栏：当前选择的文件类型:', selectedFileType);\n  }, [selectedFileType]);\n\n  const handleTypeClick = (type: FileType) => {\n    // 直接调用回调，不需要任何额外逻辑\n    console.log('Sidebar直接点击类型:', type);\n    onTypeClick(type);\n  };\n\n  return (\n    <div className={styles.sidebar}>\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader} \n          onClick={() => setMyFilesExpanded(!myFilesExpanded)}\n        >\n          <Folder className={styles.icon} />\n          我的文件\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: myFilesExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {myFilesExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            {fileTypes.map(({ type, label, icon: Icon }) => (\n              <div\n                key={type || 'all'}\n                className={`${styles.sidebarItem} ${selectedFileType === type ? styles.active : ''}`}\n                onClick={() => handleTypeClick(type)}\n              >\n                <Icon className={styles.icon} />\n                {label}\n                {selectedFileType === type && (\n                  <CheckCircle \n                    className={styles.icon} \n                    style={{ \n                      marginLeft: 'auto', \n                      color: 'var(--theme-primary, #3b82f6)',\n                      fill: 'var(--theme-primary, #3b82f6)',\n                      stroke: '#fff',\n                      opacity: 0.9,\n                    }} \n                    size={16} \n                  />\n                )}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader}\n          onClick={() => setQuickAccessExpanded(!quickAccessExpanded)}\n        >\n          <Search className={styles.icon} />\n          快捷查询\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: quickAccessExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {quickAccessExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            <div \n              className={styles.sidebarItem}\n              onClick={onSearchClick}\n            >\n              <Search className={styles.icon} />\n              搜索文件\n            </div>\n            <div className={styles.sidebarItem}>\n              <Star className={styles.icon} />\n              收藏文件\n            </div>\n            <div className={styles.sidebarItem}>\n              <Clock className={styles.icon} />\n              最近访问\n            </div>\n            <div className={styles.sidebarItem}>\n              <Tag className={styles.icon} />\n              按标签查找\n            </div>\n            <div className={styles.sidebarItem}>\n              <Download className={styles.icon} />\n              下载记录\n            </div>\n          </div>\n        )}\n      </div>\n\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader}\n          onClick={() => setSettingsExpanded(!settingsExpanded)}\n        >\n          <Settings className={styles.icon} />\n          系统设置\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: settingsExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {settingsExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            <div className={styles.sidebarItem}>\n              <Settings className={styles.icon} />\n              存储管理\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\Skeleton.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/shared/Skeleton 组件。\n */\n\n'use client';\n\nimport React from 'react';\nimport styles from './Skeleton.module.css';\n\ninterface SkeletonProps {\n  variant?: 'sidebar' | 'file' | 'avatar' | 'text' | 'button' | 'card';\n  width?: string | number;\n  height?: string | number;\n  animation?: 'pulse' | 'wave' | 'none';\n  count?: number;\n  className?: string;\n  borderRadius?: string;\n}\n\nexport const Skeleton: React.FC<SkeletonProps> = ({ \n  variant = 'text', \n  width, \n  height, \n  animation = 'pulse',\n  count = 1,\n  className = '',\n  borderRadius\n}) => {\n  const getVariantStyles = () => {\n    switch (variant) {\n      case 'sidebar':\n        return {\n          width: width || '100%',\n          height: height || '40px',\n          borderRadius: borderRadius || '8px'\n        };\n      case 'file':\n        return {\n          width: width || '100%',\n          height: height || '56px',\n          borderRadius: borderRadius || '8px'\n        };\n      case 'avatar':\n        return {\n          width: width || '40px',\n          height: height || '40px',\n          borderRadius: borderRadius || '50%'\n        };\n      case 'text':\n        return {\n          width: width || '100%',\n          height: height || '16px',\n          borderRadius: borderRadius || '4px'\n        };\n      case 'button':\n        return {\n          width: width || '120px',\n          height: height || '36px',\n          borderRadius: borderRadius || '6px'\n        };\n      case 'card':\n        return {\n          width: width || '100%',\n          height: height || '200px',\n          borderRadius: borderRadius || '12px'\n        };\n      default:\n        return {\n          width: width || '100%',\n          height: height || '16px',\n          borderRadius: borderRadius || '4px'\n        };\n    }\n  };\n\n  const renderSkeleton = () => {\n    const items = [];\n    const baseStyles = getVariantStyles();\n    \n    for (let i = 0; i < count; i++) {\n      items.push(\n        <div \n          key={i}\n          className={`${styles.skeleton} ${styles[`animation-${animation}`]} ${className}`}\n          style={{\n            ...baseStyles,\n            marginBottom: count > 1 && i < count - 1 ? '8px' : '0'\n          }}\n        />\n      );\n    }\n    \n    return items;\n  };\n\n  return <>{renderSkeleton()}</>;\n};\n\nexport const SkeletonFileList: React.FC = () => {\n  return (\n    <div className={styles.fileListSkeleton}>\n      <div className={styles.fileListHeader}>\n        <Skeleton variant=\"text\" width=\"15%\" height=\"24px\" />\n        <div className={styles.headerActions}>\n          <Skeleton variant=\"button\" width=\"100px\" />\n          <Skeleton variant=\"button\" width=\"100px\" />\n        </div>\n      </div>\n      \n      <div className={styles.fileItems}>\n        {[...Array(8)].map((_, index) => (\n          <div key={index} className={styles.fileItemSkeleton}>\n            <div className={styles.fileIcon}>\n              <Skeleton variant=\"avatar\" width=\"32px\" height=\"32px\" borderRadius=\"6px\" />\n            </div>\n            <div className={styles.fileDetails}>\n              <Skeleton variant=\"text\" width=\"60%\" height=\"18px\" />\n              <Skeleton variant=\"text\" width=\"40%\" height=\"14px\" />\n            </div>\n            <div className={styles.fileActions}>\n              <Skeleton variant=\"button\" width=\"70px\" />\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport const SkeletonSidebar: React.FC = () => {\n  return (\n    <div className={styles.sidebarSkeleton}>\n      <div className={styles.sidebarHeader}>\n        <Skeleton variant=\"text\" width=\"70%\" height=\"24px\" />\n      </div>\n      <div className={styles.sidebarContent}>\n        <Skeleton variant=\"sidebar\" count={5} />\n        <div className={styles.sidebarSection}>\n          <Skeleton variant=\"text\" width=\"50%\" height=\"18px\" />\n          <Skeleton variant=\"sidebar\" count={3} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport const SkeletonPageLayout: React.FC = () => {\n  return (\n    <div className={styles.pageLayoutSkeleton}>\n      <div className={styles.miniSidebarSkeleton}>\n        <Skeleton variant=\"avatar\" width=\"40px\" height=\"40px\" />\n        <Skeleton variant=\"button\" width=\"40px\" height=\"40px\" borderRadius=\"12px\" />\n        <Skeleton variant=\"button\" width=\"40px\" height=\"40px\" borderRadius=\"12px\" />\n      </div>\n      \n      <div className={styles.sidebarContainerSkeleton}>\n        <SkeletonSidebar />\n      </div>\n      \n      <div className={styles.mainContentSkeleton}>\n        <div className={styles.topBarSkeleton}>\n          <div className={styles.breadcrumbSkeleton}>\n            <Skeleton variant=\"text\" width=\"180px\" height=\"20px\" />\n          </div>\n          <div className={styles.actionButtonsSkeleton}>\n            <Skeleton variant=\"button\" width=\"100px\" />\n            <Skeleton variant=\"button\" width=\"100px\" />\n          </div>\n        </div>\n        \n        <SkeletonFileList />\n      </div>\n    </div>\n  );\n}; "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\UploadButton.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/upload/UploadButton 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Upload, Folder, ChevronDown } from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { UploadModal } from './UploadModal';\n\ninterface UploadButtonProps {\n  showDropdown: boolean;\n  setShowDropdown: (show: boolean) => void;\n  setIsModalOpen: (open: boolean) => void;\n  setIsFolderModalOpen: (open: boolean) => void;\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\n}\n\nexport function UploadButton({ \n  showDropdown, \n  setShowDropdown, \n  setIsModalOpen, \n  setIsFolderModalOpen,\n  uploadDropdownRef \n}: UploadButtonProps) {\n  \n  // 处理上传按钮点击\n  const handleUploadClick = (type: 'file' | 'folder') => {\n    if (type === 'file') {\n      setIsModalOpen(true);\n    } else {\n      setIsFolderModalOpen(true);\n    }\n    setShowDropdown(false);\n  };\n\n  return (\n    <div className={styles.uploadOptionsContainer} ref={uploadDropdownRef}>\n      <button\n        className={`${styles.uploadButton} ${showDropdown ? styles.activeButton : ''}`}\n        onClick={() => setShowDropdown(!showDropdown)}\n      >\n        <Upload size={18} className={styles.buttonIcon} />\n        上传文件\n        <ChevronDown size={16} className={styles.dropdownIcon} />\n      </button>\n      \n      {showDropdown && (\n        <div className={styles.dropdownMenu}>\n          <div \n            className={styles.dropdownItem}\n            onClick={() => handleUploadClick('file')}\n          >\n            <Upload size={16} className=\"mr-2\" />\n            <span>上传文件</span>\n          </div>\n          <div \n            className={styles.dropdownItem}\n            onClick={() => handleUploadClick('folder')}\n          >\n            <Folder size={16} className=\"mr-2\" />\n            <span>上传文件夹</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\file-management\\shared\\UploadModal.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/upload/UploadModal 组件。\n */\n\nimport React, { useState, useEffect, useRef, KeyboardEvent } from 'react';\nimport { InboxOutlined, CloseCircleOutlined, TagOutlined, CloseOutlined } from '@ant-design/icons';\nimport { Modal, Upload, Input, message, Button, Tag } from 'antd';\nimport type { RcFile, UploadFile } from 'antd/es/upload/interface';\nimport type { UploadProps } from 'antd';\nimport type { InputRef } from 'antd/es/input';\nimport { FileInfo, FileResponse } from '@/app/types';\nimport styles from '../../styles/shared.module.css';\nimport { useSession } from 'next-auth/react';\nimport { API_PATHS } from '@/app/lib/api/paths';\n\nconst { Dragger } = Upload;\n\ninterface UploadModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSuccess: (files?: FileInfo[]) => void;\n  isFolderUpload?: boolean;\n  currentFolderId?: string | null;\n}\n\n// 扩展UploadFile类型，添加webkitRelativePath属性\ninterface ExtendedUploadFile extends UploadFile<any> {\n  webkitRelativePath?: string;\n}\n\nexport function UploadModal({\n  isOpen,\n  onClose,\n  onSuccess,\n  isFolderUpload = false,\n  currentFolderId\n}: UploadModalProps) {\n  const [fileList, setFileList] = useState<ExtendedUploadFile[]>([]);\n  const [tagInput, setTagInput] = useState<string>('');\n  const [tagList, setTagList] = useState<string[]>([]);\n  const [uploading, setUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const tagInputRef = useRef<InputRef>(null);\n  const { data: session } = useSession();\n\n  useEffect(() => {\n    // 当模态框打开时检查登录状态\n    if (isOpen && !session) {\n      message.error('请先登录后再上传文件');\n      onClose();\n    }\n  }, [isOpen, session, onClose]);\n\n  // 处理文件选择\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFiles = e.target.files;\n    if (!selectedFiles || selectedFiles.length === 0) return;\n\n    const newFiles: ExtendedUploadFile[] = [];\n    for (let i = 0; i < selectedFiles.length; i++) {\n      const file = selectedFiles[i];\n      newFiles.push({\n        uid: `file-${Date.now()}-${i}`,\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        originFileObj: file as any,\n        webkitRelativePath: file.webkitRelativePath, // 添加相对路径\n      });\n    }\n\n    setFileList(prev => [...prev, ...newFiles]);\n    \n    // 清空input以允许再次选择相同的文件\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  // 处理标签输入\n  const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTagInput(e.target.value);\n  };\n\n  // 处理标签输入的回车事件\n  const handleTagInputKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter' && tagInput.trim()) {\n      e.preventDefault();\n      addTag(tagInput.trim());\n    }\n  };\n\n  // 添加标签\n  const addTag = (tag: string) => {\n    if (!tag) return;\n    \n    // 检查标签是否已存在\n    if (!tagList.includes(tag)) {\n      setTagList(prev => [...prev, tag]);\n    }\n    \n    // 清空输入框\n    setTagInput('');\n    \n    // 聚焦回输入框，方便继续输入\n    if (tagInputRef.current) {\n      setTimeout(() => {\n        tagInputRef.current?.focus();\n      }, 0);\n    }\n  };\n\n  // 删除标签\n  const removeTag = (tagToRemove: string) => {\n    setTagList(tagList.filter(tag => tag !== tagToRemove));\n  };\n\n  const handleUpload = async () => {\n    if (fileList.length === 0) {\n      message.warning('请选择要上传的文件');\n      return;\n    }\n\n    setUploading(true);\n\n    try {\n      const formData = new FormData();\n      \n      // 添加所有文件到FormData\n      let filesAdded = 0;\n      fileList.forEach((file, index) => {\n        const rawFile = file.originFileObj;\n        if (rawFile instanceof File) {\n          // 使用'file'字段名，与后端对应\n          formData.append('file', rawFile);\n          \n          // 如果是文件夹上传，添加相对路径信息\n          if (isFolderUpload && file.webkitRelativePath) {\n            // 使用数字索引作为键，确保后端可以正确解析\n            formData.append(`paths_${index}`, file.webkitRelativePath);\n            console.log(`文件 ${index}: ${file.name} - 路径: ${file.webkitRelativePath}`);\n          }\n          \n          filesAdded++;\n          console.log(`添加文件 ${index+1}: ${file.name}, 大小: ${file.size} 字节`);\n        } else {\n          console.warn(`无法获取文件 ${index+1}: ${file.name} 的原始File对象`);\n        }\n      });\n      \n      if (filesAdded === 0) {\n        throw new Error('无法处理上传文件，请重新选择文件');\n      }\n      \n      // 添加标志表明这是文件夹上传\n      if (isFolderUpload) {\n        formData.append('isFolderUpload', 'true');\n        console.log('文件夹上传模式已启用');\n      }\n      \n      // 将标签数组转换为逗号分隔的字符串\n      if (tagList.length > 0) {\n        formData.append('tags', JSON.stringify(tagList));\n        console.log('添加标签:', tagList);\n      }\n\n      if (currentFolderId) {\n        formData.append('folderId', currentFolderId);\n        console.log('当前文件夹ID:', currentFolderId);\n      }\n\n      console.log(`准备上传 ${filesAdded} 个文件...`);\n      \n      // 显示上传开始消息\n      const uploadKey = `upload-${Date.now()}`;\n      message.loading({ content: '正在上传文件...', key: uploadKey, duration: 0 });\n\n      // 使用fetch发送请求\n      const response = await fetch(API_PATHS.STORAGE.FILES.UPLOAD, {\n        method: 'POST',\n        body: formData,\n      });\n\n      // 获取响应\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n      \n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        // 如果不是JSON响应，尝试获取文本\n        const text = await response.text();\n        console.error('服务器返回了非JSON响应:', text);\n        throw new Error('服务器返回了无效的响应格式');\n      }\n      \n      // 检查响应状态\n      if (!response.ok) {\n        console.error('上传响应错误:', data);\n        \n        // 显示错误消息\n        message.error({ \n          content: `上传失败: ${data.details || data.error || '服务器错误'}`, \n          key: uploadKey,\n          duration: 5 \n        });\n        \n        throw new Error(data.details || data.error || '上传失败');\n      }\n\n      // 上传成功处理\n      console.log('上传成功:', data);\n      message.success({ content: '上传成功', key: uploadKey, duration: 3 });\n      \n      // 关闭模态框并通知父组件\n      handleClose();\n      if (typeof onSuccess === 'function') {\n        onSuccess(data.files || (data.file ? [data.file] : undefined));\n      } else {\n        console.warn('onSuccess不是一个函数，无法通知上传成功');\n      }\n    } catch (error) {\n      console.error('上传过程中出错:', error);\n      message.error(`上传失败: ${error instanceof Error ? error.message : '未知错误'}`);\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  const handleClose = () => {\n    setFileList([]);\n    setTagInput('');\n    setTagList([]);\n    onClose();\n  };\n  \n  // 直接使用原生文件输入\n  const triggerFileInput = () => {\n    if (fileInputRef.current) {\n      fileInputRef.current.click();\n    }\n  };\n  \n  const removeFile = (index: number) => {\n    setFileList(prev => prev.filter((_, i) => i !== index));\n  };\n\n  return (\n    <Modal\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\n      open={isOpen}\n      onCancel={handleClose}\n      onOk={handleUpload}\n      okText=\"上传\"\n      cancelText=\"取消\"\n      confirmLoading={uploading}\n      width={600}\n    >\n      <div className={styles.uploadContainer || ''}>\n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          onChange={handleFileChange}\n          style={{ display: 'none' }}\n          multiple={true}\n          {...(isFolderUpload ? { webkitdirectory: '', directory: '', mozdirectory: '', msdirectory: '' } : {})}\n        />\n        \n        <div \n          className={styles.dropzone || ''}\n          onClick={triggerFileInput}\n          style={{ \n            border: '2px dashed #d9d9d9',\n            borderRadius: '4px',\n            padding: '20px',\n            textAlign: 'center',\n            cursor: 'pointer',\n            marginBottom: '16px'\n          }}\n        >\n          <p><InboxOutlined style={{ fontSize: '48px', color: '#40a9ff' }} /></p>\n          <p style={{ marginTop: '8px', fontWeight: 'bold' }}>\n            点击或拖拽{isFolderUpload ? '文件夹' : '文件'}到此区域上传\n          </p>\n          <p style={{ color: '#888' }}>\n            {isFolderUpload\n              ? '支持上传整个文件夹及其内部文件，保留文件夹结构'\n              : '支持单个或批量上传文件，最大支持同时选择50个文件'}\n          </p>\n          <Button type=\"primary\" onClick={(e) => { e.stopPropagation(); triggerFileInput(); }}>\n            选择{isFolderUpload ? '文件夹' : '文件'}\n          </Button>\n        </div>\n        \n        {fileList.length > 0 && (\n          <div style={{ marginBottom: '16px' }}>\n            <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n              已选择 {fileList.length} 个文件:\n            </div>\n            <ul style={{ maxHeight: '150px', overflowY: 'auto', padding: '0 0 0 20px' }}>\n              {fileList.map((file, index) => (\n                <li key={file.uid} style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>\n                  <span>\n                    {file.name} \n                    {isFolderUpload && file.webkitRelativePath && (\n                      <span style={{ fontSize: '12px', color: '#8c8c8c', marginLeft: '4px' }}>\n                        (路径: {file.webkitRelativePath.split('/').slice(0, -1).join('/')})\n                      </span>\n                    )}\n                    ({((file.size || 0) / 1024).toFixed(2)} KB)\n                  </span>\n                  <Button \n                    type=\"text\" \n                    danger \n                    onClick={() => removeFile(index)}\n                    style={{ padding: '0 4px' }}\n                  >\n                    删除\n                  </Button>\n                </li>\n              ))}\n            </ul>\n          </div>\n        )}\n\n        <div style={{ marginTop: 16 }}>\n          <div style={{ marginBottom: '8px', display: 'flex', alignItems: 'center' }}>\n            <span style={{ fontWeight: 'bold', marginRight: '8px' }}>添加标签:</span>\n            <span style={{ fontSize: '12px', color: '#8c8c8c' }}>\n              (输入标签后按回车添加)\n            </span>\n          </div>\n          \n          <div className={styles.tagsInputWrapper}>\n            <Input\n              ref={tagInputRef}\n              placeholder=\"输入标签后按回车添加\"\n              value={tagInput}\n              onChange={handleTagInputChange}\n              onKeyDown={handleTagInputKeyDown}\n              prefix={<TagOutlined style={{ color: '#bfbfbf' }} />}\n              suffix={\n                <span style={{ color: '#bfbfbf', fontSize: '12px' }}>\n                  按回车添加\n                </span>\n              }\n            />\n          </div>\n          \n          <div className={styles.tagsContainer}>\n            {tagList.length > 0 ? (\n              <div className={styles.tagsList}>\n                {tagList.map((tag, index) => (\n                  <Tag\n                    key={index}\n                    closable\n                    onClose={() => removeTag(tag)}\n                    className={styles.interactiveTag}\n                  >\n                    {tag}\n                  </Tag>\n                ))}\n              </div>\n            ) : (\n              <div className={styles.emptyTagsHint}>\n                添加一些标签来帮助管理您的文件\n              </div>\n            )}\n          </div>\n        </div>\n\n        <div style={{ marginTop: '16px', padding: '12px', background: '#f5f5f5', borderRadius: '8px', fontSize: '13px', color: '#555' }}>\n          <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n            {isFolderUpload ? '文件夹上传说明:' : '文件上传说明:'}\n          </div>\n          <ul style={{ paddingLeft: '16px', margin: '0' }}>\n            {isFolderUpload ? (\n              <>\n                <li>支持上传整个文件夹及其子文件夹结构</li>\n                <li>保留完整的文件夹层次结构</li>\n                <li>目前仅Chrome、Edge等现代浏览器支持文件夹选择</li>\n                <li>如果您的浏览器不支持文件夹选择，请选择单个文件模式</li>\n              </>\n            ) : (\n              <>\n                <li>支持批量上传多个文件</li>\n                <li>支持常见的文件格式（图片、文档、视频等）</li>\n                <li>每个文件大小限制为50MB</li>\n                <li>一次最多可选择50个文件</li>\n              </>\n            )}\n            <li>您可以为上传的文件添加标签，以便更好地组织和查找</li>\n          </ul>\n        </div>\n      </div>\n    </Modal>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\file-management\\SortDropdown.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/actionBar/SortDropdown 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport styles from '../styles/SortDropdown.module.css';\nimport { FileSortInterface, SortDirectionEnum } from '@/app/types';\n\ninterface SortDropdownProps {\n  sortOrder: FileSortInterface;\n  onSortChange: (order: FileSortInterface) => void;\n}\n\nexport const SortDropdown: React.FC<SortDropdownProps> = ({\n  sortOrder,\n  onSortChange\n}) => {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n        setShowDropdown(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  // 根据当前排序字段获取显示文本\n  const getSortFieldText = () => {\n    switch(sortOrder.field) {\n      case 'name': return '文件名';\n      case 'size': return '大小';\n      case 'createdAt': return '时间';\n      default: return '默认';\n    }\n  };\n\n  return (\n    <div className={styles.sortDropdown} ref={dropdownRef}>\n      <button \n        className={styles.topButton}\n        onClick={() => setShowDropdown(!showDropdown)}\n        style={{ \n          background: showDropdown ? '#f0f7ff' : 'white',\n          borderColor: showDropdown ? '#60a5fa' : '#e8e8e8'\n        }}\n      >\n        <span>↕️</span>\n        排序: {getSortFieldText()} {sortOrder.direction === SortDirectionEnum.ASC ? '↑' : '↓'}\n      </button>\n      {showDropdown && (\n        <div className={styles.dropdownMenu}>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'name',\n                direction: sortOrder.field === 'name' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'name' ? 'bold' : 'normal',\n              background: sortOrder.field === 'name' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>📝</span>\n            按文件名{sortOrder.field === 'name' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'size',\n                direction: sortOrder.field === 'size' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'size' ? 'bold' : 'normal',\n              background: sortOrder.field === 'size' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>📊</span>\n            按大小{sortOrder.field === 'size' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'createdAt',\n                direction: sortOrder.field === 'createdAt' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'createdAt' ? 'bold' : 'normal',\n              background: sortOrder.field === 'createdAt' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>🕒</span>\n            按时间{sortOrder.field === 'createdAt' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SortDropdown; "
  },
  {
    "path": "app\\components\\features\\file-management\\Toolbar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/toolbar/Toolbar 组件。\n */\n\nimport React, { useRef, useState } from 'react';\nimport { useFileContext } from '../context/FileContext';\nimport { X, Download, Edit, Move } from 'lucide-react';\nimport { message } from 'antd';\nimport styles from './Toolbar.module.css';\nimport commonStyles from '../styles/common.module.css';\n\ninterface ToolbarProps {\n  onUploadClick: () => void;\n  onFolderUploadClick: () => void;\n  onCreateFolderClick: () => void;\n}\n\nexport function Toolbar({ onUploadClick, onFolderUploadClick, onCreateFolderClick }: ToolbarProps) {\n  const {\n    selectedFiles,\n    clearSelection,\n    files\n  } = useFileContext();\n\n  const [showUploadDropdown, setShowUploadDropdown] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n\n  const handleDownload = () => {\n    // TODO: 实现文件下载功能\n    message.info('下载功能开发中');\n  };\n\n  const handleRename = () => {\n    if (selectedFiles.length !== 1) {\n      message.warning('请选择一个文件进行重命名');\n      return;\n    }\n    const selectedFile = files.find(file => file.id === selectedFiles[0]);\n    if (selectedFile) {\n      // TODO: 实现重命名功能\n      message.info('重命名功能开发中');\n    }\n  };\n\n  return (\n    <div className={styles.topBar}>\n      <div className={styles.buttonGroup}>\n        {selectedFiles.length > 0 ? (\n          <>\n            <button className={styles.topButton} onClick={() => clearSelection()}>\n              <X className={commonStyles.icon} />\n              取消选择\n            </button>\n            <button className={styles.topButton} onClick={handleDownload}>\n              <Download className={commonStyles.icon} />\n              下载\n            </button>\n            <button className={styles.topButton} onClick={handleRename}>\n              <Edit className={commonStyles.icon} />\n              重命名\n            </button>\n            <button className={styles.topButton}>\n              <Move className={commonStyles.icon} />\n              移动\n            </button>\n          </>\n        ) : (\n          <>\n            <div className={styles.uploadDropdown} ref={dropdownRef}>\n              <button\n                className={styles.topButton}\n                onClick={() => setShowUploadDropdown(!showUploadDropdown)}\n              >\n                <span className={styles.buttonIcon}>⬆️</span>\n                上传\n                <span className={styles.dropdownArrow}>▼</span>\n              </button>\n              {showUploadDropdown && (\n                <div className={styles.dropdownMenu}>\n                  <button\n                    className={styles.dropdownItem}\n                    onClick={() => {\n                      onUploadClick();\n                      setShowUploadDropdown(false);\n                    }}\n                  >\n                    <span className={styles.buttonIcon}>📄</span>\n                    上传文件\n                  </button>\n                  <button\n                    className={styles.dropdownItem}\n                    onClick={() => {\n                      onFolderUploadClick();\n                      setShowUploadDropdown(false);\n                    }}\n                  >\n                    <span className={styles.buttonIcon}>📁</span>\n                    上传文件夹\n                  </button>\n                </div>\n              )}\n            </div>\n            <button\n              className={styles.topButton}\n              onClick={onCreateFolderClick}\n            >\n              <span className={styles.buttonIcon}>📁</span>\n              新建文件夹\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\file-management\\TopActionBar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/actionBar/TopActionBar 组件。\n */\n\nimport React from 'react';\nimport { \n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \n} from 'lucide-react';\nimport styles from '../styles/shared.module.css';\nimport SortDropdown from './SortDropdown';\nimport { UploadButton } from '../components/shared';\nimport { FileSortInterface } from '@/app/types';\n\ninterface TopActionBarProps {\n  selectedFiles: string[];\n  onClearSelection: () => void;\n  onDownload: () => void;\n  onRename: () => void;\n  onMove: () => void;\n  onDelete: () => void;\n  onClearFilter: () => void;\n  onCreateFolder: () => void;\n  selectedFileType: string | null;\n  showSearchView: boolean;\n  isInRootFolder: boolean;\n  sortOrder: FileSortInterface;\n  setSortOrder: (order: FileSortInterface) => void;\n  showUploadDropdown: boolean;\n  setShowUploadDropdown: (show: boolean) => void;\n  setIsUploadModalOpen: (open: boolean) => void;\n  setIsFolderUploadModalOpen: (open: boolean) => void;\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\n}\n\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\n  selectedFiles,\n  onClearSelection,\n  onDownload,\n  onRename,\n  onMove,\n  onDelete,\n  onClearFilter,\n  onCreateFolder,\n  selectedFileType,\n  showSearchView,\n  isInRootFolder,\n  sortOrder,\n  setSortOrder,\n  showUploadDropdown,\n  setShowUploadDropdown,\n  setIsUploadModalOpen,\n  setIsFolderUploadModalOpen,\n  uploadDropdownRef\n}) => {\n  return (\n    <div className={styles.topBar}>\n      <div className={styles.buttonGroup}>\n        {selectedFiles.length > 0 ? (\n          <>\n            <button className={styles.topButton} onClick={onClearSelection}>\n              <X className=\"w-4 h-4\" />\n              取消选择\n            </button>\n            <button className={styles.topButton} onClick={onDownload}>\n              <Download className=\"w-4 h-4\" />\n              下载\n            </button>\n            <button \n              className={styles.topButton}\n              onClick={onRename}\n            >\n              <Edit className=\"w-4 h-4\" />\n              重命名\n            </button>\n            <button className={styles.topButton} onClick={onMove}>\n              <Move className=\"w-4 h-4\" />\n              移动\n            </button>\n            <button className={styles.topButton} onClick={onDelete}>\n              <Trash2 className=\"w-4 h-4\" />\n              删除\n            </button>\n          </>\n        ) : (\n          <>\n            <button \n              className={styles.topButton}\n              onClick={onClearFilter}\n              disabled={isInRootFolder}\n            >\n              <span>📁</span>\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\n            </button>\n\n            {/* 添加当前过滤状态指示器 */}\n            {selectedFileType && (\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\n                {(() => {\n                  switch(selectedFileType) {\n                    case 'image': return <ImageIcon className=\"w-4 h-4 mr-2\" />;\n                    case 'document': return <FileText className=\"w-4 h-4 mr-2\" />;\n                    case 'video': return <Video className=\"w-4 h-4 mr-2\" />;\n                    case 'audio': return <Music className=\"w-4 h-4 mr-2\" />;\n                    case 'other': return <File className=\"w-4 h-4 mr-2\" />;\n                    default: return null;\n                  }\n                })()}\n                当前浏览：\n                {selectedFileType === 'image' && '仅图片'}\n                {selectedFileType === 'document' && '仅文档'}\n                {selectedFileType === 'video' && '仅视频'}\n                {selectedFileType === 'audio' && '仅音频'}\n                {selectedFileType === 'other' && '其他文件'}\n              </div>\n            )}\n\n            {/* 排序下拉菜单 */}\n            <SortDropdown \n              sortOrder={sortOrder}\n              onSortChange={setSortOrder}\n            />\n            \n            {/* 上传按钮 */}\n            <UploadButton \n              showDropdown={showUploadDropdown}\n              setShowDropdown={setShowUploadDropdown}\n              setIsModalOpen={setIsUploadModalOpen}\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\n              uploadDropdownRef={uploadDropdownRef}\n            />\n            \n            <button \n              className={styles.folderButton} \n              onClick={onCreateFolder}\n            >\n              <FolderUp className=\"w-4 h-4 mr-2\" />\n              新建文件夹\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TopActionBar; "
  },
  {
    "path": "app\\components\\features\\file-management\\upload\\UploadModal\\UploadModal.tsx",
    "newContent": "'use client';\r\n\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport { Modal, Button, Space, Tag, Input, message, Progress } from 'antd';\r\nimport { UploadOutlined, FolderOutlined } from '@ant-design/icons';\r\nimport { UploadModalProps } from '@/app/types/domains/file-management';\r\nimport { FileTreeNode } from '@/app/types/domains/fileTypes';\r\nimport { formatFileSize } from '@/app/lib/utils/file';\r\nimport { uploadFile, uploadFolder, processSelectedFiles } from '@/app/lib/uploadService';\r\n\r\n// 构建文件树节点\r\nfunction createFileTreeNode(name: string, type: 'file' | 'folder', size: number = 0, file?: File): FileTreeNode {\r\n  return {\r\n    name,\r\n    type,\r\n    size,\r\n    children: type === 'folder' ? [] : undefined,\r\n    file: file as any\r\n  };\r\n}\r\n\r\n// 更新文件夹大小\r\nfunction updateFolderSize(node: FileTreeNode, fileSize: number) {\r\n  let currentNode = node;\r\n  while (currentNode) {\r\n    currentNode.size += fileSize;\r\n    currentNode = currentNode.children?.find(child => \r\n      child.type === 'folder'\r\n    ) as FileTreeNode;\r\n  }\r\n}\r\n\r\n// 构建文件树结构\r\nfunction buildFileTree(files: File[], rootName: string): FileTreeNode {\r\n  const root = createFileTreeNode(rootName, 'folder');\r\n  \r\n  files.forEach(file => {\r\n    const paths = (file as any).webkitRelativePath.split('/');\r\n    let currentNode = root;\r\n    \r\n    for (let i = 1; i < paths.length; i++) {\r\n      const pathPart = paths[i];\r\n      const isFile = i === paths.length - 1;\r\n\r\n      if (isFile) {\r\n        const fileNode = createFileTreeNode(pathPart, 'file', file.size, file);\r\n        currentNode.children?.push(fileNode);\r\n        updateFolderSize(currentNode, file.size);\r\n      } else {\r\n        let folderNode = currentNode.children?.find(\r\n          child => child.name === pathPart && child.type === 'folder'\r\n        );\r\n        \r\n        if (!folderNode) {\r\n          folderNode = createFileTreeNode(pathPart, 'folder');\r\n          currentNode.children?.push(folderNode);\r\n        }\r\n        currentNode = folderNode;\r\n      }\r\n    }\r\n  });\r\n\r\n  return root;\r\n}\r\n\r\n/**\r\n * 文件上传模态框组件\r\n * 支持文件或文件夹上传，提供拖放和选择界面\r\n */\r\nconst UploadModal: React.FC<UploadModalProps> = ({\r\n  isOpen,\r\n  onClose,\r\n  onUploadSuccess,\r\n  currentFolderId,\r\n  isFolderUpload,\r\n  withTags\r\n}) => {\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [files, setFiles] = useState<File[]>([]);\r\n  const [isUploading, setIsUploading] = useState(false);\r\n  const [uploadProgress, setUploadProgress] = useState(0);\r\n  const [tags, setTags] = useState<string[]>([]);\r\n  const [tagInput, setTagInput] = useState('');\r\n  const [folderName, setFolderName] = useState<string | null>(null);\r\n  const [fileTree, setFileTree] = useState<FileTreeNode | null>(null);\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // 重置所有状态\r\n  const resetState = () => {\r\n    setFiles([]);\r\n    setIsDragging(false);\r\n    setTags([]);\r\n    setTagInput('');\r\n    setFolderName(null);\r\n    setFileTree(null);\r\n    setUploadProgress(0);\r\n  };\r\n\r\n  // 监听 isOpen 变化，当弹窗关闭时重置状态\r\n  useEffect(() => {\r\n    if (!isOpen) {\r\n      resetState();\r\n    }\r\n  }, [isOpen]);\r\n\r\n  const handleClose = () => {\r\n    resetState();\r\n    onClose();\r\n  };\r\n\r\n  const handleDragOver = (e: React.DragEvent) => {\r\n    e.preventDefault();\r\n    setIsDragging(true);\r\n  };\r\n\r\n  const handleDragLeave = () => {\r\n    setIsDragging(false);\r\n  };\r\n\r\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\r\n    e.preventDefault();\r\n    setIsDragging(false);\r\n    \r\n    const droppedFiles = Array.from(e.dataTransfer.files);\r\n    if (droppedFiles.length > 0) {\r\n      const { files: processedFiles, folderName } = processSelectedFiles(droppedFiles, isFolderUpload);\r\n      setFiles(processedFiles);\r\n      setFolderName(folderName);\r\n      \r\n      if (isFolderUpload && folderName) {\r\n        setFileTree(buildFileTree(processedFiles, folderName));\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = Array.from(e.target.files || []);\r\n    if (selectedFiles.length > 0) {\r\n      const { files: processedFiles, folderName } = processSelectedFiles(selectedFiles, isFolderUpload);\r\n      setFiles(processedFiles);\r\n      setFolderName(folderName);\r\n      \r\n      if (isFolderUpload && folderName) {\r\n        setFileTree(buildFileTree(processedFiles, folderName));\r\n      }\r\n    }\r\n  };\r\n\r\n  const removeFile = (fileName: string) => {\r\n    setFiles(prev => prev.filter(file => file.name !== fileName));\r\n  };\r\n\r\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n    if (e.key === 'Enter' && tagInput.trim()) {\r\n      e.preventDefault();\r\n      const newTag = tagInput.trim();\r\n      if (!tags.includes(newTag)) {\r\n        setTags([...tags, newTag]);\r\n      }\r\n      setTagInput('');\r\n    }\r\n  };\r\n\r\n  const removeTag = (tagToRemove: string) => {\r\n    setTags(tags.filter(tag => tag !== tagToRemove));\r\n  };\r\n\r\n  // 递归渲染文件树组件\r\n  const renderFileTree = (node: FileTreeNode, level: number = 0) => {\r\n    return (\r\n      <div key={node.name} style={{ marginLeft: `${level * 20}px` }}>\r\n        <div className=\"file-item\">\r\n          <div className=\"file-info\">\r\n            <span className=\"file-type-icon\">\r\n              {node.type === 'folder' ? '📁' : \r\n               node.file?.type.startsWith('image/') ? '🖼️' :\r\n               node.file?.type.includes('pdf') ? '📄' :\r\n               node.file?.type.includes('word') ? '📝' :\r\n               '📄'}\r\n            </span>\r\n            <div>\r\n              <p className=\"file-name\">{node.name}</p>\r\n              <p className=\"file-size\">\r\n                {formatFileSize(node.size)}\r\n                {node.type === 'folder' && ` (${node.children?.length || 0} 个文件)`}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        {node.children && node.children.length > 0 && (\r\n          <div className=\"file-children\">\r\n            {node.children.map(child => renderFileTree(child, level + 1))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // 上传处理函数\r\n  const handleUpload = async () => {\r\n    if (files.length === 0) return;\r\n    \r\n    setIsUploading(true);\r\n    setUploadProgress(0);\r\n    \r\n    try {\r\n      // 处理文件夹上传\r\n      if (isFolderUpload && folderName) {\r\n        await uploadFolder(files, folderName, {\r\n          folderId: currentFolderId || undefined,\r\n          tags,\r\n          onProgress: (progress) => {\r\n            setUploadProgress(progress);\r\n          },\r\n          onSuccess: (response) => {\r\n            message.success(`文件夹 \"${folderName}\" 上传成功`);\r\n            setIsUploading(false);\r\n            onUploadSuccess();\r\n            handleClose();\r\n          },\r\n          onError: (error) => {\r\n            message.error(`上传失败: ${error.message}`);\r\n            setIsUploading(false);\r\n          }\r\n        });\r\n      } else {\r\n        // 单文件或多文件上传\r\n        let uploadedCount = 0;\r\n        const totalFiles = files.length;\r\n        \r\n        for (const file of files) {\r\n          await uploadFile(file, {\r\n            folderId: currentFolderId || undefined,\r\n            tags,\r\n            onProgress: (fileProgress) => {\r\n              // 计算总体进度：已完成文件 + 当前文件进度\r\n              const totalProgress = Math.round(\r\n                (uploadedCount * 100 + fileProgress) / totalFiles\r\n              );\r\n              setUploadProgress(totalProgress);\r\n            },\r\n            onSuccess: () => {\r\n              uploadedCount++;\r\n              \r\n              // 所有文件上传完成\r\n              if (uploadedCount === totalFiles) {\r\n                message.success(totalFiles > 1 \r\n                  ? `${totalFiles}个文件上传成功` \r\n                  : '文件上传成功');\r\n                \r\n                setIsUploading(false);\r\n                onUploadSuccess();\r\n                handleClose();\r\n              }\r\n            },\r\n            onError: (error) => {\r\n              message.error(`文件上传失败: ${error.message}`);\r\n              setIsUploading(false);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : '上传失败';\r\n      message.error(errorMessage);\r\n      setIsUploading(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\r\n      open={isOpen}\r\n      onCancel={handleClose}\r\n      footer={[\r\n        <Button key=\"cancel\" onClick={handleClose} disabled={isUploading}>\r\n          取消\r\n        </Button>,\r\n        <Button \r\n          key=\"upload\" \r\n          type=\"primary\" \r\n          onClick={handleUpload} \r\n          disabled={files.length === 0 || isUploading}\r\n          loading={isUploading}\r\n        >\r\n          上传\r\n        </Button>,\r\n      ]}\r\n      width={800}\r\n    >\r\n      {isUploading ? (\r\n        <div className=\"text-center py-8\">\r\n          <div className=\"my-4\">\r\n            <Progress percent={uploadProgress} status=\"active\" />\r\n            <div className=\"mt-2\">{`上传中...${uploadProgress}%`}</div>\r\n          </div>\r\n        </div>\r\n      ) : (\r\n        <div className=\"upload-content\">\r\n          {/* 拖放区域 */}\r\n          <div\r\n            onDragOver={handleDragOver}\r\n            onDragLeave={handleDragLeave}\r\n            onDrop={handleDrop}\r\n            className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${\r\n              isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-500'\r\n            }`}\r\n          >\r\n            <div className=\"upload-icon mb-4\">\r\n              {isFolderUpload ? <FolderOutlined style={{ fontSize: 48 }} /> : <UploadOutlined style={{ fontSize: 48 }} />}\r\n            </div>\r\n            <p className=\"text-lg mb-2\">\r\n              {isDragging\r\n                ? isFolderUpload\r\n                  ? '放开以上传文件夹'\r\n                  : '放开以上传文件'\r\n                : isFolderUpload\r\n                ? '拖放文件夹至此处，或'\r\n                : '拖放文件至此处，或'}\r\n            </p>\r\n            <Button\r\n              onClick={() => fileInputRef.current?.click()}\r\n              type=\"primary\"\r\n              icon={isFolderUpload ? <FolderOutlined /> : <UploadOutlined />}\r\n            >\r\n              {isFolderUpload ? '选择文件夹' : '选择文件'}\r\n            </Button>\r\n            <input\r\n              ref={fileInputRef}\r\n              type=\"file\"\r\n              multiple={!isFolderUpload}\r\n              style={{ display: 'none' }}\r\n              onChange={handleFileSelect}\r\n              {...(isFolderUpload ? { webkitdirectory: \"\", directory: \"\" } : {})}\r\n            />\r\n          </div>\r\n\r\n          {/* 标签输入区域 */}\r\n          {withTags && (\r\n            <div className=\"tags-section mt-6\">\r\n              <h4 className=\"text-base font-medium mb-2\">添加标签</h4>\r\n              <div className=\"tag-input\">\r\n                <Input\r\n                  placeholder=\"输入标签并按Enter添加\"\r\n                  value={tagInput}\r\n                  onChange={(e) => setTagInput(e.target.value)}\r\n                  onKeyDown={handleTagInputKeyDown}\r\n                />\r\n              </div>\r\n              {tags.length > 0 && (\r\n                <div className=\"tags-list mt-2 flex flex-wrap gap-1\">\r\n                  {tags.map((tag) => (\r\n                    <Tag\r\n                      key={tag}\r\n                      closable\r\n                      onClose={() => removeTag(tag)}\r\n                    >\r\n                      {tag}\r\n                    </Tag>\r\n                  ))}\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n\r\n          {/* 文件列表或文件树 */}\r\n          {files.length > 0 && (\r\n            <div className=\"file-list mt-6\">\r\n              <h4 className=\"text-base font-medium mb-2\">\r\n                {isFolderUpload \r\n                  ? `文件夹: ${folderName} (${files.length}个文件)` \r\n                  : `选择的文件 (${files.length})`}\r\n              </h4>\r\n              \r\n              {isFolderUpload && fileTree ? (\r\n                <div className=\"folder-tree border rounded p-3\">\r\n                  {renderFileTree(fileTree)}\r\n                </div>\r\n              ) : (\r\n                <div className=\"file-items space-y-2\">\r\n                  {files.map((file) => (\r\n                    <div\r\n                      key={file.name}\r\n                      className=\"file-item flex justify-between items-center border rounded p-2\"\r\n                    >\r\n                      <div className=\"file-details flex items-center\">\r\n                        <span className=\"file-icon mr-2\">\r\n                          {file.type.startsWith('image/') ? '🖼️' :\r\n                           file.type.includes('pdf') ? '📄' :\r\n                           file.type.includes('word') ? '📝' :\r\n                           '📄'}\r\n                        </span>\r\n                        <div>\r\n                          <div className=\"file-name font-medium\">{file.name}</div>\r\n                          <div className=\"file-meta text-xs text-gray-500\">\r\n                            {formatFileSize(file.size)}\r\n                          </div>\r\n                        </div>\r\n                      </div>\r\n                      <Button\r\n                        type=\"text\"\r\n                        size=\"small\"\r\n                        danger\r\n                        onClick={() => removeFile(file.name)}\r\n                      >\r\n                        移除\r\n                      </Button>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default UploadModal; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\actionBar\\TopActionBar\\TopActionBar.tsx",
    "newContent": "import React from 'react';\r\nimport { \r\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \r\n} from 'lucide-react';\r\nimport styles from '@/app/file-management/styles/shared.module.css';\r\nimport { SortDropdown } from '@/app/components/features/file-management/actionBar/SortDropdown';\r\nimport { UploadButton } from '@/app/components/features/file-management/upload/UploadButton';\r\nimport { FileSortInterface } from '@/app/types';\r\n\r\ninterface TopActionBarProps {\r\n  selectedFiles: string[];\r\n  onClearSelection: () => void;\r\n  onDownload: () => void;\r\n  onRename: () => void;\r\n  onMove: () => void;\r\n  onDelete: () => void;\r\n  onClearFilter: () => void;\r\n  onCreateFolder: () => void;\r\n  selectedFileType: string | null;\r\n  showSearchView: boolean;\r\n  isInRootFolder: boolean;\r\n  sortOrder: FileSortInterface;\r\n  setSortOrder: (order: FileSortInterface) => void;\r\n  showUploadDropdown: boolean;\r\n  setShowUploadDropdown: (show: boolean) => void;\r\n  setIsUploadModalOpen: (open: boolean) => void;\r\n  setIsFolderUploadModalOpen: (open: boolean) => void;\r\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\r\n}\r\n\r\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\r\n  selectedFiles,\r\n  onClearSelection,\r\n  onDownload,\r\n  onRename,\r\n  onMove,\r\n  onDelete,\r\n  onClearFilter,\r\n  onCreateFolder,\r\n  selectedFileType,\r\n  showSearchView,\r\n  isInRootFolder,\r\n  sortOrder,\r\n  setSortOrder,\r\n  showUploadDropdown,\r\n  setShowUploadDropdown,\r\n  setIsUploadModalOpen,\r\n  setIsFolderUploadModalOpen,\r\n  uploadDropdownRef\r\n}) => {\r\n  return (\r\n    <div className={styles.topBar}>\r\n      <div className={styles.buttonGroup}>\r\n        {selectedFiles.length > 0 ? (\r\n          <>\r\n            <button className={styles.topButton} onClick={onClearSelection}>\r\n              <X className=\"w-4 h-4\" />\r\n              取消选择\r\n            </button>\r\n            <button className={styles.topButton} onClick={onDownload}>\r\n              <Download className=\"w-4 h-4\" />\r\n              下载\r\n            </button>\r\n            <button \r\n              className={styles.topButton}\r\n              onClick={onRename}\r\n            >\r\n              <Edit className=\"w-4 h-4\" />\r\n              重命名\r\n            </button>\r\n            <button className={styles.topButton} onClick={onMove}>\r\n              <Move className=\"w-4 h-4\" />\r\n              移动\r\n            </button>\r\n            <button className={styles.topButton} onClick={onDelete}>\r\n              <Trash2 className=\"w-4 h-4\" />\r\n              删除\r\n            </button>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <button \r\n              className={styles.topButton}\r\n              onClick={onClearFilter}\r\n              disabled={isInRootFolder}\r\n            >\r\n              <span>📁</span>\r\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\r\n            </button>\r\n\r\n            {/* 添加当前过滤状态指示器 */}\r\n            {selectedFileType && (\r\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\r\n                {(() => {\r\n                  switch(selectedFileType) {\r\n                    case 'image': return <ImageIcon className=\"w-4 h-4 mr-2\" />;\r\n                    case 'document': return <FileText className=\"w-4 h-4 mr-2\" />;\r\n                    case 'video': return <Video className=\"w-4 h-4 mr-2\" />;\r\n                    case 'audio': return <Music className=\"w-4 h-4 mr-2\" />;\r\n                    case 'other': return <File className=\"w-4 h-4 mr-2\" />;\r\n                    default: return null;\r\n                  }\r\n                })()}\r\n                当前浏览：\r\n                {selectedFileType === 'image' && '仅图片'}\r\n                {selectedFileType === 'document' && '仅文档'}\r\n                {selectedFileType === 'video' && '仅视频'}\r\n                {selectedFileType === 'audio' && '仅音频'}\r\n                {selectedFileType === 'other' && '其他文件'}\r\n              </div>\r\n            )}\r\n\r\n            {/* 排序下拉菜单 */}\r\n            <SortDropdown \r\n              sortOrder={sortOrder}\r\n              onSortChange={setSortOrder}\r\n            />\r\n            \r\n            {/* 上传按钮 */}\r\n            <UploadButton \r\n              showDropdown={showUploadDropdown}\r\n              setShowDropdown={setShowUploadDropdown}\r\n              setIsModalOpen={setIsUploadModalOpen}\r\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\r\n              uploadDropdownRef={uploadDropdownRef}\r\n            />\r\n            \r\n            <button \r\n              className={styles.folderButton} \r\n              onClick={onCreateFolder}\r\n            >\r\n              <FolderUp className=\"w-4 h-4 mr-2\" />\r\n              新建文件夹\r\n            </button>\r\n          </>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TopActionBar; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\MiniSidebar.tsx",
    "newContent": "/**\r\n * @deprecated 此组件已迁移到新的组件架构中。\r\n * 请使用 @/app/components/features/file-management/navigation/MiniSidebar 组件。\r\n */\r\n\r\nimport React from 'react';\r\nimport Image from 'next/image';\r\nimport { Home, LogOut, Palette } from 'lucide-react';\r\nimport styles from '../styles/shared.module.css';\r\n\r\ninterface MiniSidebarProps {\r\n  avatarUrl: string | null;\r\n  userName: string | null;\r\n  userEmail: string | null;\r\n  onHomeClick: () => void;\r\n  onLogoutClick: () => void;\r\n  onAvatarClick: () => void;\r\n  currentTheme?: string | null;\r\n  onThemeClick: () => void;\r\n}\r\n\r\nconst MiniSidebar: React.FC<MiniSidebarProps> = ({\r\n  avatarUrl,\r\n  userName,\r\n  userEmail,\r\n  onHomeClick,\r\n  onLogoutClick,\r\n  onAvatarClick,\r\n  currentTheme = 'default',\r\n  onThemeClick\r\n}) => {\r\n  return (\r\n    <div className={styles.miniSidebar}>\r\n      <div className={styles.patternOverlay}></div>\r\n      <div className={styles.avatarContainer}>\r\n        <button \r\n          className={styles.miniSidebarButton}\r\n          onClick={onAvatarClick}\r\n        >\r\n          {avatarUrl ? (\r\n            <Image\r\n              src={`${avatarUrl}?t=${Date.now()}`}\r\n              alt=\"用户头像\"\r\n              width={38}\r\n              height={38}\r\n              className=\"rounded-full ring-1 ring-white/50 transition-all duration-300 hover:ring-2\"\r\n            />\r\n          ) : (\r\n            <div \r\n              className={styles.avatarPlaceholder}\r\n              style={{ width: '38px', height: '38px', fontSize: '16px' }}\r\n            >\r\n              {userName?.[0]?.toUpperCase() || userEmail?.[0]?.toUpperCase() || '?'}\r\n            </div>\r\n          )}\r\n        </button>\r\n      </div>\r\n      <div className={styles.miniSidebarDivider}></div>\r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onHomeClick}\r\n      >\r\n        <Home className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n      \r\n      {/* 主题选择按钮 */}\r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onThemeClick}\r\n        title=\"主题设置\"\r\n      >\r\n        <Palette className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n      \r\n      <button \r\n        className={styles.miniSidebarButton}\r\n        onClick={onLogoutClick}\r\n      >\r\n        <LogOut className=\"w-5 h-5 text-white\" />\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MiniSidebar; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\NewFolderForm.tsx",
    "newContent": "/**\r\n * @deprecated 此组件已迁移到新的组件架构中。\r\n * 请使用 @/app/components/features/file-management/folderManagement/NewFolderForm 组件。\r\n */\r\n\r\nimport React, { useRef, useState, useEffect } from 'react';\r\nimport { Folder, AlertCircle } from 'lucide-react';\r\nimport styles from '../styles/shared.module.css';\r\n\r\ninterface NewFolderFormProps {\r\n  folderName: string;\r\n  setFolderName: (name: string) => void;\r\n  folderTags: string[];\r\n  setFolderTags: (tags: string[]) => void;\r\n  onCreateFolder: () => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nconst NewFolderForm: React.FC<NewFolderFormProps> = ({\r\n  folderName,\r\n  setFolderName,\r\n  folderTags,\r\n  setFolderTags,\r\n  onCreateFolder,\r\n  onCancel\r\n}) => {\r\n  const [newTag, setNewTag] = useState('');\r\n  const [nameError, setNameError] = useState<string | null>(null);\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // 检查文件夹名称是否有效\r\n  useEffect(() => {\r\n    const trimmedName = folderName.trim();\r\n    \r\n    if (trimmedName === '') {\r\n      setNameError(null); // 空名称不显示错误，但创建按钮会处理\r\n      return;\r\n    }\r\n\r\n    // 检查特殊字符\r\n    const invalidChars = /[\\/\\\\:*?\"<>|]/;\r\n    if (invalidChars.test(trimmedName)) {\r\n      setNameError('文件夹名称不能包含下列字符: / \\\\ : * ? \" < > |');\r\n      return;\r\n    }\r\n\r\n    setNameError(null);\r\n  }, [folderName]);\r\n\r\n  // 处理回车键创建文件夹\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (e.key === 'Enter' && !nameError && folderName.trim()) {\r\n      onCreateFolder();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.newFolderRow} p-4 border border-gray-200 rounded-lg bg-white shadow-sm mb-4`}>\r\n      <div className={`${styles.newFolderForm} flex flex-col space-y-4`}>\r\n        <div className={`flex items-center`}>\r\n          <Folder className=\"w-6 h-6 text-blue-500 flex-shrink-0 mr-3\" />\r\n          <div className={`${styles.newFolderNameContainer} flex-grow relative`}>\r\n            <input\r\n              type=\"text\"\r\n              ref={inputRef}\r\n              className={`${styles.newFolderInput} h-10 px-3 rounded-md border ${nameError ? 'border-red-500' : 'border-gray-300'} w-full text-base`}\r\n              value={folderName}\r\n              onChange={(e) => setFolderName(e.target.value)}\r\n              placeholder=\"新文件夹名称\"\r\n              autoFocus\r\n              onKeyDown={handleKeyDown}\r\n            />\r\n            {nameError && (\r\n              <div className=\"text-red-500 text-xs mt-1 flex items-center\">\r\n                <AlertCircle className=\"w-3 h-3 mr-1\" />\r\n                <span>{nameError}</span>\r\n              </div>\r\n            )}\r\n            {!nameError && (\r\n              <div className=\"text-gray-500 text-xs mt-1\">\r\n                相同目录下不能存在同名文件夹\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={`${styles.newFolderTagsContainer} ml-9`}>\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">添加标签</label>\r\n          <div className={`${styles.tagsWrapper} h-10 flex items-center flex-wrap gap-2 border border-gray-300 rounded-md px-3 py-1 overflow-y-auto`}>\r\n            {folderTags.map((tag, index) => (\r\n              <div key={index} className={`${styles.tagItem} h-7 flex items-center bg-blue-100 text-blue-800 px-2 rounded-md`}>\r\n                <span className=\"text-sm\">{tag}</span>\r\n                <button\r\n                  className={`${styles.removeTagButton} ml-1 text-blue-600 hover:text-blue-800 w-5 h-5 flex items-center justify-center rounded-full hover:bg-blue-200`}\r\n                  onClick={() => {\r\n                    const updatedTags = [...folderTags];\r\n                    updatedTags.splice(index, 1);\r\n                    setFolderTags(updatedTags);\r\n                  }}\r\n                >\r\n                  ×\r\n                </button>\r\n              </div>\r\n            ))}\r\n            <input\r\n              type=\"text\"\r\n              className={`${styles.tagInput} flex-grow h-7 border-0 outline-none text-sm bg-transparent`}\r\n              value={newTag}\r\n              onChange={(e) => setNewTag(e.target.value)}\r\n              onKeyDown={(e) => {\r\n                if (e.key === 'Enter' && newTag.trim()) {\r\n                  setFolderTags([...folderTags, newTag.trim()]);\r\n                  setNewTag('');\r\n                  e.preventDefault();\r\n                }\r\n              }}\r\n              placeholder=\"添加标签...\"\r\n            />\r\n          </div>\r\n        </div>\r\n        \r\n        <div className={`${styles.newFolderActions} flex items-center gap-3 ml-9`}>\r\n          <button \r\n            className={`${styles.confirmButton} h-10 px-4 ${nameError || !folderName.trim() ? 'bg-blue-300 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white rounded-md flex items-center justify-center`}\r\n            onClick={onCreateFolder}\r\n            disabled={!!nameError || !folderName.trim()}\r\n          >\r\n            创建\r\n          </button>\r\n          <button \r\n            className={`${styles.cancelButton} h-10 px-4 bg-gray-100 hover:bg-gray-200 text-gray-800 rounded-md flex items-center justify-center border border-gray-300`}\r\n            onClick={onCancel}\r\n          >\r\n            取消\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NewFolderForm; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\RenameModal\\index.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/fileOperations/RenameModal 组件。\n */\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport styles from '@/app/shared/themes/components/renameModal.module.css';\nimport { CloseOutlined, TagOutlined, PlusOutlined } from '@ant-design/icons';\n\ninterface RenameModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onRename: (newName: string, tags?: string[]) => void;\n  initialName: string;\n  initialTags?: string[];\n  fileType: 'file' | 'folder';\n}\n\nconst RenameModal: React.FC<RenameModalProps> = ({\n  isOpen,\n  onClose,\n  onRename,\n  initialName,\n  initialTags = [],\n  fileType\n}) => {\n  const [newName, setNewName] = useState(initialName);\n  const [tags, setTags] = useState<string[]>(initialTags);\n  const [tagInput, setTagInput] = useState('');\n  \n  const inputRef = useRef<HTMLInputElement>(null);\n  const tagInputRef = useRef<HTMLInputElement>(null);\n  const modalRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    setNewName(initialName);\n    // 确保初始标签不包含重复项\n    setTags(Array.from(new Set(initialTags)));\n  }, [initialName, initialTags]);\n\n  useEffect(() => {\n    if (isOpen && inputRef.current) {\n      // 自动聚焦输入框并选中文件名（不包括扩展名）\n      inputRef.current.focus();\n      \n      const extension = fileType === 'file' ? initialName.lastIndexOf('.') : -1;\n      if (extension !== -1) {\n        inputRef.current.setSelectionRange(0, extension);\n      } else {\n        inputRef.current.select();\n      }\n    }\n  }, [isOpen, initialName, fileType]);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n    \n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen, onClose]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    // 首先确保新名称是有效的非空字符串\n    if (newName && typeof newName === 'string' && newName.trim() && \n        (newName !== initialName || JSON.stringify(tags) !== JSON.stringify(initialTags))) {\n      onRename(newName, tags);\n    } else if (!newName || !newName.trim()) {\n      // 如果名称为空，显示错误信息但不关闭模态框\n      return;\n    }\n    onClose();\n  };\n\n  const handleAddTag = () => {\n    if (!tagInput.trim()) return;\n    \n    // 避免添加重复标签\n    if (!tags.includes(tagInput.trim())) {\n      setTags([...tags, tagInput.trim()]);\n    }\n    \n    setTagInput('');\n    \n    // 添加后自动聚焦回标签输入框\n    setTimeout(() => {\n      if (tagInputRef.current) {\n        tagInputRef.current.focus();\n      }\n    }, 0);\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(tag => tag !== tagToRemove));\n  };\n\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      handleAddTag();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div className={styles['modal-overlay']}>\n      <div ref={modalRef} className={`${styles['modal-content']} ${styles['rename-modal']}`}>\n        <div className={styles['modal-header']}>\n          <h3 className={styles['modal-title']}>\n            {fileType === 'folder' ? '重命名文件夹' : '重命名文件'}\n          </h3>\n          <button \n            className={styles['modal-close']} \n            onClick={onClose}\n            aria-label=\"关闭\"\n          >\n            <CloseOutlined />\n          </button>\n        </div>\n        \n        <form className={styles['rename-form']} onSubmit={handleSubmit}>\n          <div className={styles['form-group']}>\n            <label className={styles['form-label']}>名称</label>\n            <input\n              ref={inputRef}\n              type=\"text\"\n              className={styles['rename-input']}\n              value={newName}\n              onChange={(e) => setNewName(e.target.value)}\n              placeholder=\"输入新名称\"\n              autoFocus\n            />\n          </div>\n          \n          <div className={styles['form-group']}>\n            <label className={styles['form-label']}>标签</label>\n            <div className={styles['tags-container']}>\n              {tags.map((tag, index) => (\n                <div key={index} className={styles['tag']}>\n                  <span>{tag}</span>\n                  <button \n                    type=\"button\"\n                    className={styles['tag-remove']}\n                    onClick={() => handleRemoveTag(tag)}\n                  >\n                    &times;\n                  </button>\n                </div>\n              ))}\n            </div>\n            <div className={styles['tag-input-container']}>\n              <TagOutlined className={styles['tag-icon']} />\n              <input\n                ref={tagInputRef}\n                type=\"text\"\n                className={styles['tag-input']}\n                value={tagInput}\n                onChange={(e) => setTagInput(e.target.value)}\n                onKeyDown={handleTagInputKeyDown}\n                placeholder=\"输入标签，按回车添加\"\n              />\n              <button\n                type=\"button\"\n                className={styles['tag-add-button']}\n                onClick={handleAddTag}\n                disabled={!tagInput.trim()}\n              >\n                <PlusOutlined />\n              </button>\n            </div>\n          </div>\n\n          <div className={styles['modal-footer']}>\n            <button \n              type=\"button\" \n              className={`${styles['modal-button']} ${styles.cancel}`}\n              onClick={onClose}\n            >\n              取消\n            </button>\n            <button \n              type=\"submit\" \n              className={`${styles['modal-button']} ${styles.confirm}`}\n              disabled={!newName.trim() || (newName === initialName && JSON.stringify(tags) === JSON.stringify(initialTags))}\n            >\n              确认\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default RenameModal; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\Breadcrumb.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/navigation/Breadcrumb 组件。\n */\n\nimport React from 'react';\nimport { Home, ChevronRight, ChevronLeft } from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { FolderPathItem } from '@/app/types';\n\ninterface BreadcrumbProps {\n  folderPath: FolderPathItem[];\n  showHome?: boolean;\n  onNavigate?: (folderId: string | null) => void;\n  onPathClick: (folderId: string | null) => void;\n  onBackClick?: () => void;\n}\n\nexport function Breadcrumb({ \n  folderPath, \n  showHome = true, \n  onNavigate, \n  onPathClick,\n  onBackClick\n}: BreadcrumbProps) {\n  // 向下兼容：如果有onNavigate但没有onPathClick，就使用onNavigate\n  const handlePathClick = onPathClick || onNavigate;\n\n  if (!handlePathClick) {\n    console.error('Breadcrumb组件缺少必要的onPathClick或onNavigate回调函数');\n    return null;\n  }\n\n  return (\n    <div className={styles.breadcrumb}>\n      {onBackClick && folderPath.length > 0 && (\n        <button \n          className={styles.breadcrumbBackButton}\n          onClick={onBackClick}\n          title=\"返回上一级\"\n        >\n          <ChevronLeft size={16} />\n        </button>\n      )}\n      \n      {showHome && (\n        <div className={styles.breadcrumbItem}>\n          <button\n            className={styles.breadcrumbLink}\n            onClick={() => handlePathClick(null)}\n          >\n            <Home size={16} className={styles.breadcrumbIcon} />\n            根目录\n          </button>\n        </div>\n      )}\n      \n      {folderPath.map((folder) => (\n        <React.Fragment key={folder.id}>\n          <span className={styles.breadcrumbSeparator}>\n            <ChevronRight size={14} />\n          </span>\n          <div className={styles.breadcrumbItem}>\n            <button\n              className={styles.breadcrumbLink}\n              onClick={() => handlePathClick(folder.id)}\n            >\n              {folder.name}\n            </button>\n          </div>\n        </React.Fragment>\n      ))}\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\ErrorDisplay.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/shared/ErrorDisplay 组件。\n */\n\n'use client';\n\nimport React from 'react';\nimport { AlertTriangle, RefreshCw, Wifi, Server, CloudOff } from 'lucide-react';\nimport styles from '../../../../file-management/styles/shared.module.css';\n\ninterface ErrorDisplayProps {\n  title?: string;\n  message?: string;\n  errorType?: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown';\n  onRetry?: () => void;\n  retryText?: string;\n}\n\n/**\n * 显示友好的错误提示，支持不同类型的错误\n */\nexport const ErrorDisplay: React.FC<ErrorDisplayProps> = ({\n  title,\n  message = '请刷新页面重试或联系管理员',\n  errorType = 'unknown',\n  onRetry,\n  retryText = '重试'\n}) => {\n  // 根据错误类型获取图标和标题\n  const getErrorInfo = () => {\n    switch (errorType) {\n      case 'network':\n        return {\n          icon: <Wifi className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '网络连接错误'\n        };\n      case 'auth':\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '身份验证失败'\n        };\n      case 'server':\n        return {\n          icon: <Server className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '服务器错误'\n        };\n      case 'data':\n        return {\n          icon: <CloudOff className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '数据加载失败'\n        };\n      case 'timeout':\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '请求超时'\n        };\n      default:\n        return {\n          icon: <AlertTriangle className=\"w-12 h-12 text-red-500\" />,\n          defaultTitle: '加载出错'\n        };\n    }\n  };\n\n  const { icon, defaultTitle } = getErrorInfo();\n  const displayTitle = title || defaultTitle;\n\n  return (\n    <div className={styles.errorContainer}>\n      <div className={styles.errorCard}>\n        <div className={styles.errorIcon}>\n          {icon}\n        </div>\n        <h3 className={styles.errorTitle}>{displayTitle}</h3>\n        <p className={styles.errorText}>{message}</p>\n        {onRetry && (\n          <button \n            className={styles.retryButton}\n            onClick={onRetry}\n          >\n            <RefreshCw className=\"w-4 h-4\" />\n            {retryText}\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\FileList.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/fileList/FileList 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { \n  File as FileIcon, \n  Folder, \n  Image as ImageIcon, \n  FileText, \n  Video, \n  Music, \n  MoreVertical,\n  Tag as TagIcon,\n  SearchX,\n  Filter,\n  Check,\n  X,\n  Plus\n} from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { getFileType as getFileTypeDisplay } from '@/app/utils/file/type';\nimport { getFileNameAndExtension } from '@/app/utils/file/path';\nimport { FileInfo } from '@/app/types';\n\ninterface FileListProps {\n  files: FileInfo[];\n  selectedFiles: string[];\n  onFileClick: (file: FileInfo) => void;\n  onFileDoubleClick?: (file: FileInfo) => void;\n  onFileContextMenu?: (event: React.MouseEvent, file: FileInfo) => void;\n  onSelectFiles?: (fileIds: string[]) => void;\n  onFileSelect?: (file: FileInfo, checked: boolean) => void;\n  onSelectAll?: () => void;\n  onDeselectAll?: () => void;\n  onSelectAllFiles?: () => void;\n  onDeselectAllFiles?: () => void;\n  fileTypeFilter?: string | null;\n  isLoading?: boolean;\n  error?: string | null;\n  onBackClick?: () => void;\n  editingFileId?: string | null;\n  editingFile?: string | null;\n  editingName?: string;\n  editingTags?: string[];\n  newTag?: string;\n  onNewTagChange?: (value: string) => void;\n  onEditNameChange?: (value: string) => void;\n  onStartEdit?: (file: FileInfo) => void;\n  onConfirmEdit?: (fileId: string, newName: string, newTags: string[]) => void;\n  onCancelEdit?: () => void;\n  onAddTag?: (tag: string) => void;\n  onRemoveTag?: (tag: string) => void;\n  showCheckboxes?: boolean;\n  areAllSelected?: boolean;\n}\n\nexport function FileList({\n  files,\n  selectedFiles,\n  onFileClick,\n  onFileDoubleClick,\n  onFileContextMenu,\n  onSelectFiles,\n  onFileSelect,\n  onSelectAll,\n  onDeselectAll,\n  onSelectAllFiles,\n  onDeselectAllFiles,\n  fileTypeFilter,\n  isLoading,\n  error,\n  onBackClick,\n  editingFileId,\n  editingFile,\n  editingName: providedEditingName,\n  editingTags: providedEditingTags,\n  newTag: providedNewTag,\n  onNewTagChange,\n  onEditNameChange,\n  onStartEdit,\n  onConfirmEdit,\n  onCancelEdit,\n  onAddTag,\n  onRemoveTag,\n  showCheckboxes = true,\n  areAllSelected\n}: FileListProps) {\n  const actualEditingFileId = editingFileId || editingFile;\n\n  const [localEditName, setLocalEditName] = useState<string>('');\n  const [localEditTags, setLocalEditTags] = useState<string[]>([]);\n  const [localNewTag, setLocalNewTag] = useState<string>('');\n  \n  const editName = providedEditingName !== undefined ? providedEditingName : localEditName;\n  const editTags = providedEditingTags !== undefined ? providedEditingTags : localEditTags;\n  const newTagValue = providedNewTag !== undefined ? providedNewTag : localNewTag;\n  \n  const setEditName = (value: string) => {\n    if (onEditNameChange) {\n      onEditNameChange(value);\n    } else {\n      setLocalEditName(value);\n    }\n  };\n  \n  const setEditTags = (tags: string[]) => {\n    setLocalEditTags(tags);\n  };\n  \n  const setNewTag = (value: string) => {\n    if (onNewTagChange) {\n      onNewTagChange(value);\n    } else {\n      setLocalNewTag(value);\n    }\n  };\n\n  const editNameInputRef = useRef<HTMLInputElement>(null);\n  const newTagInputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (actualEditingFileId && providedEditingName === undefined) {\n      const file = files.find(f => f.id === actualEditingFileId);\n      if (file) {\n        setLocalEditName(file.name);\n        setLocalEditTags(file.tags || []);\n      }\n    }\n    \n    if (actualEditingFileId) {\n      setTimeout(() => {\n        if (editNameInputRef.current) {\n          editNameInputRef.current.focus();\n          editNameInputRef.current.select();\n        }\n      }, 0);\n    }\n  }, [actualEditingFileId, files, providedEditingName]);\n\n  const handleEditKeyDown = (e: React.KeyboardEvent, fileId: string) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      onConfirmEdit && onConfirmEdit(fileId, editName, editTags);\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancelEdit && onCancelEdit();\n    }\n  };\n\n  const handleAddTag = () => {\n    const trimmedTag = newTagValue.trim();\n    if (!trimmedTag) return;\n    \n    if (!editTags.includes(trimmedTag)) {\n      if (onAddTag) {\n        onAddTag(trimmedTag);\n      } else {\n        setEditTags([...editTags, trimmedTag]);\n      }\n      setNewTag('');\n      \n      setTimeout(() => {\n        if (newTagInputRef.current) {\n          newTagInputRef.current.focus();\n        }\n      }, 0);\n    }\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    if (onRemoveTag) {\n      onRemoveTag(tagToRemove);\n    } else {\n      setEditTags(editTags.filter(tag => tag !== tagToRemove));\n    }\n  };\n\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      handleAddTag();\n    }\n  };\n\n  const handleFileCheckboxChange = (file: FileInfo, checked: boolean) => {\n    if (onFileSelect) {\n      onFileSelect(file, checked);\n      return;\n    }\n    \n    if (onSelectFiles) {\n      if (checked) {\n        onSelectFiles([...selectedFiles, file.id]);\n      } else {\n        onSelectFiles(selectedFiles.filter(id => id !== file.id));\n      }\n    } else {\n      console.error('FileList: 缺少必要的onSelectFiles或onFileSelect回调函数');\n    }\n  };\n\n  const handleSelectAll = onSelectAll || onSelectAllFiles;\n  const handleDeselectAll = onDeselectAll || onDeselectAllFiles;\n\n  const renderFileIcon = (type?: string, extension?: string, isFolder?: boolean) => {\n    if (isFolder) return <Folder className={styles.fileIcon} />;\n    \n    const getFileIconType = () => {\n      if (!type) return 'file';\n      \n      if (type.includes('image')) return 'image';\n      if (type.includes('text') || type.includes('document') || extension?.match(/docx?|pdf|txt|md/i)) return 'file-text';\n      if (type.includes('video')) return 'video';\n      if (type.includes('audio')) return 'music';\n      if (extension?.match(/zip|rar|7z|tar|gz/i)) return 'archive';\n      if (extension?.match(/js|ts|jsx|tsx|py|java|c|cpp|go|rb|php|html|css/i)) return 'code';\n      \n      return 'file';\n    };\n    \n    const iconType = getFileIconType();\n    const IconComponent = {\n      'folder': Folder,\n      'file': FileIcon,\n      'image': ImageIcon,\n      'file-text': FileText,\n      'video': Video,\n      'music': Music,\n      'archive': FileIcon,\n      'code': FileIcon\n    }[iconType] || FileIcon;\n\n    return <IconComponent className={styles.fileIcon} />;\n  };\n\n  const renderTags = (file: FileInfo) => {\n    const tags = file.tags || [];\n    \n    if (actualEditingFileId === file.id) {\n      return (\n        <div className={styles.tagEditContainer}>\n          <div className={styles.editTagsList}>\n            {editTags.map((tag, index) => (\n              <div key={index} className={styles.editTag}>\n                <span>{tag}</span>\n                <button \n                  className={styles.removeTagButton}\n                  onClick={() => handleRemoveTag(tag)}\n                >\n                  <X size={12} />\n                </button>\n              </div>\n            ))}\n          </div>\n          <div className={styles.addTagInput}>\n            <input\n              ref={newTagInputRef}\n              type=\"text\"\n              placeholder=\"添加标签...\"\n              value={localNewTag}\n              onChange={(e) => setNewTag(e.target.value)}\n              onKeyDown={handleTagKeyDown}\n              className={styles.tagInput}\n            />\n            <button \n              className={styles.addTagButton}\n              onClick={handleAddTag}\n            >\n              <Plus size={14} />\n            </button>\n          </div>\n        </div>\n      );\n    }\n    \n    if (!tags || tags.length === 0) return <span className={styles.emptyText}>-</span>;\n    \n    const maxTagsToShow = 3;\n    const visibleTags = tags.slice(0, maxTagsToShow);\n    const extraTagsCount = tags.length - maxTagsToShow;\n    \n    return (\n      <div className={styles.tagContainer}>\n        {visibleTags.map((tag, index) => (\n          <span key={index} className={styles.tag}>\n            {tag}\n          </span>\n        ))}\n        {extraTagsCount > 0 && (\n          <span className={styles.extraTagsCount}>+{extraTagsCount}</span>\n        )}\n      </div>\n    );\n  };\n\n  const isAllSelected = areAllSelected !== undefined \n    ? areAllSelected \n    : (files.length > 0 && selectedFiles.length === files.length);\n\n  if (!Array.isArray(files) || files.length === 0) {\n    const getEmptyStateMessage = () => {\n      if (fileTypeFilter) {\n        switch(fileTypeFilter) {\n          case 'image':\n            return `您的存储空间中没有找到图片文件`;\n          case 'document':\n            return `您的存储空间中没有找到文档文件`;\n          case 'video':\n            return `您的存储空间中没有找到视频文件`;\n          case 'audio':\n            return `您的存储空间中没有找到音频文件`;\n          case 'other':\n            return `您的存储空间中没有找到其他类型的文件`;\n          default:\n            return `没有找到${fileTypeFilter}类型的文件`;\n        }\n      }\n      return '没有文件';\n    };\n\n    const getEmptyStateIcon = () => {\n      if (fileTypeFilter) {\n        return <Filter size={50} stroke=\"#CBD5E0\" />;\n      }\n      return <FileIcon size={50} stroke=\"#CBD5E0\" />;\n    };\n\n    const getEmptyStateHint = () => {\n      if (fileTypeFilter) {\n        return `系统已搜索所有文件夹，未找到${\n          fileTypeFilter === 'image' ? '图片' : \n          fileTypeFilter === 'document' ? '文档' : \n          fileTypeFilter === 'video' ? '视频' :\n          fileTypeFilter === 'audio' ? '音频' : '该类型'\n        }文件，您可以上传一些，或选择其他文件类型查看。`;\n      }\n      return '上传文件或创建文件夹以开始管理您的文件';\n    };\n\n    return (\n      <div className={styles.emptyState}>\n        {getEmptyStateIcon()}\n        <p className={styles.emptyStateText}>{getEmptyStateMessage()}</p>\n        <p className={styles.emptyStateHint}>\n          {getEmptyStateHint()}\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={styles.fileListWrapper}>\n      <div className={styles.fileListContainer}>\n        <table className={styles.fileTable}>\n          <thead>\n            <tr>\n              <th>\n                <input\n                  type=\"checkbox\"\n                  checked={isAllSelected}\n                  onChange={isAllSelected ? \n                    () => handleDeselectAll && handleDeselectAll() : \n                    () => handleSelectAll && handleSelectAll()}\n                  disabled={!showCheckboxes}\n                />\n              </th>\n              <th>名称</th>\n              <th>类型</th>\n              <th>大小</th>\n              <th>标签</th>\n              <th>修改日期</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            {files.map((file) => {\n              const isSelected = selectedFiles.includes(file.id);\n              const isEditing = actualEditingFileId === file.id;\n              \n              return (\n                <tr\n                  key={file.id}\n                  className={`${styles.fileRow} ${isSelected ? styles.selectedRow : ''} ${isEditing ? styles.editingRow : ''}`}\n                  onClick={() => !isEditing && onFileClick(file)}\n                  onDoubleClick={() => {\n                    if (!isEditing && onStartEdit && !file.isFolder) {\n                      onStartEdit(file);\n                    } else if (!isEditing && onFileDoubleClick) {\n                      onFileDoubleClick(file);\n                    }\n                  }}\n                  onContextMenu={(e) => !isEditing && onFileContextMenu && onFileContextMenu(e, file)}\n                >\n                  <td>\n                    {showCheckboxes && (\n                      <input\n                        type=\"checkbox\"\n                        checked={isSelected}\n                        onChange={(e) => handleFileCheckboxChange(file, e.target.checked)}\n                        onClick={(e) => e.stopPropagation()}\n                        disabled={isEditing}\n                      />\n                    )}\n                  </td>\n                  <td className={styles.fileNameCell}>\n                    <span className={styles.fileIcon}>\n                      {renderFileIcon(file.type, file.extension, file.isFolder)}\n                    </span>\n                    {isEditing ? (\n                      <input\n                        ref={editNameInputRef}\n                        type=\"text\"\n                        className={styles.fileNameInput}\n                        value={editName}\n                        onChange={(e) => setEditName(e.target.value)}\n                        onKeyDown={(e) => handleEditKeyDown(e, file.id)}\n                        onClick={(e) => e.stopPropagation()}\n                        autoComplete=\"off\"\n                      />\n                    ) : (\n                      <span className={styles.fileName}>{file.name}</span>\n                    )}\n                    {isEditing && (\n                      <div className={styles.editActions}>\n                        <button \n                          className={styles.editActionButton}\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            onConfirmEdit && onConfirmEdit(file.id, editName, editTags);\n                          }}\n                        >\n                          <Check size={16} />\n                        </button>\n                        <button \n                          className={styles.editActionButton}\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            onCancelEdit && onCancelEdit();\n                          }}\n                        >\n                          <X size={16} />\n                        </button>\n                      </div>\n                    )}\n                  </td>\n                  <td>{file.isFolder ? '文件夹' : \n                     file.type === 'document' ? '文档' : \n                     getFileTypeDisplay(file.type || null, file.extension)}</td>\n                  <td>{file.size ? `${Math.round(file.size / 1024)} KB` : '-'}</td>\n                  <td className={styles.tagsCell}>{renderTags(file)}</td>\n                  <td>\n                    {file.createdAt \n                      ? new Date(file.createdAt).toLocaleString() \n                      : '-'\n                    }\n                  </td>\n                  <td>\n                    {!isEditing ? (\n                      <button \n                        className={styles.actionButton}\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          if (onStartEdit) {\n                            onStartEdit(file);\n                          } else if (onFileContextMenu) {\n                            onFileContextMenu(e, file);\n                          }\n                        }}\n                      >\n                        <MoreVertical size={16} />\n                      </button>\n                    ) : (\n                      <span className={styles.editingMessage}>编辑中</span>\n                    )}\n                  </td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n}"
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\index.ts",
    "newContent": "export * from './Sidebar';\nexport * from './Breadcrumb';\nexport * from './FileList';\n// export * from './UploadModal'; // 已迁移到 @/app/components/features/file-management/upload/UploadModal\n// export * from './UploadButton'; // 已迁移到 @/app/components/features/file-management/upload/UploadButton\nexport * from './Skeleton';\nexport * from './ErrorDisplay'; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\Sidebar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/navigation/Sidebar 组件。\n */\n\nimport React, { useEffect } from 'react';\nimport { \n  Folder, Files, Image as ImageIcon, FileText, \n  Video, Music, File, Search, ChevronDown, \n  Star, Clock, Tag, Download, Settings,\n  CheckCircle\n} from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\n\nexport type FileType = 'image' | 'document' | 'video' | 'audio' | 'other' | null;\n\ninterface SidebarProps {\n  selectedFileType: FileType;\n  onTypeClick: (type: FileType) => void;\n  onSearchClick?: () => void;\n}\n\nexport function Sidebar({ selectedFileType, onTypeClick, onSearchClick }: SidebarProps) {\n  const fileTypes: { type: FileType; label: string; icon: React.ElementType }[] = [\n    { type: null, label: '全部文件', icon: Files },\n    { type: 'image', label: '图片', icon: ImageIcon },\n    { type: 'document', label: '文档', icon: FileText },\n    { type: 'video', label: '视频', icon: Video },\n    { type: 'audio', label: '音频', icon: Music },\n    { type: 'other', label: '其他', icon: File }\n  ];\n\n  const [quickAccessExpanded, setQuickAccessExpanded] = React.useState(true);\n  const [myFilesExpanded, setMyFilesExpanded] = React.useState(true);\n  const [settingsExpanded, setSettingsExpanded] = React.useState(false);\n\n  // 监听文件类型变化并记录日志\n  useEffect(() => {\n    console.log('侧边栏：当前选择的文件类型:', selectedFileType);\n  }, [selectedFileType]);\n\n  const handleTypeClick = (type: FileType) => {\n    // 直接调用回调，不需要任何额外逻辑\n    console.log('Sidebar直接点击类型:', type);\n    onTypeClick(type);\n  };\n\n  return (\n    <div className={styles.sidebar}>\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader} \n          onClick={() => setMyFilesExpanded(!myFilesExpanded)}\n        >\n          <Folder className={styles.icon} />\n          我的文件\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: myFilesExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {myFilesExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            {fileTypes.map(({ type, label, icon: Icon }) => (\n              <div\n                key={type || 'all'}\n                className={`${styles.sidebarItem} ${selectedFileType === type ? styles.active : ''}`}\n                onClick={() => handleTypeClick(type)}\n              >\n                <Icon className={styles.icon} />\n                {label}\n                {selectedFileType === type && (\n                  <CheckCircle \n                    className={styles.icon} \n                    style={{ \n                      marginLeft: 'auto', \n                      color: 'var(--theme-primary, #3b82f6)',\n                      fill: 'var(--theme-primary, #3b82f6)',\n                      stroke: '#fff',\n                      opacity: 0.9,\n                    }} \n                    size={16} \n                  />\n                )}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader}\n          onClick={() => setQuickAccessExpanded(!quickAccessExpanded)}\n        >\n          <Search className={styles.icon} />\n          快捷查询\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: quickAccessExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {quickAccessExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            <div \n              className={styles.sidebarItem}\n              onClick={onSearchClick}\n            >\n              <Search className={styles.icon} />\n              搜索文件\n            </div>\n            <div className={styles.sidebarItem}>\n              <Star className={styles.icon} />\n              收藏文件\n            </div>\n            <div className={styles.sidebarItem}>\n              <Clock className={styles.icon} />\n              最近访问\n            </div>\n            <div className={styles.sidebarItem}>\n              <Tag className={styles.icon} />\n              按标签查找\n            </div>\n            <div className={styles.sidebarItem}>\n              <Download className={styles.icon} />\n              下载记录\n            </div>\n          </div>\n        )}\n      </div>\n\n      <div className={styles.sidebarSection}>\n        <div \n          className={styles.sidebarHeader}\n          onClick={() => setSettingsExpanded(!settingsExpanded)}\n        >\n          <Settings className={styles.icon} />\n          系统设置\n          <ChevronDown \n            className={styles.icon} \n            style={{ \n              marginLeft: 'auto', \n              transform: settingsExpanded ? 'rotate(180deg)' : 'rotate(0)', \n              transition: 'transform 0.3s' \n            }} \n            size={16} \n          />\n        </div>\n        {settingsExpanded && (\n          <div className={styles.sidebarSubmenu}>\n            <div className={styles.sidebarItem}>\n              <Settings className={styles.icon} />\n              存储管理\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\Skeleton.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/shared/Skeleton 组件。\n */\n\n'use client';\n\nimport React from 'react';\nimport styles from './Skeleton.module.css';\n\ninterface SkeletonProps {\n  variant?: 'sidebar' | 'file' | 'avatar' | 'text' | 'button' | 'card';\n  width?: string | number;\n  height?: string | number;\n  animation?: 'pulse' | 'wave' | 'none';\n  count?: number;\n  className?: string;\n  borderRadius?: string;\n}\n\nexport const Skeleton: React.FC<SkeletonProps> = ({ \n  variant = 'text', \n  width, \n  height, \n  animation = 'pulse',\n  count = 1,\n  className = '',\n  borderRadius\n}) => {\n  const getVariantStyles = () => {\n    switch (variant) {\n      case 'sidebar':\n        return {\n          width: width || '100%',\n          height: height || '40px',\n          borderRadius: borderRadius || '8px'\n        };\n      case 'file':\n        return {\n          width: width || '100%',\n          height: height || '56px',\n          borderRadius: borderRadius || '8px'\n        };\n      case 'avatar':\n        return {\n          width: width || '40px',\n          height: height || '40px',\n          borderRadius: borderRadius || '50%'\n        };\n      case 'text':\n        return {\n          width: width || '100%',\n          height: height || '16px',\n          borderRadius: borderRadius || '4px'\n        };\n      case 'button':\n        return {\n          width: width || '120px',\n          height: height || '36px',\n          borderRadius: borderRadius || '6px'\n        };\n      case 'card':\n        return {\n          width: width || '100%',\n          height: height || '200px',\n          borderRadius: borderRadius || '12px'\n        };\n      default:\n        return {\n          width: width || '100%',\n          height: height || '16px',\n          borderRadius: borderRadius || '4px'\n        };\n    }\n  };\n\n  const renderSkeleton = () => {\n    const items = [];\n    const baseStyles = getVariantStyles();\n    \n    for (let i = 0; i < count; i++) {\n      items.push(\n        <div \n          key={i}\n          className={`${styles.skeleton} ${styles[`animation-${animation}`]} ${className}`}\n          style={{\n            ...baseStyles,\n            marginBottom: count > 1 && i < count - 1 ? '8px' : '0'\n          }}\n        />\n      );\n    }\n    \n    return items;\n  };\n\n  return <>{renderSkeleton()}</>;\n};\n\nexport const SkeletonFileList: React.FC = () => {\n  return (\n    <div className={styles.fileListSkeleton}>\n      <div className={styles.fileListHeader}>\n        <Skeleton variant=\"text\" width=\"15%\" height=\"24px\" />\n        <div className={styles.headerActions}>\n          <Skeleton variant=\"button\" width=\"100px\" />\n          <Skeleton variant=\"button\" width=\"100px\" />\n        </div>\n      </div>\n      \n      <div className={styles.fileItems}>\n        {[...Array(8)].map((_, index) => (\n          <div key={index} className={styles.fileItemSkeleton}>\n            <div className={styles.fileIcon}>\n              <Skeleton variant=\"avatar\" width=\"32px\" height=\"32px\" borderRadius=\"6px\" />\n            </div>\n            <div className={styles.fileDetails}>\n              <Skeleton variant=\"text\" width=\"60%\" height=\"18px\" />\n              <Skeleton variant=\"text\" width=\"40%\" height=\"14px\" />\n            </div>\n            <div className={styles.fileActions}>\n              <Skeleton variant=\"button\" width=\"70px\" />\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport const SkeletonSidebar: React.FC = () => {\n  return (\n    <div className={styles.sidebarSkeleton}>\n      <div className={styles.sidebarHeader}>\n        <Skeleton variant=\"text\" width=\"70%\" height=\"24px\" />\n      </div>\n      <div className={styles.sidebarContent}>\n        <Skeleton variant=\"sidebar\" count={5} />\n        <div className={styles.sidebarSection}>\n          <Skeleton variant=\"text\" width=\"50%\" height=\"18px\" />\n          <Skeleton variant=\"sidebar\" count={3} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport const SkeletonPageLayout: React.FC = () => {\n  return (\n    <div className={styles.pageLayoutSkeleton}>\n      <div className={styles.miniSidebarSkeleton}>\n        <Skeleton variant=\"avatar\" width=\"40px\" height=\"40px\" />\n        <Skeleton variant=\"button\" width=\"40px\" height=\"40px\" borderRadius=\"12px\" />\n        <Skeleton variant=\"button\" width=\"40px\" height=\"40px\" borderRadius=\"12px\" />\n      </div>\n      \n      <div className={styles.sidebarContainerSkeleton}>\n        <SkeletonSidebar />\n      </div>\n      \n      <div className={styles.mainContentSkeleton}>\n        <div className={styles.topBarSkeleton}>\n          <div className={styles.breadcrumbSkeleton}>\n            <Skeleton variant=\"text\" width=\"180px\" height=\"20px\" />\n          </div>\n          <div className={styles.actionButtonsSkeleton}>\n            <Skeleton variant=\"button\" width=\"100px\" />\n            <Skeleton variant=\"button\" width=\"100px\" />\n          </div>\n        </div>\n        \n        <SkeletonFileList />\n      </div>\n    </div>\n  );\n}; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\UploadButton.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/upload/UploadButton 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Upload, Folder, ChevronDown } from 'lucide-react';\nimport styles from '../../styles/shared.module.css';\nimport { UploadModal } from './UploadModal';\n\ninterface UploadButtonProps {\n  showDropdown: boolean;\n  setShowDropdown: (show: boolean) => void;\n  setIsModalOpen: (open: boolean) => void;\n  setIsFolderModalOpen: (open: boolean) => void;\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\n}\n\nexport function UploadButton({ \n  showDropdown, \n  setShowDropdown, \n  setIsModalOpen, \n  setIsFolderModalOpen,\n  uploadDropdownRef \n}: UploadButtonProps) {\n  \n  // 处理上传按钮点击\n  const handleUploadClick = (type: 'file' | 'folder') => {\n    if (type === 'file') {\n      setIsModalOpen(true);\n    } else {\n      setIsFolderModalOpen(true);\n    }\n    setShowDropdown(false);\n  };\n\n  return (\n    <div className={styles.uploadOptionsContainer} ref={uploadDropdownRef}>\n      <button\n        className={`${styles.uploadButton} ${showDropdown ? styles.activeButton : ''}`}\n        onClick={() => setShowDropdown(!showDropdown)}\n      >\n        <Upload size={18} className={styles.buttonIcon} />\n        上传文件\n        <ChevronDown size={16} className={styles.dropdownIcon} />\n      </button>\n      \n      {showDropdown && (\n        <div className={styles.dropdownMenu}>\n          <div \n            className={styles.dropdownItem}\n            onClick={() => handleUploadClick('file')}\n          >\n            <Upload size={16} className=\"mr-2\" />\n            <span>上传文件</span>\n          </div>\n          <div \n            className={styles.dropdownItem}\n            onClick={() => handleUploadClick('folder')}\n          >\n            <Folder size={16} className=\"mr-2\" />\n            <span>上传文件夹</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\fileManagement\\shared\\UploadModal.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/upload/UploadModal 组件。\n */\n\nimport React, { useState, useEffect, useRef, KeyboardEvent } from 'react';\nimport { InboxOutlined, CloseCircleOutlined, TagOutlined, CloseOutlined } from '@ant-design/icons';\nimport { Modal, Upload, Input, message, Button, Tag } from 'antd';\nimport type { RcFile, UploadFile } from 'antd/es/upload/interface';\nimport type { UploadProps } from 'antd';\nimport type { InputRef } from 'antd/es/input';\nimport { FileInfo, FileResponse } from '@/app/types';\nimport styles from '../../styles/shared.module.css';\nimport { useSession } from 'next-auth/react';\nimport { API_PATHS } from '@/app/lib/api/paths';\n\nconst { Dragger } = Upload;\n\ninterface UploadModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSuccess: (files?: FileInfo[]) => void;\n  isFolderUpload?: boolean;\n  currentFolderId?: string | null;\n}\n\n// 扩展UploadFile类型，添加webkitRelativePath属性\ninterface ExtendedUploadFile extends UploadFile<any> {\n  webkitRelativePath?: string;\n}\n\nexport function UploadModal({\n  isOpen,\n  onClose,\n  onSuccess,\n  isFolderUpload = false,\n  currentFolderId\n}: UploadModalProps) {\n  const [fileList, setFileList] = useState<ExtendedUploadFile[]>([]);\n  const [tagInput, setTagInput] = useState<string>('');\n  const [tagList, setTagList] = useState<string[]>([]);\n  const [uploading, setUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const tagInputRef = useRef<InputRef>(null);\n  const { data: session } = useSession();\n\n  useEffect(() => {\n    // 当模态框打开时检查登录状态\n    if (isOpen && !session) {\n      message.error('请先登录后再上传文件');\n      onClose();\n    }\n  }, [isOpen, session, onClose]);\n\n  // 处理文件选择\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const selectedFiles = e.target.files;\n    if (!selectedFiles || selectedFiles.length === 0) return;\n\n    const newFiles: ExtendedUploadFile[] = [];\n    for (let i = 0; i < selectedFiles.length; i++) {\n      const file = selectedFiles[i];\n      newFiles.push({\n        uid: `file-${Date.now()}-${i}`,\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        originFileObj: file as any,\n        webkitRelativePath: file.webkitRelativePath, // 添加相对路径\n      });\n    }\n\n    setFileList(prev => [...prev, ...newFiles]);\n    \n    // 清空input以允许再次选择相同的文件\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  // 处理标签输入\n  const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTagInput(e.target.value);\n  };\n\n  // 处理标签输入的回车事件\n  const handleTagInputKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter' && tagInput.trim()) {\n      e.preventDefault();\n      addTag(tagInput.trim());\n    }\n  };\n\n  // 添加标签\n  const addTag = (tag: string) => {\n    if (!tag) return;\n    \n    // 检查标签是否已存在\n    if (!tagList.includes(tag)) {\n      setTagList(prev => [...prev, tag]);\n    }\n    \n    // 清空输入框\n    setTagInput('');\n    \n    // 聚焦回输入框，方便继续输入\n    if (tagInputRef.current) {\n      setTimeout(() => {\n        tagInputRef.current?.focus();\n      }, 0);\n    }\n  };\n\n  // 删除标签\n  const removeTag = (tagToRemove: string) => {\n    setTagList(tagList.filter(tag => tag !== tagToRemove));\n  };\n\n  const handleUpload = async () => {\n    if (fileList.length === 0) {\n      message.warning('请选择要上传的文件');\n      return;\n    }\n\n    setUploading(true);\n\n    try {\n      const formData = new FormData();\n      \n      // 添加所有文件到FormData\n      let filesAdded = 0;\n      fileList.forEach((file, index) => {\n        const rawFile = file.originFileObj;\n        if (rawFile instanceof File) {\n          // 使用'file'字段名，与后端对应\n          formData.append('file', rawFile);\n          \n          // 如果是文件夹上传，添加相对路径信息\n          if (isFolderUpload && file.webkitRelativePath) {\n            // 使用数字索引作为键，确保后端可以正确解析\n            formData.append(`paths_${index}`, file.webkitRelativePath);\n            console.log(`文件 ${index}: ${file.name} - 路径: ${file.webkitRelativePath}`);\n          }\n          \n          filesAdded++;\n          console.log(`添加文件 ${index+1}: ${file.name}, 大小: ${file.size} 字节`);\n        } else {\n          console.warn(`无法获取文件 ${index+1}: ${file.name} 的原始File对象`);\n        }\n      });\n      \n      if (filesAdded === 0) {\n        throw new Error('无法处理上传文件，请重新选择文件');\n      }\n      \n      // 添加标志表明这是文件夹上传\n      if (isFolderUpload) {\n        formData.append('isFolderUpload', 'true');\n        console.log('文件夹上传模式已启用');\n      }\n      \n      // 将标签数组转换为逗号分隔的字符串\n      if (tagList.length > 0) {\n        formData.append('tags', JSON.stringify(tagList));\n        console.log('添加标签:', tagList);\n      }\n\n      if (currentFolderId) {\n        formData.append('folderId', currentFolderId);\n        console.log('当前文件夹ID:', currentFolderId);\n      }\n\n      console.log(`准备上传 ${filesAdded} 个文件...`);\n      \n      // 显示上传开始消息\n      const uploadKey = `upload-${Date.now()}`;\n      message.loading({ content: '正在上传文件...', key: uploadKey, duration: 0 });\n\n      // 使用fetch发送请求\n      const response = await fetch(API_PATHS.STORAGE.FILES.UPLOAD, {\n        method: 'POST',\n        body: formData,\n      });\n\n      // 获取响应\n      const contentType = response.headers.get(\"content-type\");\n      let data;\n      \n      if (contentType && contentType.includes(\"application/json\")) {\n        data = await response.json();\n      } else {\n        // 如果不是JSON响应，尝试获取文本\n        const text = await response.text();\n        console.error('服务器返回了非JSON响应:', text);\n        throw new Error('服务器返回了无效的响应格式');\n      }\n      \n      // 检查响应状态\n      if (!response.ok) {\n        console.error('上传响应错误:', data);\n        \n        // 显示错误消息\n        message.error({ \n          content: `上传失败: ${data.details || data.error || '服务器错误'}`, \n          key: uploadKey,\n          duration: 5 \n        });\n        \n        throw new Error(data.details || data.error || '上传失败');\n      }\n\n      // 上传成功处理\n      console.log('上传成功:', data);\n      message.success({ content: '上传成功', key: uploadKey, duration: 3 });\n      \n      // 关闭模态框并通知父组件\n      handleClose();\n      if (typeof onSuccess === 'function') {\n        onSuccess(data.files || (data.file ? [data.file] : undefined));\n      } else {\n        console.warn('onSuccess不是一个函数，无法通知上传成功');\n      }\n    } catch (error) {\n      console.error('上传过程中出错:', error);\n      message.error(`上传失败: ${error instanceof Error ? error.message : '未知错误'}`);\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  const handleClose = () => {\n    setFileList([]);\n    setTagInput('');\n    setTagList([]);\n    onClose();\n  };\n  \n  // 直接使用原生文件输入\n  const triggerFileInput = () => {\n    if (fileInputRef.current) {\n      fileInputRef.current.click();\n    }\n  };\n  \n  const removeFile = (index: number) => {\n    setFileList(prev => prev.filter((_, i) => i !== index));\n  };\n\n  return (\n    <Modal\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\n      open={isOpen}\n      onCancel={handleClose}\n      onOk={handleUpload}\n      okText=\"上传\"\n      cancelText=\"取消\"\n      confirmLoading={uploading}\n      width={600}\n    >\n      <div className={styles.uploadContainer || ''}>\n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          onChange={handleFileChange}\n          style={{ display: 'none' }}\n          multiple={true}\n          {...(isFolderUpload ? { webkitdirectory: '', directory: '', mozdirectory: '', msdirectory: '' } : {})}\n        />\n        \n        <div \n          className={styles.dropzone || ''}\n          onClick={triggerFileInput}\n          style={{ \n            border: '2px dashed #d9d9d9',\n            borderRadius: '4px',\n            padding: '20px',\n            textAlign: 'center',\n            cursor: 'pointer',\n            marginBottom: '16px'\n          }}\n        >\n          <p><InboxOutlined style={{ fontSize: '48px', color: '#40a9ff' }} /></p>\n          <p style={{ marginTop: '8px', fontWeight: 'bold' }}>\n            点击或拖拽{isFolderUpload ? '文件夹' : '文件'}到此区域上传\n          </p>\n          <p style={{ color: '#888' }}>\n            {isFolderUpload\n              ? '支持上传整个文件夹及其内部文件，保留文件夹结构'\n              : '支持单个或批量上传文件，最大支持同时选择50个文件'}\n          </p>\n          <Button type=\"primary\" onClick={(e) => { e.stopPropagation(); triggerFileInput(); }}>\n            选择{isFolderUpload ? '文件夹' : '文件'}\n          </Button>\n        </div>\n        \n        {fileList.length > 0 && (\n          <div style={{ marginBottom: '16px' }}>\n            <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n              已选择 {fileList.length} 个文件:\n            </div>\n            <ul style={{ maxHeight: '150px', overflowY: 'auto', padding: '0 0 0 20px' }}>\n              {fileList.map((file, index) => (\n                <li key={file.uid} style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>\n                  <span>\n                    {file.name} \n                    {isFolderUpload && file.webkitRelativePath && (\n                      <span style={{ fontSize: '12px', color: '#8c8c8c', marginLeft: '4px' }}>\n                        (路径: {file.webkitRelativePath.split('/').slice(0, -1).join('/')})\n                      </span>\n                    )}\n                    ({((file.size || 0) / 1024).toFixed(2)} KB)\n                  </span>\n                  <Button \n                    type=\"text\" \n                    danger \n                    onClick={() => removeFile(index)}\n                    style={{ padding: '0 4px' }}\n                  >\n                    删除\n                  </Button>\n                </li>\n              ))}\n            </ul>\n          </div>\n        )}\n\n        <div style={{ marginTop: 16 }}>\n          <div style={{ marginBottom: '8px', display: 'flex', alignItems: 'center' }}>\n            <span style={{ fontWeight: 'bold', marginRight: '8px' }}>添加标签:</span>\n            <span style={{ fontSize: '12px', color: '#8c8c8c' }}>\n              (输入标签后按回车添加)\n            </span>\n          </div>\n          \n          <div className={styles.tagsInputWrapper}>\n            <Input\n              ref={tagInputRef}\n              placeholder=\"输入标签后按回车添加\"\n              value={tagInput}\n              onChange={handleTagInputChange}\n              onKeyDown={handleTagInputKeyDown}\n              prefix={<TagOutlined style={{ color: '#bfbfbf' }} />}\n              suffix={\n                <span style={{ color: '#bfbfbf', fontSize: '12px' }}>\n                  按回车添加\n                </span>\n              }\n            />\n          </div>\n          \n          <div className={styles.tagsContainer}>\n            {tagList.length > 0 ? (\n              <div className={styles.tagsList}>\n                {tagList.map((tag, index) => (\n                  <Tag\n                    key={index}\n                    closable\n                    onClose={() => removeTag(tag)}\n                    className={styles.interactiveTag}\n                  >\n                    {tag}\n                  </Tag>\n                ))}\n              </div>\n            ) : (\n              <div className={styles.emptyTagsHint}>\n                添加一些标签来帮助管理您的文件\n              </div>\n            )}\n          </div>\n        </div>\n\n        <div style={{ marginTop: '16px', padding: '12px', background: '#f5f5f5', borderRadius: '8px', fontSize: '13px', color: '#555' }}>\n          <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n            {isFolderUpload ? '文件夹上传说明:' : '文件上传说明:'}\n          </div>\n          <ul style={{ paddingLeft: '16px', margin: '0' }}>\n            {isFolderUpload ? (\n              <>\n                <li>支持上传整个文件夹及其子文件夹结构</li>\n                <li>保留完整的文件夹层次结构</li>\n                <li>目前仅Chrome、Edge等现代浏览器支持文件夹选择</li>\n                <li>如果您的浏览器不支持文件夹选择，请选择单个文件模式</li>\n              </>\n            ) : (\n              <>\n                <li>支持批量上传多个文件</li>\n                <li>支持常见的文件格式（图片、文档、视频等）</li>\n                <li>每个文件大小限制为50MB</li>\n                <li>一次最多可选择50个文件</li>\n              </>\n            )}\n            <li>您可以为上传的文件添加标签，以便更好地组织和查找</li>\n          </ul>\n        </div>\n      </div>\n    </Modal>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\fileManagement\\SortDropdown.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/actionBar/SortDropdown 组件。\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport styles from '../styles/SortDropdown.module.css';\nimport { FileSortInterface, SortDirectionEnum } from '@/app/types';\n\ninterface SortDropdownProps {\n  sortOrder: FileSortInterface;\n  onSortChange: (order: FileSortInterface) => void;\n}\n\nexport const SortDropdown: React.FC<SortDropdownProps> = ({\n  sortOrder,\n  onSortChange\n}) => {\n  const [showDropdown, setShowDropdown] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n        setShowDropdown(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  // 根据当前排序字段获取显示文本\n  const getSortFieldText = () => {\n    switch(sortOrder.field) {\n      case 'name': return '文件名';\n      case 'size': return '大小';\n      case 'createdAt': return '时间';\n      default: return '默认';\n    }\n  };\n\n  return (\n    <div className={styles.sortDropdown} ref={dropdownRef}>\n      <button \n        className={styles.topButton}\n        onClick={() => setShowDropdown(!showDropdown)}\n        style={{ \n          background: showDropdown ? '#f0f7ff' : 'white',\n          borderColor: showDropdown ? '#60a5fa' : '#e8e8e8'\n        }}\n      >\n        <span>↕️</span>\n        排序: {getSortFieldText()} {sortOrder.direction === SortDirectionEnum.ASC ? '↑' : '↓'}\n      </button>\n      {showDropdown && (\n        <div className={styles.dropdownMenu}>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'name',\n                direction: sortOrder.field === 'name' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'name' ? 'bold' : 'normal',\n              background: sortOrder.field === 'name' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>📝</span>\n            按文件名{sortOrder.field === 'name' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'size',\n                direction: sortOrder.field === 'size' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'size' ? 'bold' : 'normal',\n              background: sortOrder.field === 'size' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>📊</span>\n            按大小{sortOrder.field === 'size' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n          <button \n            className={styles.dropdownItem}\n            onClick={() => {\n              const newSortOrder: FileSortInterface = {\n                field: 'createdAt',\n                direction: sortOrder.field === 'createdAt' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\n              };\n              onSortChange(newSortOrder);\n              setShowDropdown(false);\n            }}\n            style={{ \n              fontWeight: sortOrder.field === 'createdAt' ? 'bold' : 'normal',\n              background: sortOrder.field === 'createdAt' ? '#f0f7ff' : 'transparent'\n            }}\n          >\n            <span>🕒</span>\n            按时间{sortOrder.field === 'createdAt' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SortDropdown; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\Toolbar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/toolbar/Toolbar 组件。\n */\n\nimport React, { useRef, useState } from 'react';\nimport { useFileContext } from '../context/FileContext';\nimport { X, Download, Edit, Move } from 'lucide-react';\nimport { message } from 'antd';\nimport styles from './Toolbar.module.css';\nimport commonStyles from '../styles/common.module.css';\n\ninterface ToolbarProps {\n  onUploadClick: () => void;\n  onFolderUploadClick: () => void;\n  onCreateFolderClick: () => void;\n}\n\nexport function Toolbar({ onUploadClick, onFolderUploadClick, onCreateFolderClick }: ToolbarProps) {\n  const {\n    selectedFiles,\n    clearSelection,\n    files\n  } = useFileContext();\n\n  const [showUploadDropdown, setShowUploadDropdown] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n\n  const handleDownload = () => {\n    // TODO: 实现文件下载功能\n    message.info('下载功能开发中');\n  };\n\n  const handleRename = () => {\n    if (selectedFiles.length !== 1) {\n      message.warning('请选择一个文件进行重命名');\n      return;\n    }\n    const selectedFile = files.find(file => file.id === selectedFiles[0]);\n    if (selectedFile) {\n      // TODO: 实现重命名功能\n      message.info('重命名功能开发中');\n    }\n  };\n\n  return (\n    <div className={styles.topBar}>\n      <div className={styles.buttonGroup}>\n        {selectedFiles.length > 0 ? (\n          <>\n            <button className={styles.topButton} onClick={() => clearSelection()}>\n              <X className={commonStyles.icon} />\n              取消选择\n            </button>\n            <button className={styles.topButton} onClick={handleDownload}>\n              <Download className={commonStyles.icon} />\n              下载\n            </button>\n            <button className={styles.topButton} onClick={handleRename}>\n              <Edit className={commonStyles.icon} />\n              重命名\n            </button>\n            <button className={styles.topButton}>\n              <Move className={commonStyles.icon} />\n              移动\n            </button>\n          </>\n        ) : (\n          <>\n            <div className={styles.uploadDropdown} ref={dropdownRef}>\n              <button\n                className={styles.topButton}\n                onClick={() => setShowUploadDropdown(!showUploadDropdown)}\n              >\n                <span className={styles.buttonIcon}>⬆️</span>\n                上传\n                <span className={styles.dropdownArrow}>▼</span>\n              </button>\n              {showUploadDropdown && (\n                <div className={styles.dropdownMenu}>\n                  <button\n                    className={styles.dropdownItem}\n                    onClick={() => {\n                      onUploadClick();\n                      setShowUploadDropdown(false);\n                    }}\n                  >\n                    <span className={styles.buttonIcon}>📄</span>\n                    上传文件\n                  </button>\n                  <button\n                    className={styles.dropdownItem}\n                    onClick={() => {\n                      onFolderUploadClick();\n                      setShowUploadDropdown(false);\n                    }}\n                  >\n                    <span className={styles.buttonIcon}>📁</span>\n                    上传文件夹\n                  </button>\n                </div>\n              )}\n            </div>\n            <button\n              className={styles.topButton}\n              onClick={onCreateFolderClick}\n            >\n              <span className={styles.buttonIcon}>📁</span>\n              新建文件夹\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n} "
  },
  {
    "path": "app\\components\\features\\fileManagement\\TopActionBar.tsx",
    "newContent": "/**\n * @deprecated 此组件已迁移到新的组件架构中。\n * 请使用 @/app/components/features/file-management/actionBar/TopActionBar 组件。\n */\n\nimport React from 'react';\nimport { \n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \n} from 'lucide-react';\nimport styles from '../styles/shared.module.css';\nimport SortDropdown from './SortDropdown';\nimport { UploadButton } from '../components/shared';\nimport { FileSortInterface } from '@/app/types';\n\ninterface TopActionBarProps {\n  selectedFiles: string[];\n  onClearSelection: () => void;\n  onDownload: () => void;\n  onRename: () => void;\n  onMove: () => void;\n  onDelete: () => void;\n  onClearFilter: () => void;\n  onCreateFolder: () => void;\n  selectedFileType: string | null;\n  showSearchView: boolean;\n  isInRootFolder: boolean;\n  sortOrder: FileSortInterface;\n  setSortOrder: (order: FileSortInterface) => void;\n  showUploadDropdown: boolean;\n  setShowUploadDropdown: (show: boolean) => void;\n  setIsUploadModalOpen: (open: boolean) => void;\n  setIsFolderUploadModalOpen: (open: boolean) => void;\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\n}\n\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\n  selectedFiles,\n  onClearSelection,\n  onDownload,\n  onRename,\n  onMove,\n  onDelete,\n  onClearFilter,\n  onCreateFolder,\n  selectedFileType,\n  showSearchView,\n  isInRootFolder,\n  sortOrder,\n  setSortOrder,\n  showUploadDropdown,\n  setShowUploadDropdown,\n  setIsUploadModalOpen,\n  setIsFolderUploadModalOpen,\n  uploadDropdownRef\n}) => {\n  return (\n    <div className={styles.topBar}>\n      <div className={styles.buttonGroup}>\n        {selectedFiles.length > 0 ? (\n          <>\n            <button className={styles.topButton} onClick={onClearSelection}>\n              <X className=\"w-4 h-4\" />\n              取消选择\n            </button>\n            <button className={styles.topButton} onClick={onDownload}>\n              <Download className=\"w-4 h-4\" />\n              下载\n            </button>\n            <button \n              className={styles.topButton}\n              onClick={onRename}\n            >\n              <Edit className=\"w-4 h-4\" />\n              重命名\n            </button>\n            <button className={styles.topButton} onClick={onMove}>\n              <Move className=\"w-4 h-4\" />\n              移动\n            </button>\n            <button className={styles.topButton} onClick={onDelete}>\n              <Trash2 className=\"w-4 h-4\" />\n              删除\n            </button>\n          </>\n        ) : (\n          <>\n            <button \n              className={styles.topButton}\n              onClick={onClearFilter}\n              disabled={isInRootFolder}\n            >\n              <span>📁</span>\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\n            </button>\n\n            {/* 添加当前过滤状态指示器 */}\n            {selectedFileType && (\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\n                {(() => {\n                  switch(selectedFileType) {\n                    case 'image': return <ImageIcon className=\"w-4 h-4 mr-2\" />;\n                    case 'document': return <FileText className=\"w-4 h-4 mr-2\" />;\n                    case 'video': return <Video className=\"w-4 h-4 mr-2\" />;\n                    case 'audio': return <Music className=\"w-4 h-4 mr-2\" />;\n                    case 'other': return <File className=\"w-4 h-4 mr-2\" />;\n                    default: return null;\n                  }\n                })()}\n                当前浏览：\n                {selectedFileType === 'image' && '仅图片'}\n                {selectedFileType === 'document' && '仅文档'}\n                {selectedFileType === 'video' && '仅视频'}\n                {selectedFileType === 'audio' && '仅音频'}\n                {selectedFileType === 'other' && '其他文件'}\n              </div>\n            )}\n\n            {/* 排序下拉菜单 */}\n            <SortDropdown \n              sortOrder={sortOrder}\n              onSortChange={setSortOrder}\n            />\n            \n            {/* 上传按钮 */}\n            <UploadButton \n              showDropdown={showUploadDropdown}\n              setShowDropdown={setShowUploadDropdown}\n              setIsModalOpen={setIsUploadModalOpen}\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\n              uploadDropdownRef={uploadDropdownRef}\n            />\n            \n            <button \n              className={styles.folderButton} \n              onClick={onCreateFolder}\n            >\n              <FolderUp className=\"w-4 h-4 mr-2\" />\n              新建文件夹\n            </button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TopActionBar; "
  },
  {
    "path": "app\\components\\features\\fileManagement\\upload\\UploadModal\\UploadModal.tsx",
    "newContent": "'use client';\r\n\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport { Modal, Button, Space, Tag, Input, message, Progress } from 'antd';\r\nimport { UploadOutlined, FolderOutlined } from '@ant-design/icons';\r\nimport { UploadModalProps } from '@/app/types/domains/file-management';\r\nimport { FileTreeNode } from '@/app/types/domains/fileTypes';\r\nimport { formatFileSize } from '@/app/lib/utils/file';\r\nimport { uploadFile, uploadFolder, processSelectedFiles } from '@/app/lib/uploadService';\r\n\r\n// 构建文件树节点\r\nfunction createFileTreeNode(name: string, type: 'file' | 'folder', size: number = 0, file?: File): FileTreeNode {\r\n  return {\r\n    name,\r\n    type,\r\n    size,\r\n    children: type === 'folder' ? [] : undefined,\r\n    file: file as any\r\n  };\r\n}\r\n\r\n// 更新文件夹大小\r\nfunction updateFolderSize(node: FileTreeNode, fileSize: number) {\r\n  let currentNode = node;\r\n  while (currentNode) {\r\n    currentNode.size += fileSize;\r\n    currentNode = currentNode.children?.find(child => \r\n      child.type === 'folder'\r\n    ) as FileTreeNode;\r\n  }\r\n}\r\n\r\n// 构建文件树结构\r\nfunction buildFileTree(files: File[], rootName: string): FileTreeNode {\r\n  const root = createFileTreeNode(rootName, 'folder');\r\n  \r\n  files.forEach(file => {\r\n    const paths = (file as any).webkitRelativePath.split('/');\r\n    let currentNode = root;\r\n    \r\n    for (let i = 1; i < paths.length; i++) {\r\n      const pathPart = paths[i];\r\n      const isFile = i === paths.length - 1;\r\n\r\n      if (isFile) {\r\n        const fileNode = createFileTreeNode(pathPart, 'file', file.size, file);\r\n        currentNode.children?.push(fileNode);\r\n        updateFolderSize(currentNode, file.size);\r\n      } else {\r\n        let folderNode = currentNode.children?.find(\r\n          child => child.name === pathPart && child.type === 'folder'\r\n        );\r\n        \r\n        if (!folderNode) {\r\n          folderNode = createFileTreeNode(pathPart, 'folder');\r\n          currentNode.children?.push(folderNode);\r\n        }\r\n        currentNode = folderNode;\r\n      }\r\n    }\r\n  });\r\n\r\n  return root;\r\n}\r\n\r\n/**\r\n * 文件上传模态框组件\r\n * 支持文件或文件夹上传，提供拖放和选择界面\r\n */\r\nconst UploadModal: React.FC<UploadModalProps> = ({\r\n  isOpen,\r\n  onClose,\r\n  onUploadSuccess,\r\n  currentFolderId,\r\n  isFolderUpload,\r\n  withTags\r\n}) => {\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [files, setFiles] = useState<File[]>([]);\r\n  const [isUploading, setIsUploading] = useState(false);\r\n  const [uploadProgress, setUploadProgress] = useState(0);\r\n  const [tags, setTags] = useState<string[]>([]);\r\n  const [tagInput, setTagInput] = useState('');\r\n  const [folderName, setFolderName] = useState<string | null>(null);\r\n  const [fileTree, setFileTree] = useState<FileTreeNode | null>(null);\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // 重置所有状态\r\n  const resetState = () => {\r\n    setFiles([]);\r\n    setIsDragging(false);\r\n    setTags([]);\r\n    setTagInput('');\r\n    setFolderName(null);\r\n    setFileTree(null);\r\n    setUploadProgress(0);\r\n  };\r\n\r\n  // 监听 isOpen 变化，当弹窗关闭时重置状态\r\n  useEffect(() => {\r\n    if (!isOpen) {\r\n      resetState();\r\n    }\r\n  }, [isOpen]);\r\n\r\n  const handleClose = () => {\r\n    resetState();\r\n    onClose();\r\n  };\r\n\r\n  const handleDragOver = (e: React.DragEvent) => {\r\n    e.preventDefault();\r\n    setIsDragging(true);\r\n  };\r\n\r\n  const handleDragLeave = () => {\r\n    setIsDragging(false);\r\n  };\r\n\r\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\r\n    e.preventDefault();\r\n    setIsDragging(false);\r\n    \r\n    const droppedFiles = Array.from(e.dataTransfer.files);\r\n    if (droppedFiles.length > 0) {\r\n      const { files: processedFiles, folderName } = processSelectedFiles(droppedFiles, isFolderUpload);\r\n      setFiles(processedFiles);\r\n      setFolderName(folderName);\r\n      \r\n      if (isFolderUpload && folderName) {\r\n        setFileTree(buildFileTree(processedFiles, folderName));\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const selectedFiles = Array.from(e.target.files || []);\r\n    if (selectedFiles.length > 0) {\r\n      const { files: processedFiles, folderName } = processSelectedFiles(selectedFiles, isFolderUpload);\r\n      setFiles(processedFiles);\r\n      setFolderName(folderName);\r\n      \r\n      if (isFolderUpload && folderName) {\r\n        setFileTree(buildFileTree(processedFiles, folderName));\r\n      }\r\n    }\r\n  };\r\n\r\n  const removeFile = (fileName: string) => {\r\n    setFiles(prev => prev.filter(file => file.name !== fileName));\r\n  };\r\n\r\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n    if (e.key === 'Enter' && tagInput.trim()) {\r\n      e.preventDefault();\r\n      const newTag = tagInput.trim();\r\n      if (!tags.includes(newTag)) {\r\n        setTags([...tags, newTag]);\r\n      }\r\n      setTagInput('');\r\n    }\r\n  };\r\n\r\n  const removeTag = (tagToRemove: string) => {\r\n    setTags(tags.filter(tag => tag !== tagToRemove));\r\n  };\r\n\r\n  // 递归渲染文件树组件\r\n  const renderFileTree = (node: FileTreeNode, level: number = 0) => {\r\n    return (\r\n      <div key={node.name} style={{ marginLeft: `${level * 20}px` }}>\r\n        <div className=\"file-item\">\r\n          <div className=\"file-info\">\r\n            <span className=\"file-type-icon\">\r\n              {node.type === 'folder' ? '📁' : \r\n               node.file?.type.startsWith('image/') ? '🖼️' :\r\n               node.file?.type.includes('pdf') ? '📄' :\r\n               node.file?.type.includes('word') ? '📝' :\r\n               '📄'}\r\n            </span>\r\n            <div>\r\n              <p className=\"file-name\">{node.name}</p>\r\n              <p className=\"file-size\">\r\n                {formatFileSize(node.size)}\r\n                {node.type === 'folder' && ` (${node.children?.length || 0} 个文件)`}\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        {node.children && node.children.length > 0 && (\r\n          <div className=\"file-children\">\r\n            {node.children.map(child => renderFileTree(child, level + 1))}\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // 上传处理函数\r\n  const handleUpload = async () => {\r\n    if (files.length === 0) return;\r\n    \r\n    setIsUploading(true);\r\n    setUploadProgress(0);\r\n    \r\n    try {\r\n      // 处理文件夹上传\r\n      if (isFolderUpload && folderName) {\r\n        await uploadFolder(files, folderName, {\r\n          folderId: currentFolderId || undefined,\r\n          tags,\r\n          onProgress: (progress) => {\r\n            setUploadProgress(progress);\r\n          },\r\n          onSuccess: (response) => {\r\n            message.success(`文件夹 \"${folderName}\" 上传成功`);\r\n            setIsUploading(false);\r\n            onUploadSuccess();\r\n            handleClose();\r\n          },\r\n          onError: (error) => {\r\n            message.error(`上传失败: ${error.message}`);\r\n            setIsUploading(false);\r\n          }\r\n        });\r\n      } else {\r\n        // 单文件或多文件上传\r\n        let uploadedCount = 0;\r\n        const totalFiles = files.length;\r\n        \r\n        for (const file of files) {\r\n          await uploadFile(file, {\r\n            folderId: currentFolderId || undefined,\r\n            tags,\r\n            onProgress: (fileProgress) => {\r\n              // 计算总体进度：已完成文件 + 当前文件进度\r\n              const totalProgress = Math.round(\r\n                (uploadedCount * 100 + fileProgress) / totalFiles\r\n              );\r\n              setUploadProgress(totalProgress);\r\n            },\r\n            onSuccess: () => {\r\n              uploadedCount++;\r\n              \r\n              // 所有文件上传完成\r\n              if (uploadedCount === totalFiles) {\r\n                message.success(totalFiles > 1 \r\n                  ? `${totalFiles}个文件上传成功` \r\n                  : '文件上传成功');\r\n                \r\n                setIsUploading(false);\r\n                onUploadSuccess();\r\n                handleClose();\r\n              }\r\n            },\r\n            onError: (error) => {\r\n              message.error(`文件上传失败: ${error.message}`);\r\n              setIsUploading(false);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : '上传失败';\r\n      message.error(errorMessage);\r\n      setIsUploading(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Modal\r\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\r\n      open={isOpen}\r\n      onCancel={handleClose}\r\n      footer={[\r\n        <Button key=\"cancel\" onClick={handleClose} disabled={isUploading}>\r\n          取消\r\n        </Button>,\r\n        <Button \r\n          key=\"upload\" \r\n          type=\"primary\" \r\n          onClick={handleUpload} \r\n          disabled={files.length === 0 || isUploading}\r\n          loading={isUploading}\r\n        >\r\n          上传\r\n        </Button>,\r\n      ]}\r\n      width={800}\r\n    >\r\n      {isUploading ? (\r\n        <div className=\"text-center py-8\">\r\n          <div className=\"my-4\">\r\n            <Progress percent={uploadProgress} status=\"active\" />\r\n            <div className=\"mt-2\">{`上传中...${uploadProgress}%`}</div>\r\n          </div>\r\n        </div>\r\n      ) : (\r\n        <div className=\"upload-content\">\r\n          {/* 拖放区域 */}\r\n          <div\r\n            onDragOver={handleDragOver}\r\n            onDragLeave={handleDragLeave}\r\n            onDrop={handleDrop}\r\n            className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${\r\n              isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-500'\r\n            }`}\r\n          >\r\n            <div className=\"upload-icon mb-4\">\r\n              {isFolderUpload ? <FolderOutlined style={{ fontSize: 48 }} /> : <UploadOutlined style={{ fontSize: 48 }} />}\r\n            </div>\r\n            <p className=\"text-lg mb-2\">\r\n              {isDragging\r\n                ? isFolderUpload\r\n                  ? '放开以上传文件夹'\r\n                  : '放开以上传文件'\r\n                : isFolderUpload\r\n                ? '拖放文件夹至此处，或'\r\n                : '拖放文件至此处，或'}\r\n            </p>\r\n            <Button\r\n              onClick={() => fileInputRef.current?.click()}\r\n              type=\"primary\"\r\n              icon={isFolderUpload ? <FolderOutlined /> : <UploadOutlined />}\r\n            >\r\n              {isFolderUpload ? '选择文件夹' : '选择文件'}\r\n            </Button>\r\n            <input\r\n              ref={fileInputRef}\r\n              type=\"file\"\r\n              multiple={!isFolderUpload}\r\n              style={{ display: 'none' }}\r\n              onChange={handleFileSelect}\r\n              {...(isFolderUpload ? { webkitdirectory: \"\", directory: \"\" } : {})}\r\n            />\r\n          </div>\r\n\r\n          {/* 标签输入区域 */}\r\n          {withTags && (\r\n            <div className=\"tags-section mt-6\">\r\n              <h4 className=\"text-base font-medium mb-2\">添加标签</h4>\r\n              <div className=\"tag-input\">\r\n                <Input\r\n                  placeholder=\"输入标签并按Enter添加\"\r\n                  value={tagInput}\r\n                  onChange={(e) => setTagInput(e.target.value)}\r\n                  onKeyDown={handleTagInputKeyDown}\r\n                />\r\n              </div>\r\n              {tags.length > 0 && (\r\n                <div className=\"tags-list mt-2 flex flex-wrap gap-1\">\r\n                  {tags.map((tag) => (\r\n                    <Tag\r\n                      key={tag}\r\n                      closable\r\n                      onClose={() => removeTag(tag)}\r\n                    >\r\n                      {tag}\r\n                    </Tag>\r\n                  ))}\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n\r\n          {/* 文件列表或文件树 */}\r\n          {files.length > 0 && (\r\n            <div className=\"file-list mt-6\">\r\n              <h4 className=\"text-base font-medium mb-2\">\r\n                {isFolderUpload \r\n                  ? `文件夹: ${folderName} (${files.length}个文件)` \r\n                  : `选择的文件 (${files.length})`}\r\n              </h4>\r\n              \r\n              {isFolderUpload && fileTree ? (\r\n                <div className=\"folder-tree border rounded p-3\">\r\n                  {renderFileTree(fileTree)}\r\n                </div>\r\n              ) : (\r\n                <div className=\"file-items space-y-2\">\r\n                  {files.map((file) => (\r\n                    <div\r\n                      key={file.name}\r\n                      className=\"file-item flex justify-between items-center border rounded p-2\"\r\n                    >\r\n                      <div className=\"file-details flex items-center\">\r\n                        <span className=\"file-icon mr-2\">\r\n                          {file.type.startsWith('image/') ? '🖼️' :\r\n                           file.type.includes('pdf') ? '📄' :\r\n                           file.type.includes('word') ? '📝' :\r\n                           '📄'}\r\n                        </span>\r\n                        <div>\r\n                          <div className=\"file-name font-medium\">{file.name}</div>\r\n                          <div className=\"file-meta text-xs text-gray-500\">\r\n                            {formatFileSize(file.size)}\r\n                          </div>\r\n                        </div>\r\n                      </div>\r\n                      <Button\r\n                        type=\"text\"\r\n                        size=\"small\"\r\n                        danger\r\n                        onClick={() => removeFile(file.name)}\r\n                      >\r\n                        移除\r\n                      </Button>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default UploadModal; "
  },
  {
    "path": "app\\components\\features\\index.ts",
    "newContent": "// 导出features目录下的所有组件\r\nexport * from './home';\r\nexport * from './dashboard';\r\nexport * from './user-profile';\r\nexport * from './file-management'; "
  },
  {
    "path": "app\\components\\features\\user-profile\\index.ts",
    "newContent": "// 导出user-profile目录下的所有组件\r\nexport * from './avatar';\r\nexport * from './profileHeader';\r\nexport * from './profileContent';\r\nexport * from './completeness';\r\nexport * from './passwordForm';\r\nexport * from './editForm'; "
  },
  {
    "path": "app\\components\\features\\user-profile\\profileHeader\\ProfileHeader.tsx",
    "newContent": "import React, { useState, useRef, useEffect } from 'react';\r\nimport Image from 'next/image';\r\nimport { Session } from 'next-auth';\r\nimport { UserInfo } from '@/app/dashboard/page';\r\nimport { Camera, Upload, Trash2 } from 'lucide-react';\r\nimport styles from './ProfileHeader.module.css';\r\nimport { AvatarModal } from '@/app/components/features/user-profile/avatar';\r\n\r\ninterface ProfileHeaderProps {\r\n  session: Session;\r\n  userInfo: UserInfo;\r\n  onEditClick: () => void;\r\n  onPasswordClick: () => void;\r\n  isLoading: boolean;\r\n  onAvatarChange?: (avatarUrl: string) => void;\r\n}\r\n\r\nconst ProfileHeader = ({ \r\n  session, \r\n  userInfo,\r\n  onEditClick, \r\n  onPasswordClick, \r\n  isLoading,\r\n  onAvatarChange\r\n}: ProfileHeaderProps) => {\r\n  const [avatarError, setAvatarError] = useState(false);\r\n  const [showAvatarModal, setShowAvatarModal] = useState(false);\r\n  \r\n  // 使用userInfo中的displayName作为首选，如果没有则使用session中的name\r\n  const displayName = userInfo.displayName || session.user?.name || '未设置昵称';\r\n  \r\n  // 获取用于头像占位符的首字母\r\n  const nameInitial = displayName[0]?.toUpperCase() || '?';\r\n\r\n  // 简化头像URL逻辑，直接使用userInfo中的头像或session头像\r\n  const effectiveAvatarUrl = userInfo.avatarUrl || session.user?.image;\r\n  \r\n  // 添加时间戳作为key的一部分，确保每次头像变更都会重新渲染\r\n  const [refreshKey, setRefreshKey] = useState(Date.now());\r\n  const avatarKey = `${effectiveAvatarUrl || 'fallback'}-${refreshKey}`;\r\n\r\n  // 添加useEffect监听userInfo.avatarUrl的变化\r\n  useEffect(() => {\r\n    setRefreshKey(Date.now()); // 强制头像重新渲染\r\n    setAvatarError(false); // 重置错误状态\r\n  }, [userInfo.avatarUrl]);\r\n\r\n  // 添加深度调试 - 监控props变化\r\n  useEffect(() => {\r\n    console.log('ProfileHeader收到新的userInfo:', \r\n      { \r\n        avatarUrl: userInfo.avatarUrl,\r\n        hasAvatar: !!userInfo.avatarUrl,\r\n        displayName: userInfo.displayName\r\n      }\r\n    );\r\n  }, [userInfo]);\r\n\r\n  // 打开头像管理弹窗\r\n  const handleAvatarClick = () => {\r\n    setShowAvatarModal(true);\r\n  };\r\n\r\n  // 处理头像变更\r\n  const handleAvatarChange = (newAvatarUrl: string) => {\r\n    if (onAvatarChange) {\r\n      onAvatarChange(newAvatarUrl);\r\n    }\r\n    // 强制刷新\r\n    setRefreshKey(Date.now());\r\n  };\r\n\r\n  return (\r\n    <div className={styles.header}>\r\n      <div className={styles.avatarContainer}>\r\n        <div className={styles.avatar} onClick={handleAvatarClick}>\r\n          {effectiveAvatarUrl && !avatarError ? (\r\n            <Image\r\n              key={avatarKey}\r\n              src={`${effectiveAvatarUrl}?t=${refreshKey}`}\r\n              alt=\"用户头像\"\r\n              width={160}\r\n              height={160}\r\n              className={styles.avatarImage}\r\n              priority\r\n              unoptimized={true}\r\n              onError={() => setAvatarError(true)}\r\n            />\r\n          ) : (\r\n            <div className={styles.avatarFallback}>\r\n              <span>{nameInitial}</span>\r\n            </div>\r\n          )}\r\n          \r\n          {/* 头像悬停覆盖层 */}\r\n          <div className={styles.avatarOverlay}>\r\n            <button \r\n              className={styles.avatarButton} \r\n              onClick={handleAvatarClick}\r\n              title=\"管理头像\"\r\n            >\r\n              <Camera size={24} />\r\n            </button>\r\n          </div>\r\n        </div>\r\n        <p className={styles.avatarHint}>点击更换头像</p>\r\n      </div>\r\n      \r\n      <div className={styles.info}>\r\n        <h1 className={styles.name}>{displayName}</h1>\r\n        <p className={styles.email}>{session.user?.email || '未设置邮箱'}</p>\r\n        <div className={styles.buttons}>\r\n          <button\r\n            onClick={onEditClick}\r\n            className={styles.editButton}\r\n            disabled={isLoading}\r\n          >\r\n            编辑个人信息\r\n          </button>\r\n          <button\r\n            onClick={onPasswordClick}\r\n            className={styles.passwordButton}\r\n            disabled={isLoading}\r\n          >\r\n            设置密码\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* 头像管理弹窗 */}\r\n      <AvatarModal \r\n        isOpen={showAvatarModal}\r\n        onClose={() => setShowAvatarModal(false)}\r\n        currentAvatarUrl={effectiveAvatarUrl || null}\r\n        userDisplayName={displayName}\r\n        onAvatarChange={handleAvatarChange}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProfileHeader; "
  },
  {
    "path": "app\\components\\features\\userProfile\\index.ts",
    "newContent": "// 导出user-profile目录下的所有组件\r\nexport * from './avatar';\r\nexport * from './profileHeader';\r\nexport * from './profileContent';\r\nexport * from './completeness';\r\nexport * from './passwordForm';\r\nexport * from './editForm'; "
  },
  {
    "path": "app\\components\\features\\userProfile\\profileHeader\\ProfileHeader.tsx",
    "newContent": "import React, { useState, useRef, useEffect } from 'react';\r\nimport Image from 'next/image';\r\nimport { Session } from 'next-auth';\r\nimport { UserInfo } from '@/app/dashboard/page';\r\nimport { Camera, Upload, Trash2 } from 'lucide-react';\r\nimport styles from './ProfileHeader.module.css';\r\nimport { AvatarModal } from '@/app/components/features/user-profile/avatar';\r\n\r\ninterface ProfileHeaderProps {\r\n  session: Session;\r\n  userInfo: UserInfo;\r\n  onEditClick: () => void;\r\n  onPasswordClick: () => void;\r\n  isLoading: boolean;\r\n  onAvatarChange?: (avatarUrl: string) => void;\r\n}\r\n\r\nconst ProfileHeader = ({ \r\n  session, \r\n  userInfo,\r\n  onEditClick, \r\n  onPasswordClick, \r\n  isLoading,\r\n  onAvatarChange\r\n}: ProfileHeaderProps) => {\r\n  const [avatarError, setAvatarError] = useState(false);\r\n  const [showAvatarModal, setShowAvatarModal] = useState(false);\r\n  \r\n  // 使用userInfo中的displayName作为首选，如果没有则使用session中的name\r\n  const displayName = userInfo.displayName || session.user?.name || '未设置昵称';\r\n  \r\n  // 获取用于头像占位符的首字母\r\n  const nameInitial = displayName[0]?.toUpperCase() || '?';\r\n\r\n  // 简化头像URL逻辑，直接使用userInfo中的头像或session头像\r\n  const effectiveAvatarUrl = userInfo.avatarUrl || session.user?.image;\r\n  \r\n  // 添加时间戳作为key的一部分，确保每次头像变更都会重新渲染\r\n  const [refreshKey, setRefreshKey] = useState(Date.now());\r\n  const avatarKey = `${effectiveAvatarUrl || 'fallback'}-${refreshKey}`;\r\n\r\n  // 添加useEffect监听userInfo.avatarUrl的变化\r\n  useEffect(() => {\r\n    setRefreshKey(Date.now()); // 强制头像重新渲染\r\n    setAvatarError(false); // 重置错误状态\r\n  }, [userInfo.avatarUrl]);\r\n\r\n  // 添加深度调试 - 监控props变化\r\n  useEffect(() => {\r\n    console.log('ProfileHeader收到新的userInfo:', \r\n      { \r\n        avatarUrl: userInfo.avatarUrl,\r\n        hasAvatar: !!userInfo.avatarUrl,\r\n        displayName: userInfo.displayName\r\n      }\r\n    );\r\n  }, [userInfo]);\r\n\r\n  // 打开头像管理弹窗\r\n  const handleAvatarClick = () => {\r\n    setShowAvatarModal(true);\r\n  };\r\n\r\n  // 处理头像变更\r\n  const handleAvatarChange = (newAvatarUrl: string) => {\r\n    if (onAvatarChange) {\r\n      onAvatarChange(newAvatarUrl);\r\n    }\r\n    // 强制刷新\r\n    setRefreshKey(Date.now());\r\n  };\r\n\r\n  return (\r\n    <div className={styles.header}>\r\n      <div className={styles.avatarContainer}>\r\n        <div className={styles.avatar} onClick={handleAvatarClick}>\r\n          {effectiveAvatarUrl && !avatarError ? (\r\n            <Image\r\n              key={avatarKey}\r\n              src={`${effectiveAvatarUrl}?t=${refreshKey}`}\r\n              alt=\"用户头像\"\r\n              width={160}\r\n              height={160}\r\n              className={styles.avatarImage}\r\n              priority\r\n              unoptimized={true}\r\n              onError={() => setAvatarError(true)}\r\n            />\r\n          ) : (\r\n            <div className={styles.avatarFallback}>\r\n              <span>{nameInitial}</span>\r\n            </div>\r\n          )}\r\n          \r\n          {/* 头像悬停覆盖层 */}\r\n          <div className={styles.avatarOverlay}>\r\n            <button \r\n              className={styles.avatarButton} \r\n              onClick={handleAvatarClick}\r\n              title=\"管理头像\"\r\n            >\r\n              <Camera size={24} />\r\n            </button>\r\n          </div>\r\n        </div>\r\n        <p className={styles.avatarHint}>点击更换头像</p>\r\n      </div>\r\n      \r\n      <div className={styles.info}>\r\n        <h1 className={styles.name}>{displayName}</h1>\r\n        <p className={styles.email}>{session.user?.email || '未设置邮箱'}</p>\r\n        <div className={styles.buttons}>\r\n          <button\r\n            onClick={onEditClick}\r\n            className={styles.editButton}\r\n            disabled={isLoading}\r\n          >\r\n            编辑个人信息\r\n          </button>\r\n          <button\r\n            onClick={onPasswordClick}\r\n            className={styles.passwordButton}\r\n            disabled={isLoading}\r\n          >\r\n            设置密码\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      {/* 头像管理弹窗 */}\r\n      <AvatarModal \r\n        isOpen={showAvatarModal}\r\n        onClose={() => setShowAvatarModal(false)}\r\n        currentAvatarUrl={effectiveAvatarUrl || null}\r\n        userDisplayName={displayName}\r\n        onAvatarChange={handleAvatarChange}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProfileHeader; "
  },
  {
    "path": "app\\components\\index.ts",
    "newContent": "/**\r\n * 组件库索引文件\r\n * \r\n * 所有组件已按照原子设计模式进行重组：\r\n * - ui/: 基础UI组件\r\n *   - atoms/: 原子级组件（按钮、输入框等）\r\n *   - molecules/: 分子级组件（复合UI元素）\r\n *   - organisms/: 有机体组件（完整UI区块）\r\n * \r\n * - common/: 通用功能组件\r\n *   - feedback/: 反馈类组件（提示、通知等）\r\n *   - form/: 表单相关组件\r\n *   - media/: 媒体组件（音视频等）\r\n * \r\n * - features/: 业务功能组件\r\n *   - dashboard/: 仪表盘相关组件\r\n *   - file-management/: 文件管理组件\r\n *   - home/: 首页相关组件\r\n *   - user-profile/: 用户资料组件\r\n * \r\n * 为保持向后兼容性，所有组件可以从根路径直接导入\r\n */\r\n\r\n// 从新的目录结构中重新导出组件\r\n// UI组件\r\nexport * from './ui';\r\n\r\n// 导航组件\r\nexport { default as Navbar } from './features/dashboard/navigation/Navbar';\r\n\r\n// 文件管理组件\r\nexport { default as UploadModal } from './features/file-management/upload/UploadModal';\r\nexport { default as FileUpload } from './features/file-management/upload/FileUpload';\r\nexport { default as TopActionBar } from './features/file-management/actionBar/TopActionBar';\r\nexport { default as SortDropdown } from './features/file-management/actionBar/SortDropdown';\r\nexport { default as NewFolderForm } from './features/file-management/folderManagement/NewFolderForm';\r\nexport { default as Toolbar } from './features/file-management/toolbar/Toolbar';\r\n\r\n// 分析组件\r\nexport { default as StorageUsage } from './features/dashboard/analytics/StorageUsage';\r\n\r\n// 媒体组件\r\nexport { default as AudioVisualizer } from './common/media/AudioVisualizer';\r\n\r\n// 用户资料组件\r\nexport { default as ProfileHeader } from './features/user-profile/profileHeader';\r\nexport { default as ProfileCompleteness } from './features/user-profile/completeness';\r\nexport { default as PasswordForm } from './features/user-profile/passwordForm';\r\nexport { default as EditProfileForm } from './features/user-profile/editForm';\r\nexport * from './features/user-profile/avatar';\r\n\r\n// 表单组件\r\nexport * from './common/form';\r\n\r\n// 反馈组件\r\nexport { default as Toaster } from './common/feedback/toast';\r\n\r\n// 首页组件\r\nexport { default as Hero } from './features/home/hero';\r\nexport { default as HomeHeader } from './features/home/header';\r\nexport { default as Footer } from './features/home/footer';\r\nexport { default as Features } from './features/home/features';\r\nexport { default as CTA } from './features/home/cta'; "
  },
  {
    "path": "app\\dashboard\\page.tsx",
    "newContent": "\"use client\"\r\n\r\nimport { useSession } from \"next-auth/react\"\r\nimport { useRouter } from 'next/navigation'\r\nimport { useState, useEffect, useRef } from \"react\"\r\nimport { ArrowLeft } from 'lucide-react'\r\n\r\n// 导入自定义钩子\r\nimport { useProfile, usePassword, UserProfile, UserProfileInput } from '@/app/hooks'\r\nimport { useToast } from '@/app/components/features/dashboard/Toaster'\r\nimport { useValidation } from './hooks/useValidation'\r\n// 导入主题服务\r\nimport { applyTheme as applyThemeService } from '@/app/shared/themes'\r\n\r\n// 导入组件\r\nimport Modal from '@/app/components/features/dashboard/Modal'\r\nimport ProfileHeader from '@/app/components/features/dashboard/ProfileHeader'\r\nimport ProfileContent from '@/app/components/features/dashboard/ProfileContent'\r\nimport EditProfileForm from '@/app/components/features/dashboard/EditProfileForm'\r\nimport PasswordForm from '@/app/components/features/dashboard/PasswordForm'\r\nimport ProfileCompleteness from '@/app/components/features/dashboard/ProfileCompleteness'\r\n\r\n// 创建兼容旧组件的UserInfo接口\r\nexport interface UserInfo {\r\n  displayName: string;\r\n  bio: string;\r\n  location: string;\r\n  website: string;\r\n  company: string;\r\n  avatarUrl?: string | null; \r\n  theme?: string | null;     \r\n  createdAt?: string;        \r\n}\r\n\r\n// 导入样式\r\nimport styles from './Dashboard.module.css'\r\n\r\nexport default function DashboardPage() {\r\n  const router = useRouter()\r\n  const { data: session, status } = useSession({\r\n    required: true,\r\n    onUnauthenticated() {\r\n      router.push('/auth/login')\r\n    },\r\n  })\r\n  \r\n  const [isEditModalOpen, setIsEditModalOpen] = useState(false)\r\n  const [isPasswordModalOpen, setIsPasswordModalOpen] = useState(false)\r\n  \r\n  const { \r\n    user-profile, \r\n    isLoading: profileLoading, \r\n    error: profileError, \r\n    updateUserProfile,\r\n    effectiveAvatarUrl\r\n  } = useProfile()\r\n  \r\n  // 创建一个本地状态用于编辑，兼容旧的UserInfo格式\r\n  const [userInfo, setUserInfo] = useState<UserInfo>({\r\n    displayName: '',\r\n    bio: '',\r\n    location: '',\r\n    website: '',\r\n    company: '',\r\n    avatarUrl: null,\r\n    theme: null\r\n  })\r\n  \r\n  // 当user-profile更新时，同步更新userInfo\r\n  useEffect(() => {\r\n    if (user-profile) {\r\n      setUserInfo({\r\n        displayName: user-profile.name || '',\r\n        bio: user-profile.bio || '',\r\n        location: user-profile.location || '',\r\n        website: user-profile.website || '',\r\n        company: user-profile.company || '',\r\n        avatarUrl: user-profile.avatarUrl,\r\n        theme: user-profile.theme,\r\n        createdAt: user-profile.createdAt\r\n      })\r\n    }\r\n  }, [user-profile])\r\n  \r\n  const {\r\n    passwordInfo,\r\n    passwordError,\r\n    passwordSuccess,\r\n    isLoading: passwordLoading,\r\n    showPassword,\r\n    showConfirmPassword,\r\n    setShowPassword,\r\n    setShowConfirmPassword,\r\n    handlePasswordChange,\r\n    updatePassword,\r\n    resetPasswordState\r\n  } = usePassword()\r\n\r\n  const [isSaving, setIsSaving] = useState(false)\r\n  const toast = useToast()\r\n  const { validateForm } = useValidation()\r\n\r\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, field: string) => {\r\n    setUserInfo(prev => ({...prev, [field]: e.target.value}))\r\n  }\r\n\r\n  const handleSave = async () => {\r\n    try {\r\n      console.log('保存用户资料:', userInfo);\r\n      \r\n      // 表单验证\r\n      if (!validateForm(userInfo)) {\r\n        toast.error('请修正表单中的错误后再提交');\r\n        return;\r\n      }\r\n      \r\n      // 禁用保存按钮，防止重复提交\r\n      setIsSaving(true);\r\n      \r\n      // 转换为UserProfileInput格式\r\n      const profileInput: UserProfileInput = {\r\n        displayName: userInfo.displayName,\r\n        bio: userInfo.bio,\r\n        location: userInfo.location,\r\n        website: userInfo.website,\r\n        company: userInfo.company,\r\n        // 仅在非null时包含avatarUrl\r\n        ...(userInfo.avatarUrl && { avatarUrl: userInfo.avatarUrl }),\r\n        // 仅在非null时包含theme\r\n        ...(userInfo.theme && { theme: userInfo.theme })\r\n      };\r\n      \r\n      const success = await updateUserProfile(profileInput);\r\n      \r\n      if (success) {\r\n        setIsEditModalOpen(false);\r\n        // 使用Toast通知替代alert\r\n        toast.success('个人信息已成功保存！');\r\n      } else {\r\n        // 保存失败提示\r\n        toast.error('保存失败，请稍后重试');\r\n      }\r\n    } catch (error) {\r\n      console.error('保存用户资料时出错:', error);\r\n      toast.error('发生错误，请稍后重试');\r\n    } finally {\r\n      // 无论成功还是失败，都重新启用保存按钮\r\n      setIsSaving(false);\r\n    }\r\n  }\r\n\r\n  const handlePasswordSave = async () => {\r\n    const success = await updatePassword()\r\n    if (success) {\r\n      setIsPasswordModalOpen(false)\r\n    }\r\n  }\r\n\r\n  const openPasswordModal = () => {\r\n    resetPasswordState()\r\n    setIsPasswordModalOpen(true)\r\n  }\r\n\r\n  // 应用主题\r\n  useEffect(() => {\r\n    if (user-profile?.theme) {\r\n      applyTheme(user-profile.theme);\r\n    }\r\n  }, [user-profile?.theme]);\r\n\r\n  // 处理主题更改\r\n  const handleThemeChange = async (themeId: string) => {\r\n    // 先立即在本地应用主题，提升用户体验\r\n    applyTheme(themeId);\r\n    \r\n    // 更新用户资料中的主题\r\n    try {\r\n      const profileInput: UserProfileInput = {\r\n        theme: themeId\r\n      };\r\n      const success = await updateUserProfile(profileInput);\r\n      if (success) {\r\n        console.log(`主题 ${themeId} 已成功应用并保存到服务器`);\r\n      } else {\r\n        console.warn(`主题 ${themeId} 已在本地应用，但未能保存到服务器`);\r\n      }\r\n      return success;\r\n    } catch (error) {\r\n      console.error(`主题 ${themeId} 应用发生错误:`, error);\r\n      // 即使保存失败，本地主题已应用，所以依然返回true让UI保持已选状态\r\n      return true;\r\n    }\r\n  };\r\n\r\n  // 将主题应用到文档 - 使用统一的主题服务\r\n  const applyTheme = (theme: string) => {\r\n    applyThemeService(theme);\r\n  };\r\n\r\n  // 引用ProfileHeader中的fileInputRef\r\n  const fileInputRef = useRef<HTMLInputElement>(null);\r\n\r\n  // 触发头像上传功能\r\n  const handleAvatarClick = () => {\r\n    console.log('资料完整度头像点击被触发');\r\n    \r\n    // 首先尝试使用特定的class查找\r\n    const avatarInput = document.querySelector('.avatar-upload-input');\r\n    if (avatarInput && avatarInput instanceof HTMLInputElement) {\r\n      console.log('通过class找到头像上传input，触发点击');\r\n      avatarInput.click();\r\n      return;\r\n    }\r\n    \r\n    // 备用方案1：通过容器class查找\r\n    const containerInput = document.querySelector('.avatarContainer input[type=\"file\"]');\r\n    if (containerInput && containerInput instanceof HTMLInputElement) {\r\n      console.log('通过容器找到头像上传input，触发点击');\r\n      containerInput.click();\r\n      return;\r\n    }\r\n    \r\n    // 备用方案2：查找所有文件上传input\r\n    console.error('未找到精确的头像上传input元素，尝试查找所有图片上传控件');\r\n    const fileInputs = document.querySelectorAll('input[type=\"file\"]');\r\n    let found = false;\r\n    fileInputs.forEach(input => {\r\n      const fileInput = input as HTMLInputElement;\r\n      if (fileInput.accept && fileInput.accept.includes('image')) {\r\n        console.log('找到备选图片上传input，触发点击');\r\n        fileInput.click();\r\n        found = true;\r\n        return;\r\n      }\r\n    });\r\n    \r\n    if (!found) {\r\n      console.error('无法找到任何图片上传控件');\r\n      alert('无法找到头像上传控件，请尝试直接点击头像进行上传');\r\n    }\r\n  };\r\n\r\n  // 加载状态\r\n  if (status === 'loading' || profileLoading) {\r\n    return (\r\n      <div className={styles.loading}>\r\n        <div className={styles.loadingCard}>\r\n          <div className={styles.loadingSpinner}></div>\r\n          <h2 className={styles.loadingTitle}>加载中...</h2>\r\n          <p className={styles.loadingText}>正在获取您的个人信息</p>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  // 错误状态\r\n  if (profileError) {\r\n    return (\r\n      <div className={styles.errorContainer}>\r\n        <div className={styles.errorCard}>\r\n          <div className={styles.errorIcon}>⚠️</div>\r\n          <h2 className={styles.errorTitle}>加载失败</h2>\r\n          <p className={styles.errorText}>{profileError}</p>\r\n          <button\r\n            onClick={() => window.location.reload()}\r\n            className={styles.retryButton}\r\n          >\r\n            重试\r\n          </button>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  // 未登录\r\n  if (!session?.user) {\r\n    return null\r\n  }\r\n\r\n  // 编辑个人信息弹窗底部按钮\r\n  const renderEditFooter = () => (\r\n    <div className={styles.modalFooterButtons}>\r\n      <button\r\n        onClick={() => setIsEditModalOpen(false)}\r\n        className={styles.cancelButton}\r\n        disabled={isSaving}\r\n      >\r\n        取消\r\n      </button>\r\n      <button\r\n        onClick={handleSave}\r\n        className={styles.saveButton}\r\n        disabled={isSaving}\r\n      >\r\n        {isSaving ? '保存中...' : '保存更改'}\r\n      </button>\r\n    </div>\r\n  );\r\n\r\n  // 设置密码弹窗底部按钮\r\n  const renderPasswordFooter = () => (\r\n    <div className={styles.modalFooterButtons}>\r\n      <button\r\n        onClick={() => setIsPasswordModalOpen(false)}\r\n        className={styles.cancelButton}\r\n      >\r\n        取消\r\n      </button>\r\n      <button\r\n        onClick={handlePasswordSave}\r\n        className={styles.saveButton}\r\n        disabled={passwordLoading}\r\n      >\r\n        保存密码\r\n      </button>\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <div className={styles.profile}>\r\n        {/* 返回按钮 */}\r\n        <button \r\n          onClick={() => router.push('/file-management/main')}\r\n          className={styles.backButton}\r\n          title=\"返回文件管理\"\r\n        >\r\n          <ArrowLeft className=\"w-5 h-5\" />\r\n        </button>\r\n        \r\n        <div className={styles.profileHeader}>\r\n          {/* 个人资料头部 */}\r\n          <ProfileHeader \r\n            session={session}\r\n            userInfo={userInfo}\r\n            onEditClick={() => setIsEditModalOpen(true)}\r\n            onPasswordClick={openPasswordModal}\r\n            isLoading={profileLoading || passwordLoading}\r\n            onAvatarChange={async (avatarUrl) => {\r\n              console.log('头像变更被触发，新URL:', avatarUrl);\r\n              \r\n              try {\r\n                // 创建新的userInfo对象\r\n                const updatedInfo = {...userInfo, avatarUrl};\r\n                console.log('更新后的userInfo:', updatedInfo);\r\n                \r\n                // 更新本地状态\r\n                setUserInfo(updatedInfo);\r\n                \r\n                // 转换为UserProfileInput格式\r\n                const profileInput: UserProfileInput = {\r\n                  displayName: updatedInfo.displayName,\r\n                  bio: updatedInfo.bio,\r\n                  location: updatedInfo.location,\r\n                  website: updatedInfo.website,\r\n                  company: updatedInfo.company,\r\n                  avatarUrl: updatedInfo.avatarUrl,\r\n                  // 仅在theme不为null时包含\r\n                  ...(updatedInfo.theme && { theme: updatedInfo.theme })\r\n                };\r\n                \r\n                // 保存到数据库并等待完成\r\n                const success = await updateUserProfile(profileInput);\r\n                console.log('保存头像到数据库结果:', success ? '成功' : '失败');\r\n                \r\n                // 如果保存失败，强制重新获取用户数据\r\n                if (!success) {\r\n                  window.location.reload(); // 最后的手段：刷新整个页面\r\n                }\r\n              } catch (error) {\r\n                console.error('处理头像变更时出错:', error);\r\n                alert('更新头像失败，请稍后再试');\r\n              }\r\n            }}\r\n          />\r\n        </div>\r\n        \r\n        {/* 资料完整度 */}\r\n        <ProfileCompleteness \r\n          userInfo={userInfo} \r\n          onEditClick={() => setIsEditModalOpen(true)}\r\n          onAvatarClick={handleAvatarClick}\r\n        />\r\n        \r\n        {/* 个人资料内容 */}\r\n        <ProfileContent \r\n          session={session}\r\n          userInfo={userInfo}\r\n          isLoading={profileLoading || passwordLoading}\r\n        />\r\n      </div>\r\n\r\n      {/* 编辑个人信息弹窗 */}\r\n      <Modal\r\n        isOpen={isEditModalOpen}\r\n        onClose={() => setIsEditModalOpen(false)}\r\n        title=\"编辑个人信息\"\r\n        footer={renderEditFooter()}\r\n      >\r\n        <EditProfileForm \r\n          userInfo={userInfo}\r\n          onInputChange={handleInputChange}\r\n        />\r\n      </Modal>\r\n\r\n      {/* 设置密码弹窗 */}\r\n      <Modal\r\n        isOpen={isPasswordModalOpen}\r\n        onClose={() => setIsPasswordModalOpen(false)}\r\n        title=\"设置密码\"\r\n        footer={renderPasswordFooter()}\r\n      >\r\n        <PasswordForm\r\n          passwordInfo={passwordInfo}\r\n          passwordError={passwordError}\r\n          passwordSuccess={passwordSuccess}\r\n          showPassword={showPassword}\r\n          showConfirmPassword={showConfirmPassword}\r\n          setShowPassword={setShowPassword}\r\n          setShowConfirmPassword={setShowConfirmPassword}\r\n          handlePasswordChange={handlePasswordChange}\r\n          userEmail={session.user.email}\r\n        />\r\n      </Modal>\r\n    </div>\r\n  )\r\n} "
  },
  {
    "path": "app\\file-management\\main\\page.tsx",
    "newContent": "// @ts-nocheck\n'use client';\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useSession, signOut } from 'next-auth/react';\nimport { useRouter } from 'next/navigation';\nimport { message, Spin } from 'antd';\nimport Head from 'next/head';\n\n// 引入共享组件\nimport { Sidebar } from '@/app/components/features/file-management/navigation/Sidebar';\nimport { Breadcrumb } from '@/app/components/features/file-management/navigation/Breadcrumb';\nimport { FileList } from '@/app/components/features/file-management/fileList/FileList';\nimport { SkeletonPageLayout } from '@/app/components/features/file-management/shared/Skeleton';\nimport { ErrorDisplay } from '@/app/components/features/file-management/shared/ErrorDisplay';\nimport UploadModal from '@/app/components/features/file-management/upload/UploadModal';\nimport { FilePreview } from '@/app/components/features/file-management/filePreview/FilePreview';\nimport { RenameModal } from '@/app/components/features/file-management/fileOperations/RenameModal';\nimport ThemePanel from '@/app/shared/themes/components/ThemePanel';\n\n// 导入自定义组件\nimport MiniSidebar from '@/app/components/features/file-management/navigation/MiniSidebar';\nimport { TopActionBar } from '@/app/components/features/file-management/actionBar/TopActionBar';\nimport NewFolderForm from '@/app/components/features/file-management/folderManagement/NewFolderForm';\nimport { SearchView } from '@/app/components/features/file-management/SearchView';\n\n// 导入自定义 hooks\nimport { \n  useFiles, \n  useFileOperations, \n  useFileUpload, \n  useFileSearch, \n  useFilePreview,\n  useLoadingState, \n  useUIState, \n  useThemeManager, \n  useProfile \n} from '@/app/hooks';\n// 导入类型和工具函数\nimport { SortOrder, FileInfo } from '@/app/types';\nimport { convertFilesForDisplay } from '@/app/utils/file/converter';\n\n// 导入样式\nimport styles from '../styles/shared.module.css';\n\nexport default function FileManagementPage() {\n  const router = useRouter();\n  const { data: session, status } = useSession();\n  \n  // 获取用户资料相关状态，包括加载状态\n  const { \n    user-profile, \n    isLoading: profileLoading, \n    error: profileError,\n    fetchUserProfile, \n    forceRefreshProfile,\n    effectiveAvatarUrl\n  } = useProfile();\n\n  // 使用主题管理hook\n  const { currentTheme, updateTheme } = useThemeManager();\n\n  // 使用双状态加载管理\n  const {\n    loadingState,\n    error: loadingError,\n    isInitialLoading,\n    isRefreshing,\n    isError: isLoadingError,\n    startLoading,\n    finishLoading\n  } = useLoadingState({\n    initialLoad: true,\n    minLoadingTime: 800\n  });\n  \n  // 使用useFiles钩子获取文件列表和相关操作\n  const {\n    files,\n    isLoading: filesLoading,\n    error: filesError,\n    currentFolderId,\n    folderPath,\n    selectedFileType,\n    selectedFiles,\n    sortOrder,\n    loadFiles,\n    toggleSelectFile: handleSelectFile,\n    toggleSelectAll,\n    changeSort,\n    filterByFileType,\n    openFolder,\n    refreshCurrentFolder,\n    handleFileClick,\n    handleBackClick,\n    handleFileUpdate,\n    setCurrentFolderId,\n    setFolderPath,\n    setSelectedFileType,\n    setSelectedFiles,\n    setSortOrder\n  } = useFiles();\n\n  // UI状态管理\n  const {\n    sidebarVisible,\n    myFilesExpanded,\n    quickAccessExpanded,\n    isUploadModalOpen,\n    isFolderUploadModalOpen,\n    showUploadDropdown,\n    setSidebarVisible,\n    setMyFilesExpanded,\n    setQuickAccessExpanded,\n    setIsUploadModalOpen,\n    setIsFolderUploadModalOpen,\n    setShowUploadDropdown,\n    uploadDropdownRef\n  } = useUIState();\n\n  // 添加主题面板状态\n  const [showThemePanel, setShowThemePanel] = useState(false);\n\n  // 文件操作钩子\n  const {\n    createFolder: handleCreateFolder,\n    downloadFiles: handleDownload,\n    deleteFiles: handleDelete,\n    renameFile: handleRenameFile,\n    isLoading: fileOperationsLoading,\n    error: fileOperationsError\n  } = useFileOperations([]);\n\n  // 先调用文件搜索钩子，确保updateFileInResults可用\n  const {\n    searchQuery,\n    setSearchQuery,\n    searchResults,\n    isLoading: searchLoading,\n    error: searchError,\n    showSearchView,\n    setShowSearchView,\n    searchType,\n    setSearchType,\n    enableRealTimeSearch,\n    setEnableRealTimeSearch,\n    debounceDelay,\n    setDebounceDelay,\n    handleSearch,\n    updateFileInResults\n  } = useFileSearch();\n\n  // 文件预览和重命名 - 传入selectedFileType参数\n  const {\n    previewFile,\n    setPreviewFile,\n    handlePreview: handlePreviewFile,\n    closePreview: handleClosePreview,\n    isRenameModalOpen,\n    setIsRenameModalOpen,\n    fileToRename,\n    setFileToRename,\n    openRename: handleRenameButtonClick,\n    renameFile: handleConfirmEdit\n  } = useFilePreview({\n    onRefresh: () => loadFiles(currentFolderId, selectedFileType, true),\n    onFileUpdate: handleFileUpdate,  // 传入文件更新处理函数\n    onSearchResultsUpdate: updateFileInResults,  // 传入搜索结果更新函数\n    selectedFileType  // 传入当前选择的文件类型\n  });\n\n  // 添加创建文件夹相关状态\n  const [isCreatingFolder, setIsCreatingFolder] = useState(false);\n  const [newFolderName, setNewFolderName] = useState('');\n  const [newFolderTags, setNewFolderTags] = useState<string[]>([]);\n  const [editingFile, setEditingFile] = useState<any>(null);\n  const [editingName, setEditingName] = useState('');\n  const [editingTags, setEditingTags] = useState<string[]>([]);\n  const [newTag, setNewTag] = useState('');\n  const [selectedFile, setSelectedFile] = useState<FileInfo | null>(null);\n\n  // 文件上下文菜单处理 - 移至hooks声明区域\n  const handleFileContextMenu = useCallback((e, file, setSelectedFile, setSelectedFiles) => {\n    // 阻止默认右键菜单\n    e?.preventDefault();\n    e?.stopPropagation();\n    \n    if (file) {\n      // 设置当前选中的文件\n      setSelectedFile?.(file);\n      \n      // 如果是单击选择，只选择当前文件\n      if (e?.type === 'contextmenu') {\n        setSelectedFiles?.([file.id]);\n      }\n      \n      // 如果是文件（不是文件夹），可以设置为要重命名的文件\n      if (!file.isFolder) {\n        setFileToRename(file);\n      }\n    }\n  }, [setFileToRename]);\n\n  // 标签相关处理函数\n  const handleAddTag = useCallback((tag: string) => {\n    if (editingFile) {\n      setEditingTags(prev => [...prev, tag]);\n    } else {\n      setNewFolderTags(prev => [...prev, tag]);\n    }\n    setNewTag('');\n  }, [editingFile]);\n\n  const handleRemoveTag = useCallback((tag: string) => {\n    if (editingFile) {\n      setEditingTags(prev => prev.filter(t => t !== tag));\n    } else {\n      setNewFolderTags(prev => prev.filter(t => t !== tag));\n    }\n  }, [editingFile]);\n\n  // 状态跟踪引用\n  const hasLoadedFilesRef = React.useRef(false);\n  const sessionInitializedRef = React.useRef(false);\n  // 添加防止重复加载的标志，放在顶层\n  const loadInProgressRef = useRef(false);\n\n  // 在文件上传或文件夹上传成功后触发的函数\n  const handleUploadSuccess = useCallback(() => {\n    // 开始刷新加载状态\n    startLoading(true);\n    \n    // 刷新文件列表，保持当前文件类型过滤，并强制刷新\n    loadFiles(currentFolderId, selectedFileType, true).finally(() => {\n      finishLoading();\n    });\n  }, [currentFolderId, loadFiles, selectedFileType, startLoading, finishLoading]);\n\n  // 处理创建文件夹按钮点击\n  const handleCreateFolderClick = useCallback(() => {\n    setIsCreatingFolder(true);\n  }, [setIsCreatingFolder]);\n\n  const handleSignOut = useCallback(async () => {\n    try {\n      await signOut({ \n        callbackUrl: '/',\n        redirect: true \n      });\n    } catch (error) {\n      console.error('退出时发生错误:', error);\n      // 如果发生错误，尝试强制跳转到首页\n      window.location.href = '/';\n    }\n  }, []);\n\n  // Sidebar中\"搜索文件\"点击处理函数\n  const handleSearchClick = useCallback(() => {\n    setShowSearchView(true);\n  }, [setShowSearchView]);\n\n  // 处理文件点击\n  const handleFileItemClick = useCallback((file) => {\n    const localFile = files.find(f => f.id === file.id);\n    if (!localFile) return;\n\n    if (localFile.isFolder) {\n      // 如果是文件夹，继续使用原有的导航逻辑\n      handleFileClick(localFile);\n    } else {\n      // 如果是文件，打开预览\n      handlePreviewFile(localFile);\n    }\n  }, [files, handleFileClick, handlePreviewFile]);\n\n  // 处理全选文件\n  const onSelectAllFiles = useCallback(() => {\n    setSelectedFiles(files.map(file => file.id));\n  }, [files, setSelectedFiles]);\n\n  // 处理取消全选\n  const onDeselectAllFiles = useCallback(() => {\n    setSelectedFiles([]);\n  }, [setSelectedFiles]);\n\n  // 处理文件复选框变化\n  const onFileCheckboxChange = useCallback((file: FileInfo, checked: boolean) => {\n    handleSelectFile(file.id, checked);\n  }, [handleSelectFile]);\n\n  // 处理返回根目录/清除过滤器 - 移到这里\n  const handleClearFilter = useCallback(() => {\n    setShowSearchView(false);\n    setSelectedFileType(null);\n    setCurrentFolderId(null);\n    setFolderPath([]);\n    \n    // 开始刷新加载状态\n    startLoading(true);\n    \n    // 传递null类型参数以确保清除过滤，并强制刷新\n    loadFiles(null, null, true)\n      .finally(() => finishLoading());\n  }, [setShowSearchView, setSelectedFileType, setCurrentFolderId, setFolderPath, startLoading, loadFiles, finishLoading]);\n\n  // 处理根目录点击 - 移到这里\n  const handleRootClick = useCallback(() => {\n    setCurrentFolderId(null);\n    setFolderPath([]);\n    \n    // 开始刷新加载状态\n    startLoading(true);\n    \n    // 保持当前选中的文件类型，并强制刷新\n    loadFiles(null, selectedFileType, true)\n      .finally(() => finishLoading());\n  }, [setCurrentFolderId, setFolderPath, startLoading, loadFiles, selectedFileType, finishLoading]);\n\n  // 重定向逻辑优化\n  useEffect(() => {\n    // 只在状态确定时执行，避免初始loading状态触发重定向\n    if (status === 'unauthenticated') {\n      console.log('用户未认证，重定向到登录页面');\n      router.replace('/auth/login');\n    } else if (status === 'authenticated') {\n      console.log('用户已认证，确认会话状态');\n      sessionInitializedRef.current = true;\n    }\n  }, [status, router]);\n\n  // 文件加载逻辑优化\n  useEffect(() => {\n    // 确保session存在且状态为已认证，且文件未加载过\n    if (status === 'authenticated' && session?.user && !hasLoadedFilesRef.current && !loadInProgressRef.current) {\n      console.log('初始加载文件列表', { currentFolderId, selectedFileType, session: !!session });\n      \n      // 标记已经开始加载\n      hasLoadedFilesRef.current = true;\n      loadInProgressRef.current = true;\n      \n      // 开始加载，这是初始加载，使用骨架屏\n      startLoading(false);\n      \n      // 添加延迟，确保session完全初始化\n      setTimeout(() => {\n        // 修改为先加载用户资料，成功后再加载文件列表\n        fetchUserProfile()\n          .then(user-profileData => {\n            if (user-profileData) {\n              console.log('用户资料加载成功，继续加载文件列表');\n              // 只有在用户资料加载成功后才加载文件列表，并强制刷新\n              return loadFiles(currentFolderId, selectedFileType, true)\n                .then(() => {\n                  console.log('文件列表加载成功，完成初始化加载');\n                  finishLoading(false);\n                  loadInProgressRef.current = false;\n                })\n                .catch(error => {\n                  console.error('加载文件列表失败:', error);\n                  finishLoading(true, '加载文件列表失败');\n                  loadInProgressRef.current = false;\n                });\n            } else {\n              console.log('用户资料为空，尝试重新获取...');\n              // 增加重试延迟，确保session稳定\n              return new Promise(resolve => setTimeout(resolve, 1000))\n                .then(() => fetchUserProfile(true)) // 强制刷新模式\n                .then(retryProfileData => {\n                  if (retryProfileData) {\n                    console.log('重试获取用户资料成功，继续加载文件列表');\n                    return loadFiles(currentFolderId, selectedFileType, true)\n                      .then(() => {\n                        console.log('文件列表加载成功，完成初始化加载');\n                        finishLoading(false);\n                        loadInProgressRef.current = false;\n                      })\n                      .catch(error => {\n                        console.error('加载文件列表失败:', error);\n                        finishLoading(true, '加载文件列表失败');\n                        loadInProgressRef.current = false;\n                      });\n                  } else {\n                    console.error('重试获取用户资料失败');\n                    loadInProgressRef.current = false;\n                    throw new Error(\"获取用户资料失败，请刷新页面重试\");\n                  }\n                });\n            }\n          })\n          .catch((error) => {\n            console.error('加载过程出错:', error);\n            // 再次尝试获取用户资料，加强容错性\n            setTimeout(() => {\n              console.log('最后一次尝试获取用户资料...');\n              fetchUserProfile(true)\n                .then(lastTryProfile => {\n                  if (lastTryProfile) {\n                    console.log('最后尝试成功，继续加载文件列表');\n                    loadFiles(currentFolderId, selectedFileType, true)\n                      .then(() => {\n                        finishLoading(false);\n                        loadInProgressRef.current = false;\n                      })\n                      .catch(err => {\n                        finishLoading(true, '加载文件列表失败');\n                        loadInProgressRef.current = false;\n                      });\n                  } else {\n                    finishLoading(true, '获取用户资料失败，请刷新页面重试');\n                    loadInProgressRef.current = false;\n                  }\n                })\n                .catch(err => {\n                  finishLoading(true, err.message || '加载失败，请重试');\n                  loadInProgressRef.current = false;\n                });\n            }, 1500);\n          });\n      }, 500); // 短暂延迟，等待session稳定\n    }\n  }, [status, session, currentFolderId, selectedFileType, loadFiles, fetchUserProfile, startLoading, finishLoading]);\n\n  // 初始化Lucide图标\n  useEffect(() => {\n    // @ts-ignore\n    window.lucide?.createIcons();\n  }, []);\n  \n  // 计算所有文件是否全部选中\n  const areAllFilesSelected = files.length > 0 && selectedFiles.length === files.length;\n\n  // 使用初始化加载状态显示骨架屏\n  if (isInitialLoading) {\n    console.log('显示骨架屏加载状态');\n    return <SkeletonPageLayout />;\n  }\n\n  // 如果用户状态正在加载，显示更简单的加载提示\n  if (status === 'loading') {\n    console.log('显示用户认证加载状态');\n    return (\n      <div className={styles.loading}>\n        <div className={styles.loadingCard}>\n          <div className={styles.loadingSpinner}></div>\n          <h3 className={styles.loadingTitle}>正在加载</h3>\n          <p className={styles.loadingText}>请稍候，正在验证您的身份...</p>\n        </div>\n      </div>\n    );\n  }\n\n  // 修改错误处理逻辑，使用新的ErrorDisplay组件\n  if (isLoadingError) {\n    console.log('显示错误状态，原因:', loadingError);\n    \n    // 根据错误信息判断错误类型\n    let errorType: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown' = 'unknown';\n    \n    if (loadingError) {\n      if (loadingError.includes('网络') || loadingError.includes('连接')) {\n        errorType = 'network';\n      } else if (loadingError.includes('超时')) {\n        errorType = 'timeout';\n      } else if (loadingError.includes('服务器')) {\n        errorType = 'server';\n      } else if (loadingError.includes('数据') || loadingError.includes('资料')) {\n        errorType = 'data';\n      } else if (loadingError.includes('认证') || loadingError.includes('登录')) {\n        errorType = 'auth';\n      }\n    }\n    \n    return (\n      <ErrorDisplay \n        errorType={errorType}\n        message={loadingError || \"请刷新页面重试或联系管理员\"}\n        onRetry={() => {\n          startLoading(false);\n          fetchUserProfile(true)\n            .then(() => {\n              return loadFiles(currentFolderId, selectedFileType, true);\n            })\n            .then(() => finishLoading())\n            .catch((err) => finishLoading(true, err.message));\n        }}\n      />\n    );\n  }\n\n  // 添加一个额外的检查，如果用户资料仍在加载中，继续显示骨架屏\n  if (profileLoading) {\n    console.log('用户资料状态: 仍在加载中', { profileLoading });\n    return <SkeletonPageLayout />;\n  }\n  \n  // 单独检查用户资料是否存在\n  if (!user-profile) {\n    console.log('用户资料状态: 未获取到用户资料', { hasProfile: false });\n    return <SkeletonPageLayout />;\n  }\n\n  return (\n    <>\n      <Head>\n        <title>文件管理 - 云盘</title>\n      </Head>\n      \n      <div className={styles.file-managementContainer}>\n        {/* Mini侧边栏 */}\n        <MiniSidebar \n          avatarUrl={effectiveAvatarUrl}\n          userName={user-profile?.name}\n          userEmail={user-profile?.email}\n          onHomeClick={handleRootClick}\n          onLogoutClick={handleSignOut}\n          onAvatarClick={() => {\n            router.push('/dashboard');\n          }}\n          currentTheme={currentTheme}\n          onThemeClick={() => {\n            // 切换主题面板显示状态，同时关闭其他面板\n            setShowThemePanel(!showThemePanel);\n            // 如果打开主题面板，关闭搜索和文件预览\n            if (!showThemePanel) {\n              setShowSearchView(false);\n              if (previewFile) {\n                handleClosePreview();\n              }\n            }\n          }}\n        />\n\n        {/* 侧边栏 - 仅在非主题模式下显示 */}\n        {sidebarVisible && !showThemePanel && (\n          <div className={styles.sidebarContainer}>\n            <Sidebar\n              selectedFileType={selectedFileType}\n              onTypeClick={(type) => {\n                console.log('侧边栏类型点击:', type);\n                \n                // 开始刷新加载状态\n                startLoading(true);\n                \n                // 先更新状态\n                setSelectedFileType(type);\n                setCurrentFolderId(null);\n                setFolderPath([]);\n                \n                // 使用新的参数传递方式，直接传入点击的类型\n                loadFiles(null, type)\n                  .finally(() => finishLoading());\n              }}\n              onSearchClick={handleSearchClick}\n            />\n          </div>\n        )}\n\n        {/* 根据视图状态显示不同内容 */}\n        {showThemePanel ? (\n          /* 主题设置视图 */\n          <ThemePanel \n            currentTheme={currentTheme}\n            onThemeChange={async (themeId) => {\n              const success = await updateTheme(themeId);\n              return success;\n            }}\n            onClose={() => setShowThemePanel(false)}\n          />\n        ) : (\n          /* 文件管理视图 */\n          <div className={styles.mainContent}>\n            {/* 当内容刷新加载时显示局部加载状态 */}\n            {isRefreshing && (\n              <div className={styles.refreshingOverlay}>\n                <Spin tip=\"正在刷新...\" />\n              </div>\n            )}\n            \n            {/* 顶部操作栏 */}\n            <TopActionBar \n              selectedFiles={selectedFiles}\n              onClearSelection={() => setSelectedFiles([])}\n              onDownload={handleDownload}\n              onRename={() => {\n                // 如果选中了多个文件，提示用户一次只能重命名一个文件\n                if (selectedFiles.length > 1) {\n                  message.warning('一次只能重命名一个文件');\n                  return;\n                }\n                \n                // 如果选中了一个文件，找到该文件并打开重命名对话框\n                if (selectedFiles.length === 1) {\n                  const selectedFile = files.find(file => file.id === selectedFiles[0]);\n                  if (selectedFile) {\n                    console.log('打开重命名对话框，文件:', {\n                      id: selectedFile.id,\n                      name: selectedFile.name,\n                      isFolder: selectedFile.isFolder\n                    });\n                    handleRenameButtonClick(selectedFile);\n                  } else {\n                    message.warning('未找到选中的文件');\n                  }\n                } else {\n                  message.warning('请先选择要重命名的文件');\n                }\n              }}\n              onMove={() => {}}\n              onDelete={handleDelete}\n              onClearFilter={handleClearFilter}\n              onCreateFolder={handleCreateFolderClick}\n              selectedFileType={selectedFileType}\n              showSearchView={showSearchView}\n              isInRootFolder={!currentFolderId && !selectedFileType && !showSearchView}\n              sortOrder={sortOrder}\n              setSortOrder={setSortOrder}\n              showUploadDropdown={showUploadDropdown}\n              setShowUploadDropdown={setShowUploadDropdown}\n              setIsUploadModalOpen={setIsUploadModalOpen}\n              setIsFolderUploadModalOpen={setIsFolderUploadModalOpen}\n              uploadDropdownRef={uploadDropdownRef}\n            />\n            \n            {/* 面包屑导航栏 */}\n            <div className={styles.breadcrumbBar}>\n              <Breadcrumb \n                folderPath={folderPath} \n                showHome={true}\n                onPathClick={(folderId) => {\n                  if (folderId === null) {\n                    setCurrentFolderId(null);\n                    setFolderPath([]);\n                    \n                    // 开始刷新加载状态\n                    startLoading(true);\n                    \n                    loadFiles(null, selectedFileType)\n                      .finally(() => finishLoading());\n                  } else {\n                    // 查找用户点击的路径索引\n                    const index = folderPath.findIndex(p => p.id === folderId);\n                    if (index !== -1) {\n                      // 切断索引之后的部分\n                      const newPath = folderPath.slice(0, index + 1);\n                      setFolderPath(newPath);\n                      setCurrentFolderId(folderId);\n                      \n                      // 开始刷新加载状态\n                      startLoading(true);\n                      \n                      loadFiles(folderId, selectedFileType)\n                        .finally(() => finishLoading());\n                    }\n                  }\n                }}\n                onBackClick={() => {\n                  if (folderPath.length > 0) {\n                    handleBackClick();\n                  }\n                }}\n              />\n            </div>\n\n            {/* 搜索视图或文件列表视图 */}\n            <div className={styles.fileListWrapper}>\n              {showSearchView ? (\n                <div className=\"search-view-container\">\n                  <SearchView \n                    searchType={searchType}\n                    setSearchType={setSearchType}\n                    searchQuery={searchQuery}\n                    setSearchQuery={setSearchQuery}\n                    searchResults={searchResults}\n                    isLoading={searchLoading}\n                    error={searchError}\n                    handleSearch={handleSearch}\n                    handleFileClick={handleFileItemClick}\n                    enableRealTimeSearch={enableRealTimeSearch}\n                    setEnableRealTimeSearch={setEnableRealTimeSearch}\n                    debounceDelay={debounceDelay}\n                    setDebounceDelay={setDebounceDelay}\n                  />\n                </div>\n              ) : (\n                // 文件列表\n                <>\n                  {isCreatingFolder && (\n                    <NewFolderForm \n                      folderName={newFolderName}\n                      setFolderName={setNewFolderName}\n                      folderTags={newFolderTags}\n                      setFolderTags={setNewFolderTags}\n                      onCreateFolder={() => {\n                        // 先判断文件夹名称是否为空\n                        if (!newFolderName || !newFolderName.trim()) {\n                          return; // 如果为空，直接返回\n                        }\n                        \n                        console.log('开始创建文件夹:', newFolderName);\n                        \n                        // 确保传递名称和标签\n                        handleCreateFolder(newFolderName, currentFolderId, newFolderTags)\n                          .then(folderId => {\n                            console.log('文件夹创建返回ID:', folderId);\n                            \n                            // 只要返回值不是null，就认为是成功的\n                            if (folderId !== null) {\n                              console.log('文件夹创建成功，准备刷新');\n                              // 创建成功，关闭表单并刷新\n                              setIsCreatingFolder(false);\n                              setNewFolderName('');\n                              setNewFolderTags([]);\n                              \n                              // 刷新当前文件夹\n                              loadFiles(currentFolderId, selectedFileType, true)\n                                .then(() => {\n                                  console.log('文件列表刷新完成');\n                                })\n                                .catch(err => {\n                                  console.error('刷新文件列表失败:', err);\n                                });\n                            } else {\n                              console.error('创建文件夹失败，API返回null');\n                            }\n                          })\n                          .catch(error => {\n                            console.error('创建文件夹请求出错:', error);\n                          });\n                      }}\n                      onCancel={() => {\n                        setIsCreatingFolder(false);\n                        setNewFolderName('');\n                        setNewFolderTags([]);\n                      }}\n                    />\n                  )}\n\n                  {/* 文件列表组件 */}\n                  <FileList \n                    files={convertFilesForDisplay(files)}\n                    onFileClick={handleFileItemClick}\n                    onFileSelect={(file, checked) => onFileCheckboxChange(file as FileInfo, checked)}\n                    onSelectAll={onSelectAllFiles}\n                    onDeselectAll={onDeselectAllFiles}\n                    selectedFiles={selectedFiles}\n                    onFileContextMenu={(e, file) => handleFileContextMenu(e, file, setSelectedFile, setSelectedFiles)}\n                    onBackClick={folderPath.length > 0 ? handleBackClick : undefined}\n                    isLoading={filesLoading}\n                    error={filesError}\n                    editingFile={editingFile}\n                    editingName={editingName}\n                    editingTags={editingTags}\n                    onEditNameChange={setEditingName}\n                    onConfirmEdit={handleConfirmEdit}\n                    onCancelEdit={() => setEditingFile(null)}\n                    onAddTag={handleAddTag}\n                    onRemoveTag={handleRemoveTag}\n                    newTag={newTag}\n                    onNewTagChange={setNewTag}\n                    showCheckboxes={true}\n                    areAllSelected={areAllFilesSelected}\n                  />\n                </>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n      \n      {/* 上传模态窗口 */}\n      <UploadModal \n        isOpen={isUploadModalOpen} \n        onClose={() => setIsUploadModalOpen(false)} \n        onSuccess={handleUploadSuccess}\n        currentFolderId={currentFolderId}\n        isFolderUpload={false}\n      />\n      \n      <UploadModal \n        isOpen={isFolderUploadModalOpen} \n        onClose={() => setIsFolderUploadModalOpen(false)} \n        onSuccess={handleUploadSuccess}\n        currentFolderId={currentFolderId}\n        isFolderUpload={true}\n      />\n\n      {/* 重命名模态窗口 */}\n      <RenameModal\n        isOpen={isRenameModalOpen}\n        onClose={() => setIsRenameModalOpen(false)}\n        onRename={(newName, tags) => {\n          if (!fileToRename) {\n            message.warning('未选择要重命名的文件');\n            return;\n          }\n          \n          console.log('准备重命名文件:', {\n            id: fileToRename.id,\n            name: fileToRename.name,\n            newName: newName,\n            tagsCount: tags?.length || 0\n          });\n          \n          // 使用useFilePreview的renameFile函数\n          handleConfirmEdit(newName, tags)\n            .then(success => {\n              if (success) {\n                console.log('重命名成功，刷新文件列表');\n              } else {\n                console.error('重命名失败');\n              }\n            })\n            .catch(err => {\n              console.error('重命名过程出错:', err);\n            });\n        }}\n        initialName={fileToRename?.name || ''}\n        initialTags={fileToRename?.tags || []}\n        fileType={fileToRename?.isFolder ? 'folder' : 'file'}\n      />\n\n      {/* 文件预览组件应该位于整个应用的最外层，确保它覆盖其他所有内容 */}\n      {previewFile && (\n        <FilePreview\n          file={previewFile}\n          onClose={handleClosePreview}\n          onDownload={handleDownload}\n        />\n      )}\n    </>\n  );\n}\n       "
  },
  {
    "path": "app\\hooks\\user\\useProfile.ts",
    "newContent": "import { useState, useEffect, useRef, useCallback } from \"react\"\r\nimport { useSession } from \"next-auth/react\"\r\nimport { toast } from 'sonner'\r\nimport { applyTheme as applyThemeService } from \"@/app/shared/themes\"\r\n\r\n/**\r\n * 用户资料接口\r\n */\r\nexport interface UserProfile {\r\n  /** 用户ID */\r\n  id: string\r\n  /** 邮箱 */\r\n  email: string\r\n  /** 用户名 */\r\n  name: string | null\r\n  /** 头像URL */\r\n  avatarUrl?: string | null\r\n  /** 主题 */\r\n  theme?: string | null\r\n  /** 已使用存储空间（字节） */\r\n  storageUsed: number\r\n  /** 存储空间限制（字节） */\r\n  storageLimit: number\r\n  /** 用户简介 */\r\n  bio?: string\r\n  /** 位置 */\r\n  location?: string\r\n  /** 网站 */\r\n  website?: string\r\n  /** 公司 */\r\n  company?: string\r\n  /** 创建时间 */\r\n  createdAt: string\r\n  /** 更新时间 */\r\n  updatedAt: string\r\n}\r\n\r\n/**\r\n * 用户资料更新输入\r\n */\r\nexport interface UserProfileInput {\r\n  /** 显示名称 */\r\n  displayName?: string\r\n  /** 头像URL */\r\n  avatarUrl?: string\r\n  /** 主题 */\r\n  theme?: string\r\n  /** 用户简介 */\r\n  bio?: string\r\n  /** 位置 */\r\n  location?: string\r\n  /** 网站 */\r\n  website?: string\r\n  /** 公司 */\r\n  company?: string\r\n}\r\n\r\n/**\r\n * 用户资料API响应\r\n */\r\nexport interface UserProfileResponse {\r\n  /** 是否成功 */\r\n  success: boolean\r\n  /** 用户资料 */\r\n  profile?: UserProfile\r\n  /** 错误信息 */\r\n  error?: string\r\n}\r\n\r\n// 默认离线用户配置，当API不可用时使用\r\nconst DEFAULT_OFFLINE_PROFILE: UserProfile = {\r\n  id: 'offline-user',\r\n  email: 'offline@example.com',\r\n  name: '离线模式',\r\n  avatarUrl: null,\r\n  theme: 'default',\r\n  storageUsed: 0,\r\n  storageLimit: 1024 * 1024 * 100, // 100MB\r\n  createdAt: new Date().toISOString(),\r\n  updatedAt: new Date().toISOString()\r\n}\r\n\r\n// 重试配置\r\nconst RETRY_DELAY = 3000 // 3秒\r\nconst MAX_RETRIES = 2 // 最大重试次数\r\nconst MAX_ERROR_COUNT = 3 // 连续错误阈值，超过后进入离线模式\r\n\r\n/**\r\n * 用户资料Hook\r\n * 提供用户资料的获取、更新和管理功能\r\n * \r\n * @returns 用户资料和相关操作方法\r\n */\r\nexport function useProfile() {\r\n  const { data: session } = useSession()\r\n  const [user-profile, setUserProfile] = useState<UserProfile | null>(null)\r\n  const [isLoading, setIsLoading] = useState(true)\r\n  const [error, setError] = useState<string | null>(null)\r\n  const [isOfflineMode, setIsOfflineMode] = useState(false)\r\n  const [consecutiveErrors, setConsecutiveErrors] = useState(0)\r\n  const abortControllerRef = useRef<AbortController | null>(null)\r\n  const lastFetchTimeRef = useRef<number>(0)\r\n  const sessionChangeRef = useRef<number>(0)\r\n\r\n  // 有效的头像URL，优先使用用户资料中的，其次是会话中的\r\n  const effectiveAvatarUrl = user-profile?.avatarUrl || session?.user?.image || null\r\n\r\n  /**\r\n   * 获取用户资料\r\n   * @param showToast 是否显示加载成功的提示\r\n   * @param retryCount 重试次数\r\n   * @returns 用户资料\r\n   */\r\n  const fetchUserProfile = useCallback(async (showToast = false, retryCount = 0) => {\r\n    // 判断是否在短时间内重复调用，避免频繁请求\r\n    const now = Date.now()\r\n    const timeSinceLastFetch = now - lastFetchTimeRef.current\r\n    \r\n    if (retryCount === 0 && timeSinceLastFetch < 2000 && lastFetchTimeRef.current > 0) {\r\n      console.log(`距上次请求仅 ${timeSinceLastFetch}ms，跳过此次请求`)\r\n      return user-profile\r\n    }\r\n    \r\n    lastFetchTimeRef.current = now\r\n\r\n    // 添加更详细的 session 检查日志\r\n    console.log('获取用户资料检查 session 状态:', { \r\n      sessionExists: !!session, \r\n      hasUser: !!session?.user, \r\n      userEmail: session?.user?.email || 'unknown',\r\n      retryCount \r\n    })\r\n\r\n    if (!session || !session.user) {\r\n      console.log('未检测到有效会话，无法获取用户资料')\r\n      setIsLoading(false)\r\n      setError('未检测到有效会话')\r\n      return null\r\n    }\r\n\r\n    // 如果已经超过最大错误数，并且已经进入离线模式，则使用离线配置\r\n    if (isOfflineMode && retryCount === 0) {\r\n      console.log('应用正在离线模式下运行，使用默认配置')\r\n      if (!user-profile) {\r\n        const offlineProfile = {\r\n          ...DEFAULT_OFFLINE_PROFILE,\r\n          email: session.user?.email || DEFAULT_OFFLINE_PROFILE.email,\r\n          name: session.user?.name || DEFAULT_OFFLINE_PROFILE.name,\r\n        }\r\n        setUserProfile(offlineProfile)\r\n        setIsLoading(false)\r\n        return offlineProfile\r\n      }\r\n      setIsLoading(false)\r\n      return user-profile\r\n    }\r\n\r\n    // 如果已经有用户资料且不是重试模式，则直接返回现有资料\r\n    if (user-profile && !showToast && retryCount === 0) {\r\n      console.log('已有用户资料，直接返回:', user-profile.email)\r\n      return user-profile\r\n    }\r\n\r\n    // 取消之前的请求\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort()\r\n    }\r\n    \r\n    // 创建新的AbortController\r\n    abortControllerRef.current = new AbortController()\r\n    const { signal } = abortControllerRef.current\r\n    \r\n    let timeoutId: NodeJS.Timeout | null = null\r\n\r\n    try {\r\n      setIsLoading(true)\r\n      \r\n      if (retryCount === 0) {\r\n        setError(null)\r\n      }\r\n      \r\n      console.log(`获取用户资料${retryCount > 0 ? `(重试 ${retryCount}/${MAX_RETRIES})` : ''}...`)\r\n      \r\n      // 设置请求超时 - 10秒，增强容错性\r\n      timeoutId = setTimeout(() => {\r\n        if (abortControllerRef.current) {\r\n          console.log('用户资料请求超时，中止请求')\r\n          abortControllerRef.current.abort()\r\n        }\r\n      }, 10000) // 10秒超时\r\n      \r\n      const response = await fetch('/api/user/profile', {\r\n        signal,\r\n        headers: {\r\n          'Cache-Control': 'no-cache',\r\n          'Pragma': 'no-cache'\r\n        }\r\n      })\r\n      \r\n      if (timeoutId) clearTimeout(timeoutId)\r\n      \r\n      // 添加更详细的响应日志\r\n      console.log('资料请求响应状态:', {\r\n        status: response.status,\r\n        ok: response.ok,\r\n        statusText: response.statusText\r\n      })\r\n      \r\n      if (!response.ok) {\r\n        console.error(`资料请求失败, 状态码: ${response.status}`)\r\n        throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`)\r\n      }\r\n      \r\n      const data: UserProfileResponse = await response.json()\r\n      \r\n      console.log('资料请求返回数据:', {\r\n        success: data.success,\r\n        hasProfile: !!data.profile,\r\n        error: data.error || '无'\r\n      })\r\n      \r\n      if (!data.success) {\r\n        console.error('资料请求返回失败状态:', data.error)\r\n        throw new Error(data.error || '获取用户资料失败')\r\n      }\r\n      \r\n      if (!data.profile) {\r\n        console.error('资料请求未返回用户数据')\r\n        throw new Error('服务器未返回用户资料数据')\r\n      }\r\n      \r\n      // 请求成功，重置连续错误计数\r\n      setConsecutiveErrors(0)\r\n      setIsOfflineMode(false)\r\n      setUserProfile(data.profile)\r\n      // 明确设置加载状态为完成\r\n      setIsLoading(false)\r\n      console.log('用户资料获取成功:', data.profile.email)\r\n      \r\n      if (showToast) {\r\n        toast.success('用户资料已更新')\r\n      }\r\n      \r\n      return data.profile\r\n    } catch (err) {\r\n      if (timeoutId) clearTimeout(timeoutId)\r\n      \r\n      console.error('获取用户资料失败:', err)\r\n      setError(err instanceof Error ? err.message : '无法加载用户资料')\r\n      \r\n      // 增加连续错误计数\r\n      setConsecutiveErrors(prev => {\r\n        const newCount = prev + 1\r\n        console.log(`连续错误计数: ${prev} -> ${newCount}`)\r\n        \r\n        // 如果超过阈值，进入离线模式\r\n        if (newCount >= MAX_ERROR_COUNT) {\r\n          setIsOfflineMode(true)\r\n          console.log(`错误次数(${newCount})超过阈值(${MAX_ERROR_COUNT})，进入离线模式`)\r\n          \r\n          // 准备离线用户资料\r\n          const offlineProfile = {\r\n            ...DEFAULT_OFFLINE_PROFILE,\r\n            email: session?.user?.email || DEFAULT_OFFLINE_PROFILE.email,\r\n            name: session?.user?.name || DEFAULT_OFFLINE_PROFILE.name,\r\n          }\r\n          \r\n          setUserProfile(offlineProfile)\r\n        }\r\n        \r\n        return newCount\r\n      })\r\n      \r\n      // 在重试次数内进行重试\r\n      if (retryCount < MAX_RETRIES) {\r\n        console.log(`${RETRY_DELAY}ms后进行第${retryCount + 1}次重试...`)\r\n        setTimeout(() => {\r\n          fetchUserProfile(showToast, retryCount + 1)\r\n        }, RETRY_DELAY)\r\n      } else {\r\n        setIsLoading(false)\r\n      }\r\n      \r\n      return user-profile\r\n    }\r\n  }, [session, user-profile, isOfflineMode, consecutiveErrors])\r\n\r\n  // 监听会话变更，获取用户资料\r\n  useEffect(() => {\r\n    // 会话变更次数加1\r\n    sessionChangeRef.current += 1\r\n    const currentSessionChange = sessionChangeRef.current\r\n    \r\n    console.log(`会话变化(${currentSessionChange})，重新获取用户资料`)\r\n    \r\n    // 重置离线模式和错误计数\r\n    if (session?.user) {\r\n      setIsOfflineMode(false)\r\n      setConsecutiveErrors(0)\r\n    }\r\n    \r\n    // 延迟获取用户资料，避免在会话初始化过程中频繁请求\r\n    const timeoutId = setTimeout(() => {\r\n      // 确保在会话状态未变更的情况下执行\r\n      if (sessionChangeRef.current === currentSessionChange) {\r\n        fetchUserProfile()\r\n      }\r\n    }, 100)\r\n    \r\n    return () => clearTimeout(timeoutId)\r\n  }, [session, fetchUserProfile])\r\n\r\n  /**\r\n   * 强制刷新用户资料\r\n   */\r\n  const forceRefreshProfile = useCallback(() => {\r\n    return fetchUserProfile(true)\r\n  }, [fetchUserProfile])\r\n\r\n  /**\r\n   * 更新用户资料\r\n   * @param profileData 更新的资料数据\r\n   * @returns 是否更新成功\r\n   */\r\n  const updateUserProfile = useCallback(async (profileData: UserProfileInput) => {\r\n    if (!session?.user) {\r\n      console.error('用户未登录，无法更新资料')\r\n      return false\r\n    }\r\n    \r\n    setIsLoading(true)\r\n    setError(null)\r\n    \r\n    try {\r\n      const response = await fetch('/api/user/profile', {\r\n        method: 'PUT',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(profileData),\r\n      })\r\n      \r\n      const data: UserProfileResponse = await response.json()\r\n      \r\n      if (!response.ok || !data.success) {\r\n        throw new Error(data.error || '更新资料失败')\r\n      }\r\n      \r\n      if (data.profile) {\r\n        setUserProfile(data.profile)\r\n        toast.success('资料更新成功')\r\n        return true\r\n      } else {\r\n        throw new Error('服务器返回的数据无效')\r\n      }\r\n    } catch (error) {\r\n      console.error('更新用户资料失败:', error)\r\n      setError(error instanceof Error ? error.message : '更新资料失败')\r\n      toast.error(error instanceof Error ? error.message : '更新资料失败')\r\n      return false\r\n    } finally {\r\n      setIsLoading(false)\r\n    }\r\n  }, [session])\r\n\r\n  /**\r\n   * 更新用户主题\r\n   * @param theme 主题ID\r\n   * @returns 是否更新成功\r\n   */\r\n  const updateTheme = useCallback(async (theme: string) => {\r\n    return updateUserProfile({ theme })\r\n  }, [updateUserProfile])\r\n\r\n  /**\r\n   * 应用主题\r\n   * @param theme 主题ID\r\n   */\r\n  const applyTheme = useCallback((theme: string = 'default') => {\r\n    try {\r\n      applyThemeService(theme)\r\n      return true\r\n    } catch (error) {\r\n      console.error('应用主题失败:', error)\r\n      return false\r\n    }\r\n  }, [])\r\n\r\n  return {\r\n    user-profile,\r\n    isLoading,\r\n    error,\r\n    isOfflineMode,\r\n    effectiveAvatarUrl,\r\n    fetchUserProfile,\r\n    forceRefreshProfile,\r\n    updateUserProfile,\r\n    updateTheme,\r\n    applyTheme\r\n  }\r\n} "
  },
  {
    "path": "scripts\\fix-imports.js",
    "newContent": "/**\n * 自动修复导入路径脚本\n * 由rename-helper.js自动生成\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { promisify } = require('util');\nconst writeFile = promisify(fs.writeFile);\n\n// 需要修复的文件\nconst filesToFix = [\n  {\n    \"path\": \"app\\\\api\\\\user\\\\avatar\\\\route.ts\",\n    \"newContent\": \"import { NextRequest, NextResponse } from 'next/server';\\r\\nimport { getServerSession } from 'next-auth';\\r\\nimport { prisma } from '@/app/lib/database';\\r\\nimport { authOptions } from '@/app/lib/auth';\\r\\nimport { writeFile, mkdir, unlink } from 'fs/promises';\\r\\nimport { join } from 'path';\\r\\nimport crypto from 'crypto';\\r\\nimport fs from 'fs';\\r\\n\\r\\n// 确保上传目录存在\\r\\nconst ensureUploadDir = async () => {\\r\\n  const uploadDir = join(process.cwd(), 'public', 'uploads', 'avatars');\\r\\n  if (!fs.existsSync(uploadDir)) {\\r\\n    console.log('创建头像上传目录:', uploadDir);\\r\\n    await mkdir(uploadDir, { recursive: true });\\r\\n  }\\r\\n  return uploadDir;\\r\\n};\\r\\n\\r\\n// 获取用户当前头像文件路径\\r\\nconst getUserAvatarPath = async (userId: string) => {\\r\\n  const user = await prisma.user-profile.findUnique({\\r\\n    where: { userId },\\r\\n    select: { avatarUrl: true }\\r\\n  });\\r\\n  \\r\\n  if (!user?.avatarUrl) return null;\\r\\n  \\r\\n  // 从URL提取文件名\\r\\n  const fileName = user.avatarUrl.split('/').pop();\\r\\n  if (!fileName) return null;\\r\\n  \\r\\n  return join(process.cwd(), 'public', 'uploads', 'avatars', fileName);\\r\\n};\\r\\n\\r\\n// 获取用户当前头像\\r\\nexport async function GET() {\\r\\n  try {\\r\\n    const session = await getServerSession(authOptions);\\r\\n    \\r\\n    if (!session?.user?.email) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未授权访问' },\\r\\n        { status: 401 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    const user = await prisma.user.findUnique({\\r\\n      where: { email: session.user.email },\\r\\n      include: { profile: true }\\r\\n    });\\r\\n\\r\\n    if (!user) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '用户不存在' },\\r\\n        { status: 404 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return NextResponse.json({\\r\\n      success: true,\\r\\n      avatarUrl: user.profile?.avatarUrl || session.user.image || null\\r\\n    });\\r\\n  } catch (error) {\\r\\n    console.error('获取头像失败:', error);\\r\\n    return NextResponse.json(\\r\\n      { success: false, error: '获取头像失败' },\\r\\n      { status: 500 }\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n// 上传用户头像\\r\\nexport async function POST(request: NextRequest) {\\r\\n  try {\\r\\n    const session = await getServerSession(authOptions);\\r\\n    \\r\\n    if (!session?.user?.email) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未授权访问' },\\r\\n        { status: 401 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 获取用户ID\\r\\n    const user = await prisma.user.findUnique({\\r\\n      where: { email: session.user.email },\\r\\n      select: { id: true }\\r\\n    });\\r\\n\\r\\n    if (!user) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '用户不存在' },\\r\\n        { status: 404 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 处理表单数据\\r\\n    const formData = await request.formData();\\r\\n    const file = formData.get('avatar') as File;\\r\\n    \\r\\n    if (!file) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未提供头像文件' },\\r\\n        { status: 400 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 验证文件类型\\r\\n    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\\r\\n    if (!validTypes.includes(file.type)) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '不支持的文件类型，请上传JPEG、PNG、GIF或WEBP图片' },\\r\\n        { status: 400 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 验证文件大小（最大2MB）\\r\\n    const maxSize = 2 * 1024 * 1024; // 2MB\\r\\n    if (file.size > maxSize) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '文件大小超过限制（最大2MB）' },\\r\\n        { status: 400 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 生成唯一文件名\\r\\n    const fileExt = file.name.split('.').pop() || 'jpg';\\r\\n    const fileName = `${crypto.randomUUID()}.${fileExt}`;\\r\\n    \\r\\n    // 确保上传目录存在\\r\\n    const uploadDir = await ensureUploadDir();\\r\\n    const filePath = join(uploadDir, fileName);\\r\\n    const fileUrl = `/uploads/avatars/${fileName}`;\\r\\n\\r\\n    console.log('准备写入文件:', filePath);\\r\\n    console.log('对应的URL:', fileUrl);\\r\\n\\r\\n    // 读取文件内容\\r\\n    const buffer = Buffer.from(await file.arrayBuffer());\\r\\n    \\r\\n    // 删除旧头像文件\\r\\n    try {\\r\\n      const oldAvatarPath = await getUserAvatarPath(user.id);\\r\\n      if (oldAvatarPath && fs.existsSync(oldAvatarPath)) {\\r\\n        console.log('删除旧头像文件:', oldAvatarPath);\\r\\n        await unlink(oldAvatarPath);\\r\\n      }\\r\\n    } catch (deleteError) {\\r\\n      console.error('删除旧头像文件失败', deleteError);\\r\\n      // 继续执行，不中断上传流程\\r\\n    }\\r\\n    \\r\\n    // 写入文件\\r\\n    try {\\r\\n      await writeFile(filePath, buffer);\\r\\n      console.log('文件写入成功:', filePath);\\r\\n    } catch (writeError) {\\r\\n      console.error('文件写入失败:', writeError);\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '文件保存失败，请重试' },\\r\\n        { status: 500 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    // 更新用户资料\\r\\n    await prisma.user-profile.upsert({\\r\\n      where: { userId: user.id },\\r\\n      update: { avatarUrl: fileUrl },\\r\\n      create: {\\r\\n        userId: user.id,\\r\\n        avatarUrl: fileUrl,\\r\\n        displayName: session.user.name || ''\\r\\n      }\\r\\n    });\\r\\n\\r\\n    return NextResponse.json({ \\r\\n      success: true,\\r\\n      avatarUrl: fileUrl\\r\\n    });\\r\\n  } catch (error) {\\r\\n    console.error('头像上传失败:', error);\\r\\n    return NextResponse.json(\\r\\n      { success: false, error: '头像上传失败' },\\r\\n      { status: 500 }\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n// 删除自定义头像，恢复默认头像\\r\\nexport async function DELETE() {\\r\\n  try {\\r\\n    const session = await getServerSession(authOptions);\\r\\n    \\r\\n    if (!session?.user?.email) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未授权访问' },\\r\\n        { status: 401 }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    const user = await prisma.user.findUnique({\\r\\n      where: { email: session.user.email },\\r\\n      select: { id: true }\\r\\n    });\\r\\n\\r\\n    if (!user) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '用户不存在' },\\r\\n        { status: 404 }\\r\\n      );\\r\\n    }\\r\\n    \\r\\n    // 删除头像文件\\r\\n    try {\\r\\n      const avatarPath = await getUserAvatarPath(user.id);\\r\\n      if (avatarPath && fs.existsSync(avatarPath)) {\\r\\n        console.log('删除头像文件:', avatarPath);\\r\\n        await unlink(avatarPath);\\r\\n      }\\r\\n    } catch (deleteError) {\\r\\n      console.error('删除头像文件失败:', deleteError);\\r\\n      // 继续执行，不中断删除流程\\r\\n    }\\r\\n\\r\\n    // 更新用户资料，删除自定义头像\\r\\n    await prisma.user-profile.update({\\r\\n      where: { userId: user.id },\\r\\n      data: { avatarUrl: null }\\r\\n    });\\r\\n\\r\\n    return NextResponse.json({\\r\\n      success: true,\\r\\n      avatarUrl: session.user.image || null\\r\\n    });\\r\\n  } catch (error) {\\r\\n    console.error('删除头像失败:', error);\\r\\n    return NextResponse.json(\\r\\n      { success: false, error: '删除头像失败' },\\r\\n      { status: 500 }\\r\\n    );\\r\\n  }\\r\\n} \\r\\n\"\n  },\n  {\n    \"path\": \"app\\\\api\\\\user\\\\profile\\\\route.ts\",\n    \"newContent\": \"import { NextRequest, NextResponse } from 'next/server'\\r\\nimport { getServerSession } from 'next-auth'\\r\\nimport { prisma } from '@/app/lib/database'\\r\\n\\r\\n// 获取当前认证配置\\r\\nimport { authOptions } from '@/app/lib/auth'\\r\\n\\r\\n// 从前端获取的用户资料接口\\r\\ninterface UserProfileInput {\\r\\n  displayName?: string\\r\\n  bio?: string\\r\\n  location?: string\\r\\n  website?: string\\r\\n  company?: string\\r\\n  avatarUrl?: string\\r\\n  theme?: string\\r\\n}\\r\\n\\r\\n// 返回给前端的用户资料接口\\r\\ninterface UserProfileResponse {\\r\\n  id: string\\r\\n  email: string\\r\\n  name: string | null\\r\\n  avatarUrl?: string | null\\r\\n  theme?: string | null\\r\\n  bio?: string | null\\r\\n  location?: string | null\\r\\n  website?: string | null\\r\\n  company?: string | null\\r\\n  storageUsed: number\\r\\n  storageLimit: number\\r\\n  createdAt: string\\r\\n  updatedAt: string\\r\\n}\\r\\n\\r\\n// 获取用户资料\\r\\nexport async function GET() {\\r\\n  console.log('GET /api/user/profile 请求开始')\\r\\n  try {\\r\\n    const session = await getServerSession(authOptions)\\r\\n    console.log('获取到用户会话:', session ? '成功' : '失败')\\r\\n    \\r\\n    if (!session?.user?.email) {\\r\\n      console.log('未授权访问: 没有找到用户邮箱')\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未授权访问' },\\r\\n        { status: 401 }\\r\\n      )\\r\\n    }\\r\\n\\r\\n    console.log('查询用户信息，邮箱:', session.user.email)\\r\\n    // 查询用户，并包含用户资料\\r\\n    const user = await prisma.user.findUnique({\\r\\n      where: {\\r\\n        email: session.user.email\\r\\n      },\\r\\n      include: {\\r\\n        profile: true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (!user) {\\r\\n      console.log('用户不存在:', session.user.email)\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '用户不存在' },\\r\\n        { status: 404 }\\r\\n      )\\r\\n    }\\r\\n\\r\\n    // 构建用户资料响应\\r\\n    const user-profile: UserProfileResponse = {\\r\\n      id: user.id,\\r\\n      email: user.email,\\r\\n      name: user.name,\\r\\n      avatarUrl: user.profile?.avatarUrl || null, \\r\\n      theme: user.profile?.theme || null,\\r\\n      bio: user.profile?.bio || null,\\r\\n      location: user.profile?.location || null,\\r\\n      website: user.profile?.website || null,\\r\\n      company: user.profile?.company || null,\\r\\n      storageUsed: user.storageUsed,\\r\\n      storageLimit: user.storageLimit,\\r\\n      createdAt: user.createdAt.toISOString(),\\r\\n      updatedAt: user.updatedAt.toISOString()\\r\\n    }\\r\\n\\r\\n    console.log('成功获取用户信息:', user.id)\\r\\n    return NextResponse.json({\\r\\n      success: true,\\r\\n      profile: user-profile\\r\\n    })\\r\\n  } catch (error) {\\r\\n    console.error('获取用户信息失败:', error)\\r\\n    return NextResponse.json(\\r\\n      { success: false, error: '获取用户信息失败' },\\r\\n      { status: 500 }\\r\\n    )\\r\\n  }\\r\\n}\\r\\n\\r\\n// 更新用户资料\\r\\nexport async function PUT(request: NextRequest) {\\r\\n  console.log('PUT /api/user/profile 请求开始')\\r\\n  try {\\r\\n    const session = await getServerSession(authOptions)\\r\\n    console.log('获取到用户会话:', session ? '成功' : '失败')\\r\\n    \\r\\n    if (!session?.user?.email) {\\r\\n      console.log('未授权访问: 没有找到用户邮箱')\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '未授权访问' },\\r\\n        { status: 401 }\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const data = await request.json() as UserProfileInput\\r\\n    console.log('接收到的数据:', data)\\r\\n\\r\\n    // 获取用户\\r\\n    const user = await prisma.user.findUnique({\\r\\n      where: {\\r\\n        email: session.user.email\\r\\n      },\\r\\n      include: {\\r\\n        profile: true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (!user) {\\r\\n      return NextResponse.json(\\r\\n        { success: false, error: '用户不存在' },\\r\\n        { status: 404 }\\r\\n      )\\r\\n    }\\r\\n\\r\\n    // 更新用户名称\\r\\n    const updatedUser = await prisma.user.update({\\r\\n      where: {\\r\\n        id: user.id\\r\\n      },\\r\\n      data: {\\r\\n        name: data.displayName || user.name\\r\\n      }\\r\\n    })\\r\\n\\r\\n    // 更新或创建用户资料\\r\\n    console.log('开始更新用户资料，用户ID:', user.id);\\r\\n    console.log('当前用户Profile数据:', user.profile || '无');\\r\\n    \\r\\n    const profile = await prisma.user-profile.upsert({\\r\\n      where: {\\r\\n        userId: user.id\\r\\n      },\\r\\n      update: {\\r\\n        avatarUrl: data.avatarUrl !== undefined ? data.avatarUrl : user.profile?.avatarUrl,\\r\\n        theme: data.theme !== undefined ? data.theme : user.profile?.theme,\\r\\n        displayName: data.displayName || user.profile?.displayName || user.name,\\r\\n        bio: data.bio !== undefined ? data.bio : user.profile?.bio,\\r\\n        location: data.location !== undefined ? data.location : user.profile?.location,\\r\\n        website: data.website !== undefined ? data.website : user.profile?.website,\\r\\n        company: data.company !== undefined ? data.company : user.profile?.company\\r\\n      },\\r\\n      create: {\\r\\n        userId: user.id,\\r\\n        displayName: data.displayName || user.name || '',\\r\\n        avatarUrl: data.avatarUrl,\\r\\n        theme: data.theme,\\r\\n        bio: data.bio || '',\\r\\n        location: data.location || '',\\r\\n        website: data.website || '',\\r\\n        company: data.company || ''\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    console.log('用户资料更新/创建成功:', profile);\\r\\n\\r\\n    // 构建用户资料响应\\r\\n    const user-profile: UserProfileResponse = {\\r\\n      id: updatedUser.id,\\r\\n      email: updatedUser.email,\\r\\n      name: updatedUser.name,\\r\\n      avatarUrl: profile.avatarUrl,\\r\\n      theme: profile.theme,\\r\\n      bio: profile.bio,\\r\\n      location: profile.location,\\r\\n      website: profile.website,\\r\\n      company: profile.company,\\r\\n      storageUsed: updatedUser.storageUsed,\\r\\n      storageLimit: updatedUser.storageLimit,\\r\\n      createdAt: updatedUser.createdAt.toISOString(),\\r\\n      updatedAt: updatedUser.updatedAt.toISOString()\\r\\n    }\\r\\n\\r\\n    console.log('成功更新用户信息:', user.id)\\r\\n    return NextResponse.json({\\r\\n      success: true,\\r\\n      profile: user-profile\\r\\n    })\\r\\n  } catch (error) {\\r\\n    console.error('更新用户信息失败:', error)\\r\\n    return NextResponse.json(\\r\\n      { success: false, error: '更新用户信息失败' },\\r\\n      { status: 500 }\\r\\n    )\\r\\n  }\\r\\n} \"\n  },\n  {\n    \"path\": \"app\\\\api\\\\user\\\\theme\\\\route.ts\",\n    \"newContent\": \"import { NextRequest, NextResponse } from 'next/server';\\nimport { getServerSession } from 'next-auth';\\nimport { prisma } from '@/app/lib/database';\\nimport { authOptions } from '@/app/lib/auth';\\n\\n// 获取用户当前主题\\nexport async function GET() {\\n  try {\\n    const session = await getServerSession(authOptions);\\n    \\n    if (!session?.user?.email) {\\n      return NextResponse.json(\\n        { success: false, error: '未授权访问' },\\n        { status: 401 }\\n      );\\n    }\\n\\n    const user = await prisma.user.findUnique({\\n      where: { email: session.user.email },\\n      include: { profile: true }\\n    });\\n\\n    if (!user) {\\n      return NextResponse.json(\\n        { success: false, error: '用户不存在' },\\n        { status: 404 }\\n      );\\n    }\\n\\n    return NextResponse.json({\\n      success: true,\\n      theme: user.profile?.theme || 'default'\\n    });\\n  } catch (error) {\\n    console.error('获取主题失败:', error);\\n    return NextResponse.json(\\n      { success: false, error: '获取主题失败' },\\n      { status: 500 }\\n    );\\n  }\\n}\\n\\n// 更新用户主题\\nexport async function PUT(request: NextRequest) {\\n  try {\\n    const session = await getServerSession(authOptions);\\n    \\n    if (!session?.user?.email) {\\n      return NextResponse.json(\\n        { success: false, error: '未授权访问' },\\n        { status: 401 }\\n      );\\n    }\\n\\n    // 获取请求体\\n    const data = await request.json();\\n    const { theme } = data;\\n    \\n    if (!theme) {\\n      return NextResponse.json(\\n        { success: false, error: '未提供主题参数' },\\n        { status: 400 }\\n      );\\n    }\\n\\n    // 验证主题是否有效\\n    const validThemes = [\\n      // 基础色彩主题\\n      'default', 'violet', 'emerald', 'amber', 'rose',\\n      // 渐变主题\\n      'ocean', 'sunset', 'forest', 'galaxy', \\n      // 季节主题\\n      'spring', 'summer', 'autumn', 'winter',\\n      // 柔和主题 - 浅色系列\\n      'pastel_pink', 'pastel_blue', 'pastel_lavender', 'pastel_mint', \\n      'pastel_peach', 'pastel_lemon', 'pastel_teal'\\n    ];\\n    if (!validThemes.includes(theme)) {\\n      return NextResponse.json(\\n        { success: false, error: '无效的主题' },\\n        { status: 400 }\\n      );\\n    }\\n\\n    // 获取用户ID\\n    const user = await prisma.user.findUnique({\\n      where: { email: session.user.email },\\n      select: { id: true }\\n    });\\n\\n    if (!user) {\\n      return NextResponse.json(\\n        { success: false, error: '用户不存在' },\\n        { status: 404 }\\n      );\\n    }\\n\\n    // 更新用户主题\\n    await prisma.user-profile.upsert({\\n      where: { userId: user.id },\\n      update: { theme },\\n      create: {\\n        userId: user.id,\\n        displayName: session.user.name || '',\\n        theme\\n      }\\n    });\\n\\n    return NextResponse.json({\\n      success: true,\\n      theme\\n    });\\n  } catch (error) {\\n    console.error('更新主题失败:', error);\\n    return NextResponse.json(\\n      { success: false, error: '更新主题失败' },\\n      { status: 500 }\\n    );\\n  }\\n} \\n\"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\actionBar\\\\TopActionBar\\\\TopActionBar.tsx\",\n    \"newContent\": \"import React from 'react';\\r\\nimport { \\r\\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \\r\\n} from 'lucide-react';\\r\\nimport styles from '@/app/file-management/styles/shared.module.css';\\r\\nimport { SortDropdown } from '@/app/components/features/file-management/actionBar/SortDropdown';\\r\\nimport { UploadButton } from '@/app/components/features/file-management/upload/UploadButton';\\r\\nimport { FileSortInterface } from '@/app/types';\\r\\n\\r\\ninterface TopActionBarProps {\\r\\n  selectedFiles: string[];\\r\\n  onClearSelection: () => void;\\r\\n  onDownload: () => void;\\r\\n  onRename: () => void;\\r\\n  onMove: () => void;\\r\\n  onDelete: () => void;\\r\\n  onClearFilter: () => void;\\r\\n  onCreateFolder: () => void;\\r\\n  selectedFileType: string | null;\\r\\n  showSearchView: boolean;\\r\\n  isInRootFolder: boolean;\\r\\n  sortOrder: FileSortInterface;\\r\\n  setSortOrder: (order: FileSortInterface) => void;\\r\\n  showUploadDropdown: boolean;\\r\\n  setShowUploadDropdown: (show: boolean) => void;\\r\\n  setIsUploadModalOpen: (open: boolean) => void;\\r\\n  setIsFolderUploadModalOpen: (open: boolean) => void;\\r\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\r\\n}\\r\\n\\r\\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\\r\\n  selectedFiles,\\r\\n  onClearSelection,\\r\\n  onDownload,\\r\\n  onRename,\\r\\n  onMove,\\r\\n  onDelete,\\r\\n  onClearFilter,\\r\\n  onCreateFolder,\\r\\n  selectedFileType,\\r\\n  showSearchView,\\r\\n  isInRootFolder,\\r\\n  sortOrder,\\r\\n  setSortOrder,\\r\\n  showUploadDropdown,\\r\\n  setShowUploadDropdown,\\r\\n  setIsUploadModalOpen,\\r\\n  setIsFolderUploadModalOpen,\\r\\n  uploadDropdownRef\\r\\n}) => {\\r\\n  return (\\r\\n    <div className={styles.topBar}>\\r\\n      <div className={styles.buttonGroup}>\\r\\n        {selectedFiles.length > 0 ? (\\r\\n          <>\\r\\n            <button className={styles.topButton} onClick={onClearSelection}>\\r\\n              <X className=\\\"w-4 h-4\\\" />\\r\\n              取消选择\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onDownload}>\\r\\n              <Download className=\\\"w-4 h-4\\\" />\\r\\n              下载\\r\\n            </button>\\r\\n            <button \\r\\n              className={styles.topButton}\\r\\n              onClick={onRename}\\r\\n            >\\r\\n              <Edit className=\\\"w-4 h-4\\\" />\\r\\n              重命名\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onMove}>\\r\\n              <Move className=\\\"w-4 h-4\\\" />\\r\\n              移动\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onDelete}>\\r\\n              <Trash2 className=\\\"w-4 h-4\\\" />\\r\\n              删除\\r\\n            </button>\\r\\n          </>\\r\\n        ) : (\\r\\n          <>\\r\\n            <button \\r\\n              className={styles.topButton}\\r\\n              onClick={onClearFilter}\\r\\n              disabled={isInRootFolder}\\r\\n            >\\r\\n              <span>📁</span>\\r\\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\\r\\n            </button>\\r\\n\\r\\n            {/* 添加当前过滤状态指示器 */}\\r\\n            {selectedFileType && (\\r\\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\\r\\n                {(() => {\\r\\n                  switch(selectedFileType) {\\r\\n                    case 'image': return <ImageIcon className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'document': return <FileText className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'video': return <Video className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'audio': return <Music className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'other': return <File className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    default: return null;\\r\\n                  }\\r\\n                })()}\\r\\n                当前浏览：\\r\\n                {selectedFileType === 'image' && '仅图片'}\\r\\n                {selectedFileType === 'document' && '仅文档'}\\r\\n                {selectedFileType === 'video' && '仅视频'}\\r\\n                {selectedFileType === 'audio' && '仅音频'}\\r\\n                {selectedFileType === 'other' && '其他文件'}\\r\\n              </div>\\r\\n            )}\\r\\n\\r\\n            {/* 排序下拉菜单 */}\\r\\n            <SortDropdown \\r\\n              sortOrder={sortOrder}\\r\\n              onSortChange={setSortOrder}\\r\\n            />\\r\\n            \\r\\n            {/* 上传按钮 */}\\r\\n            <UploadButton \\r\\n              showDropdown={showUploadDropdown}\\r\\n              setShowDropdown={setShowUploadDropdown}\\r\\n              setIsModalOpen={setIsUploadModalOpen}\\r\\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\\r\\n              uploadDropdownRef={uploadDropdownRef}\\r\\n            />\\r\\n            \\r\\n            <button \\r\\n              className={styles.folderButton} \\r\\n              onClick={onCreateFolder}\\r\\n            >\\r\\n              <FolderUp className=\\\"w-4 h-4 mr-2\\\" />\\r\\n              新建文件夹\\r\\n            </button>\\r\\n          </>\\r\\n        )}\\r\\n      </div>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default TopActionBar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\MiniSidebar.tsx\",\n    \"newContent\": \"/**\\r\\n * @deprecated 此组件已迁移到新的组件架构中。\\r\\n * 请使用 @/app/components/features/file-management/navigation/MiniSidebar 组件。\\r\\n */\\r\\n\\r\\nimport React from 'react';\\r\\nimport Image from 'next/image';\\r\\nimport { Home, LogOut, Palette } from 'lucide-react';\\r\\nimport styles from '../styles/shared.module.css';\\r\\n\\r\\ninterface MiniSidebarProps {\\r\\n  avatarUrl: string | null;\\r\\n  userName: string | null;\\r\\n  userEmail: string | null;\\r\\n  onHomeClick: () => void;\\r\\n  onLogoutClick: () => void;\\r\\n  onAvatarClick: () => void;\\r\\n  currentTheme?: string | null;\\r\\n  onThemeClick: () => void;\\r\\n}\\r\\n\\r\\nconst MiniSidebar: React.FC<MiniSidebarProps> = ({\\r\\n  avatarUrl,\\r\\n  userName,\\r\\n  userEmail,\\r\\n  onHomeClick,\\r\\n  onLogoutClick,\\r\\n  onAvatarClick,\\r\\n  currentTheme = 'default',\\r\\n  onThemeClick\\r\\n}) => {\\r\\n  return (\\r\\n    <div className={styles.miniSidebar}>\\r\\n      <div className={styles.patternOverlay}></div>\\r\\n      <div className={styles.avatarContainer}>\\r\\n        <button \\r\\n          className={styles.miniSidebarButton}\\r\\n          onClick={onAvatarClick}\\r\\n        >\\r\\n          {avatarUrl ? (\\r\\n            <Image\\r\\n              src={`${avatarUrl}?t=${Date.now()}`}\\r\\n              alt=\\\"用户头像\\\"\\r\\n              width={38}\\r\\n              height={38}\\r\\n              className=\\\"rounded-full ring-1 ring-white/50 transition-all duration-300 hover:ring-2\\\"\\r\\n            />\\r\\n          ) : (\\r\\n            <div \\r\\n              className={styles.avatarPlaceholder}\\r\\n              style={{ width: '38px', height: '38px', fontSize: '16px' }}\\r\\n            >\\r\\n              {userName?.[0]?.toUpperCase() || userEmail?.[0]?.toUpperCase() || '?'}\\r\\n            </div>\\r\\n          )}\\r\\n        </button>\\r\\n      </div>\\r\\n      <div className={styles.miniSidebarDivider}></div>\\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onHomeClick}\\r\\n      >\\r\\n        <Home className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n      \\r\\n      {/* 主题选择按钮 */}\\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onThemeClick}\\r\\n        title=\\\"主题设置\\\"\\r\\n      >\\r\\n        <Palette className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n      \\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onLogoutClick}\\r\\n      >\\r\\n        <LogOut className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default MiniSidebar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\NewFolderForm.tsx\",\n    \"newContent\": \"/**\\r\\n * @deprecated 此组件已迁移到新的组件架构中。\\r\\n * 请使用 @/app/components/features/file-management/folderManagement/NewFolderForm 组件。\\r\\n */\\r\\n\\r\\nimport React, { useRef, useState, useEffect } from 'react';\\r\\nimport { Folder, AlertCircle } from 'lucide-react';\\r\\nimport styles from '../styles/shared.module.css';\\r\\n\\r\\ninterface NewFolderFormProps {\\r\\n  folderName: string;\\r\\n  setFolderName: (name: string) => void;\\r\\n  folderTags: string[];\\r\\n  setFolderTags: (tags: string[]) => void;\\r\\n  onCreateFolder: () => void;\\r\\n  onCancel: () => void;\\r\\n}\\r\\n\\r\\nconst NewFolderForm: React.FC<NewFolderFormProps> = ({\\r\\n  folderName,\\r\\n  setFolderName,\\r\\n  folderTags,\\r\\n  setFolderTags,\\r\\n  onCreateFolder,\\r\\n  onCancel\\r\\n}) => {\\r\\n  const [newTag, setNewTag] = useState('');\\r\\n  const [nameError, setNameError] = useState<string | null>(null);\\r\\n  const inputRef = useRef<HTMLInputElement>(null);\\r\\n\\r\\n  // 检查文件夹名称是否有效\\r\\n  useEffect(() => {\\r\\n    const trimmedName = folderName.trim();\\r\\n    \\r\\n    if (trimmedName === '') {\\r\\n      setNameError(null); // 空名称不显示错误，但创建按钮会处理\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // 检查特殊字符\\r\\n    const invalidChars = /[\\\\/\\\\\\\\:*?\\\"<>|]/;\\r\\n    if (invalidChars.test(trimmedName)) {\\r\\n      setNameError('文件夹名称不能包含下列字符: / \\\\\\\\ : * ? \\\" < > |');\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    setNameError(null);\\r\\n  }, [folderName]);\\r\\n\\r\\n  // 处理回车键创建文件夹\\r\\n  const handleKeyDown = (e: React.KeyboardEvent) => {\\r\\n    if (e.key === 'Enter' && !nameError && folderName.trim()) {\\r\\n      onCreateFolder();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <div className={`${styles.newFolderRow} p-4 border border-gray-200 rounded-lg bg-white shadow-sm mb-4`}>\\r\\n      <div className={`${styles.newFolderForm} flex flex-col space-y-4`}>\\r\\n        <div className={`flex items-center`}>\\r\\n          <Folder className=\\\"w-6 h-6 text-blue-500 flex-shrink-0 mr-3\\\" />\\r\\n          <div className={`${styles.newFolderNameContainer} flex-grow relative`}>\\r\\n            <input\\r\\n              type=\\\"text\\\"\\r\\n              ref={inputRef}\\r\\n              className={`${styles.newFolderInput} h-10 px-3 rounded-md border ${nameError ? 'border-red-500' : 'border-gray-300'} w-full text-base`}\\r\\n              value={folderName}\\r\\n              onChange={(e) => setFolderName(e.target.value)}\\r\\n              placeholder=\\\"新文件夹名称\\\"\\r\\n              autoFocus\\r\\n              onKeyDown={handleKeyDown}\\r\\n            />\\r\\n            {nameError && (\\r\\n              <div className=\\\"text-red-500 text-xs mt-1 flex items-center\\\">\\r\\n                <AlertCircle className=\\\"w-3 h-3 mr-1\\\" />\\r\\n                <span>{nameError}</span>\\r\\n              </div>\\r\\n            )}\\r\\n            {!nameError && (\\r\\n              <div className=\\\"text-gray-500 text-xs mt-1\\\">\\r\\n                相同目录下不能存在同名文件夹\\r\\n              </div>\\r\\n            )}\\r\\n          </div>\\r\\n        </div>\\r\\n        \\r\\n        <div className={`${styles.newFolderTagsContainer} ml-9`}>\\r\\n          <label className=\\\"block text-sm font-medium text-gray-700 mb-1\\\">添加标签</label>\\r\\n          <div className={`${styles.tagsWrapper} h-10 flex items-center flex-wrap gap-2 border border-gray-300 rounded-md px-3 py-1 overflow-y-auto`}>\\r\\n            {folderTags.map((tag, index) => (\\r\\n              <div key={index} className={`${styles.tagItem} h-7 flex items-center bg-blue-100 text-blue-800 px-2 rounded-md`}>\\r\\n                <span className=\\\"text-sm\\\">{tag}</span>\\r\\n                <button\\r\\n                  className={`${styles.removeTagButton} ml-1 text-blue-600 hover:text-blue-800 w-5 h-5 flex items-center justify-center rounded-full hover:bg-blue-200`}\\r\\n                  onClick={() => {\\r\\n                    const updatedTags = [...folderTags];\\r\\n                    updatedTags.splice(index, 1);\\r\\n                    setFolderTags(updatedTags);\\r\\n                  }}\\r\\n                >\\r\\n                  ×\\r\\n                </button>\\r\\n              </div>\\r\\n            ))}\\r\\n            <input\\r\\n              type=\\\"text\\\"\\r\\n              className={`${styles.tagInput} flex-grow h-7 border-0 outline-none text-sm bg-transparent`}\\r\\n              value={newTag}\\r\\n              onChange={(e) => setNewTag(e.target.value)}\\r\\n              onKeyDown={(e) => {\\r\\n                if (e.key === 'Enter' && newTag.trim()) {\\r\\n                  setFolderTags([...folderTags, newTag.trim()]);\\r\\n                  setNewTag('');\\r\\n                  e.preventDefault();\\r\\n                }\\r\\n              }}\\r\\n              placeholder=\\\"添加标签...\\\"\\r\\n            />\\r\\n          </div>\\r\\n        </div>\\r\\n        \\r\\n        <div className={`${styles.newFolderActions} flex items-center gap-3 ml-9`}>\\r\\n          <button \\r\\n            className={`${styles.confirmButton} h-10 px-4 ${nameError || !folderName.trim() ? 'bg-blue-300 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white rounded-md flex items-center justify-center`}\\r\\n            onClick={onCreateFolder}\\r\\n            disabled={!!nameError || !folderName.trim()}\\r\\n          >\\r\\n            创建\\r\\n          </button>\\r\\n          <button \\r\\n            className={`${styles.cancelButton} h-10 px-4 bg-gray-100 hover:bg-gray-200 text-gray-800 rounded-md flex items-center justify-center border border-gray-300`}\\r\\n            onClick={onCancel}\\r\\n          >\\r\\n            取消\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default NewFolderForm; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\RenameModal\\\\index.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/fileOperations/RenameModal 组件。\\n */\\n\\nimport React, { useState, useEffect, useRef } from 'react';\\nimport styles from '@/app/shared/themes/components/renameModal.module.css';\\nimport { CloseOutlined, TagOutlined, PlusOutlined } from '@ant-design/icons';\\n\\ninterface RenameModalProps {\\n  isOpen: boolean;\\n  onClose: () => void;\\n  onRename: (newName: string, tags?: string[]) => void;\\n  initialName: string;\\n  initialTags?: string[];\\n  fileType: 'file' | 'folder';\\n}\\n\\nconst RenameModal: React.FC<RenameModalProps> = ({\\n  isOpen,\\n  onClose,\\n  onRename,\\n  initialName,\\n  initialTags = [],\\n  fileType\\n}) => {\\n  const [newName, setNewName] = useState(initialName);\\n  const [tags, setTags] = useState<string[]>(initialTags);\\n  const [tagInput, setTagInput] = useState('');\\n  \\n  const inputRef = useRef<HTMLInputElement>(null);\\n  const tagInputRef = useRef<HTMLInputElement>(null);\\n  const modalRef = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    setNewName(initialName);\\n    // 确保初始标签不包含重复项\\n    setTags(Array.from(new Set(initialTags)));\\n  }, [initialName, initialTags]);\\n\\n  useEffect(() => {\\n    if (isOpen && inputRef.current) {\\n      // 自动聚焦输入框并选中文件名（不包括扩展名）\\n      inputRef.current.focus();\\n      \\n      const extension = fileType === 'file' ? initialName.lastIndexOf('.') : -1;\\n      if (extension !== -1) {\\n        inputRef.current.setSelectionRange(0, extension);\\n      } else {\\n        inputRef.current.select();\\n      }\\n    }\\n  }, [isOpen, initialName, fileType]);\\n\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {\\n        onClose();\\n      }\\n    };\\n\\n    if (isOpen) {\\n      document.addEventListener('mousedown', handleClickOutside);\\n    }\\n    \\n    return () => {\\n      document.removeEventListener('mousedown', handleClickOutside);\\n    };\\n  }, [isOpen, onClose]);\\n\\n  const handleSubmit = (e: React.FormEvent) => {\\n    e.preventDefault();\\n    // 首先确保新名称是有效的非空字符串\\n    if (newName && typeof newName === 'string' && newName.trim() && \\n        (newName !== initialName || JSON.stringify(tags) !== JSON.stringify(initialTags))) {\\n      onRename(newName, tags);\\n    } else if (!newName || !newName.trim()) {\\n      // 如果名称为空，显示错误信息但不关闭模态框\\n      return;\\n    }\\n    onClose();\\n  };\\n\\n  const handleAddTag = () => {\\n    if (!tagInput.trim()) return;\\n    \\n    // 避免添加重复标签\\n    if (!tags.includes(tagInput.trim())) {\\n      setTags([...tags, tagInput.trim()]);\\n    }\\n    \\n    setTagInput('');\\n    \\n    // 添加后自动聚焦回标签输入框\\n    setTimeout(() => {\\n      if (tagInputRef.current) {\\n        tagInputRef.current.focus();\\n      }\\n    }, 0);\\n  };\\n\\n  const handleRemoveTag = (tagToRemove: string) => {\\n    setTags(tags.filter(tag => tag !== tagToRemove));\\n  };\\n\\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      handleAddTag();\\n    }\\n  };\\n\\n  if (!isOpen) return null;\\n\\n  return (\\n    <div className={styles['modal-overlay']}>\\n      <div ref={modalRef} className={`${styles['modal-content']} ${styles['rename-modal']}`}>\\n        <div className={styles['modal-header']}>\\n          <h3 className={styles['modal-title']}>\\n            {fileType === 'folder' ? '重命名文件夹' : '重命名文件'}\\n          </h3>\\n          <button \\n            className={styles['modal-close']} \\n            onClick={onClose}\\n            aria-label=\\\"关闭\\\"\\n          >\\n            <CloseOutlined />\\n          </button>\\n        </div>\\n        \\n        <form className={styles['rename-form']} onSubmit={handleSubmit}>\\n          <div className={styles['form-group']}>\\n            <label className={styles['form-label']}>名称</label>\\n            <input\\n              ref={inputRef}\\n              type=\\\"text\\\"\\n              className={styles['rename-input']}\\n              value={newName}\\n              onChange={(e) => setNewName(e.target.value)}\\n              placeholder=\\\"输入新名称\\\"\\n              autoFocus\\n            />\\n          </div>\\n          \\n          <div className={styles['form-group']}>\\n            <label className={styles['form-label']}>标签</label>\\n            <div className={styles['tags-container']}>\\n              {tags.map((tag, index) => (\\n                <div key={index} className={styles['tag']}>\\n                  <span>{tag}</span>\\n                  <button \\n                    type=\\\"button\\\"\\n                    className={styles['tag-remove']}\\n                    onClick={() => handleRemoveTag(tag)}\\n                  >\\n                    &times;\\n                  </button>\\n                </div>\\n              ))}\\n            </div>\\n            <div className={styles['tag-input-container']}>\\n              <TagOutlined className={styles['tag-icon']} />\\n              <input\\n                ref={tagInputRef}\\n                type=\\\"text\\\"\\n                className={styles['tag-input']}\\n                value={tagInput}\\n                onChange={(e) => setTagInput(e.target.value)}\\n                onKeyDown={handleTagInputKeyDown}\\n                placeholder=\\\"输入标签，按回车添加\\\"\\n              />\\n              <button\\n                type=\\\"button\\\"\\n                className={styles['tag-add-button']}\\n                onClick={handleAddTag}\\n                disabled={!tagInput.trim()}\\n              >\\n                <PlusOutlined />\\n              </button>\\n            </div>\\n          </div>\\n\\n          <div className={styles['modal-footer']}>\\n            <button \\n              type=\\\"button\\\" \\n              className={`${styles['modal-button']} ${styles.cancel}`}\\n              onClick={onClose}\\n            >\\n              取消\\n            </button>\\n            <button \\n              type=\\\"submit\\\" \\n              className={`${styles['modal-button']} ${styles.confirm}`}\\n              disabled={!newName.trim() || (newName === initialName && JSON.stringify(tags) === JSON.stringify(initialTags))}\\n            >\\n              确认\\n            </button>\\n          </div>\\n        </form>\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default RenameModal; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Breadcrumb.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/navigation/Breadcrumb 组件。\\n */\\n\\nimport React from 'react';\\nimport { Home, ChevronRight, ChevronLeft } from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { FolderPathItem } from '@/app/types';\\n\\ninterface BreadcrumbProps {\\n  folderPath: FolderPathItem[];\\n  showHome?: boolean;\\n  onNavigate?: (folderId: string | null) => void;\\n  onPathClick: (folderId: string | null) => void;\\n  onBackClick?: () => void;\\n}\\n\\nexport function Breadcrumb({ \\n  folderPath, \\n  showHome = true, \\n  onNavigate, \\n  onPathClick,\\n  onBackClick\\n}: BreadcrumbProps) {\\n  // 向下兼容：如果有onNavigate但没有onPathClick，就使用onNavigate\\n  const handlePathClick = onPathClick || onNavigate;\\n\\n  if (!handlePathClick) {\\n    console.error('Breadcrumb组件缺少必要的onPathClick或onNavigate回调函数');\\n    return null;\\n  }\\n\\n  return (\\n    <div className={styles.breadcrumb}>\\n      {onBackClick && folderPath.length > 0 && (\\n        <button \\n          className={styles.breadcrumbBackButton}\\n          onClick={onBackClick}\\n          title=\\\"返回上一级\\\"\\n        >\\n          <ChevronLeft size={16} />\\n        </button>\\n      )}\\n      \\n      {showHome && (\\n        <div className={styles.breadcrumbItem}>\\n          <button\\n            className={styles.breadcrumbLink}\\n            onClick={() => handlePathClick(null)}\\n          >\\n            <Home size={16} className={styles.breadcrumbIcon} />\\n            根目录\\n          </button>\\n        </div>\\n      )}\\n      \\n      {folderPath.map((folder) => (\\n        <React.Fragment key={folder.id}>\\n          <span className={styles.breadcrumbSeparator}>\\n            <ChevronRight size={14} />\\n          </span>\\n          <div className={styles.breadcrumbItem}>\\n            <button\\n              className={styles.breadcrumbLink}\\n              onClick={() => handlePathClick(folder.id)}\\n            >\\n              {folder.name}\\n            </button>\\n          </div>\\n        </React.Fragment>\\n      ))}\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\ErrorDisplay.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/shared/ErrorDisplay 组件。\\n */\\n\\n'use client';\\n\\nimport React from 'react';\\nimport { AlertTriangle, RefreshCw, Wifi, Server, CloudOff } from 'lucide-react';\\nimport styles from '../../../../file-management/styles/shared.module.css';\\n\\ninterface ErrorDisplayProps {\\n  title?: string;\\n  message?: string;\\n  errorType?: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown';\\n  onRetry?: () => void;\\n  retryText?: string;\\n}\\n\\n/**\\n * 显示友好的错误提示，支持不同类型的错误\\n */\\nexport const ErrorDisplay: React.FC<ErrorDisplayProps> = ({\\n  title,\\n  message = '请刷新页面重试或联系管理员',\\n  errorType = 'unknown',\\n  onRetry,\\n  retryText = '重试'\\n}) => {\\n  // 根据错误类型获取图标和标题\\n  const getErrorInfo = () => {\\n    switch (errorType) {\\n      case 'network':\\n        return {\\n          icon: <Wifi className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '网络连接错误'\\n        };\\n      case 'auth':\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '身份验证失败'\\n        };\\n      case 'server':\\n        return {\\n          icon: <Server className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '服务器错误'\\n        };\\n      case 'data':\\n        return {\\n          icon: <CloudOff className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '数据加载失败'\\n        };\\n      case 'timeout':\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '请求超时'\\n        };\\n      default:\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '加载出错'\\n        };\\n    }\\n  };\\n\\n  const { icon, defaultTitle } = getErrorInfo();\\n  const displayTitle = title || defaultTitle;\\n\\n  return (\\n    <div className={styles.errorContainer}>\\n      <div className={styles.errorCard}>\\n        <div className={styles.errorIcon}>\\n          {icon}\\n        </div>\\n        <h3 className={styles.errorTitle}>{displayTitle}</h3>\\n        <p className={styles.errorText}>{message}</p>\\n        {onRetry && (\\n          <button \\n            className={styles.retryButton}\\n            onClick={onRetry}\\n          >\\n            <RefreshCw className=\\\"w-4 h-4\\\" />\\n            {retryText}\\n          </button>\\n        )}\\n      </div>\\n    </div>\\n  );\\n}; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\FileList.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/fileList/FileList 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport { \\n  File as FileIcon, \\n  Folder, \\n  Image as ImageIcon, \\n  FileText, \\n  Video, \\n  Music, \\n  MoreVertical,\\n  Tag as TagIcon,\\n  SearchX,\\n  Filter,\\n  Check,\\n  X,\\n  Plus\\n} from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { getFileType as getFileTypeDisplay } from '@/app/utils/file/type';\\nimport { getFileNameAndExtension } from '@/app/utils/file/path';\\nimport { FileInfo } from '@/app/types';\\n\\ninterface FileListProps {\\n  files: FileInfo[];\\n  selectedFiles: string[];\\n  onFileClick: (file: FileInfo) => void;\\n  onFileDoubleClick?: (file: FileInfo) => void;\\n  onFileContextMenu?: (event: React.MouseEvent, file: FileInfo) => void;\\n  onSelectFiles?: (fileIds: string[]) => void;\\n  onFileSelect?: (file: FileInfo, checked: boolean) => void;\\n  onSelectAll?: () => void;\\n  onDeselectAll?: () => void;\\n  onSelectAllFiles?: () => void;\\n  onDeselectAllFiles?: () => void;\\n  fileTypeFilter?: string | null;\\n  isLoading?: boolean;\\n  error?: string | null;\\n  onBackClick?: () => void;\\n  editingFileId?: string | null;\\n  editingFile?: string | null;\\n  editingName?: string;\\n  editingTags?: string[];\\n  newTag?: string;\\n  onNewTagChange?: (value: string) => void;\\n  onEditNameChange?: (value: string) => void;\\n  onStartEdit?: (file: FileInfo) => void;\\n  onConfirmEdit?: (fileId: string, newName: string, newTags: string[]) => void;\\n  onCancelEdit?: () => void;\\n  onAddTag?: (tag: string) => void;\\n  onRemoveTag?: (tag: string) => void;\\n  showCheckboxes?: boolean;\\n  areAllSelected?: boolean;\\n}\\n\\nexport function FileList({\\n  files,\\n  selectedFiles,\\n  onFileClick,\\n  onFileDoubleClick,\\n  onFileContextMenu,\\n  onSelectFiles,\\n  onFileSelect,\\n  onSelectAll,\\n  onDeselectAll,\\n  onSelectAllFiles,\\n  onDeselectAllFiles,\\n  fileTypeFilter,\\n  isLoading,\\n  error,\\n  onBackClick,\\n  editingFileId,\\n  editingFile,\\n  editingName: providedEditingName,\\n  editingTags: providedEditingTags,\\n  newTag: providedNewTag,\\n  onNewTagChange,\\n  onEditNameChange,\\n  onStartEdit,\\n  onConfirmEdit,\\n  onCancelEdit,\\n  onAddTag,\\n  onRemoveTag,\\n  showCheckboxes = true,\\n  areAllSelected\\n}: FileListProps) {\\n  const actualEditingFileId = editingFileId || editingFile;\\n\\n  const [localEditName, setLocalEditName] = useState<string>('');\\n  const [localEditTags, setLocalEditTags] = useState<string[]>([]);\\n  const [localNewTag, setLocalNewTag] = useState<string>('');\\n  \\n  const editName = providedEditingName !== undefined ? providedEditingName : localEditName;\\n  const editTags = providedEditingTags !== undefined ? providedEditingTags : localEditTags;\\n  const newTagValue = providedNewTag !== undefined ? providedNewTag : localNewTag;\\n  \\n  const setEditName = (value: string) => {\\n    if (onEditNameChange) {\\n      onEditNameChange(value);\\n    } else {\\n      setLocalEditName(value);\\n    }\\n  };\\n  \\n  const setEditTags = (tags: string[]) => {\\n    setLocalEditTags(tags);\\n  };\\n  \\n  const setNewTag = (value: string) => {\\n    if (onNewTagChange) {\\n      onNewTagChange(value);\\n    } else {\\n      setLocalNewTag(value);\\n    }\\n  };\\n\\n  const editNameInputRef = useRef<HTMLInputElement>(null);\\n  const newTagInputRef = useRef<HTMLInputElement>(null);\\n\\n  useEffect(() => {\\n    if (actualEditingFileId && providedEditingName === undefined) {\\n      const file = files.find(f => f.id === actualEditingFileId);\\n      if (file) {\\n        setLocalEditName(file.name);\\n        setLocalEditTags(file.tags || []);\\n      }\\n    }\\n    \\n    if (actualEditingFileId) {\\n      setTimeout(() => {\\n        if (editNameInputRef.current) {\\n          editNameInputRef.current.focus();\\n          editNameInputRef.current.select();\\n        }\\n      }, 0);\\n    }\\n  }, [actualEditingFileId, files, providedEditingName]);\\n\\n  const handleEditKeyDown = (e: React.KeyboardEvent, fileId: string) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      onConfirmEdit && onConfirmEdit(fileId, editName, editTags);\\n    } else if (e.key === 'Escape') {\\n      e.preventDefault();\\n      onCancelEdit && onCancelEdit();\\n    }\\n  };\\n\\n  const handleAddTag = () => {\\n    const trimmedTag = newTagValue.trim();\\n    if (!trimmedTag) return;\\n    \\n    if (!editTags.includes(trimmedTag)) {\\n      if (onAddTag) {\\n        onAddTag(trimmedTag);\\n      } else {\\n        setEditTags([...editTags, trimmedTag]);\\n      }\\n      setNewTag('');\\n      \\n      setTimeout(() => {\\n        if (newTagInputRef.current) {\\n          newTagInputRef.current.focus();\\n        }\\n      }, 0);\\n    }\\n  };\\n\\n  const handleRemoveTag = (tagToRemove: string) => {\\n    if (onRemoveTag) {\\n      onRemoveTag(tagToRemove);\\n    } else {\\n      setEditTags(editTags.filter(tag => tag !== tagToRemove));\\n    }\\n  };\\n\\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      handleAddTag();\\n    }\\n  };\\n\\n  const handleFileCheckboxChange = (file: FileInfo, checked: boolean) => {\\n    if (onFileSelect) {\\n      onFileSelect(file, checked);\\n      return;\\n    }\\n    \\n    if (onSelectFiles) {\\n      if (checked) {\\n        onSelectFiles([...selectedFiles, file.id]);\\n      } else {\\n        onSelectFiles(selectedFiles.filter(id => id !== file.id));\\n      }\\n    } else {\\n      console.error('FileList: 缺少必要的onSelectFiles或onFileSelect回调函数');\\n    }\\n  };\\n\\n  const handleSelectAll = onSelectAll || onSelectAllFiles;\\n  const handleDeselectAll = onDeselectAll || onDeselectAllFiles;\\n\\n  const renderFileIcon = (type?: string, extension?: string, isFolder?: boolean) => {\\n    if (isFolder) return <Folder className={styles.fileIcon} />;\\n    \\n    const getFileIconType = () => {\\n      if (!type) return 'file';\\n      \\n      if (type.includes('image')) return 'image';\\n      if (type.includes('text') || type.includes('document') || extension?.match(/docx?|pdf|txt|md/i)) return 'file-text';\\n      if (type.includes('video')) return 'video';\\n      if (type.includes('audio')) return 'music';\\n      if (extension?.match(/zip|rar|7z|tar|gz/i)) return 'archive';\\n      if (extension?.match(/js|ts|jsx|tsx|py|java|c|cpp|go|rb|php|html|css/i)) return 'code';\\n      \\n      return 'file';\\n    };\\n    \\n    const iconType = getFileIconType();\\n    const IconComponent = {\\n      'folder': Folder,\\n      'file': FileIcon,\\n      'image': ImageIcon,\\n      'file-text': FileText,\\n      'video': Video,\\n      'music': Music,\\n      'archive': FileIcon,\\n      'code': FileIcon\\n    }[iconType] || FileIcon;\\n\\n    return <IconComponent className={styles.fileIcon} />;\\n  };\\n\\n  const renderTags = (file: FileInfo) => {\\n    const tags = file.tags || [];\\n    \\n    if (actualEditingFileId === file.id) {\\n      return (\\n        <div className={styles.tagEditContainer}>\\n          <div className={styles.editTagsList}>\\n            {editTags.map((tag, index) => (\\n              <div key={index} className={styles.editTag}>\\n                <span>{tag}</span>\\n                <button \\n                  className={styles.removeTagButton}\\n                  onClick={() => handleRemoveTag(tag)}\\n                >\\n                  <X size={12} />\\n                </button>\\n              </div>\\n            ))}\\n          </div>\\n          <div className={styles.addTagInput}>\\n            <input\\n              ref={newTagInputRef}\\n              type=\\\"text\\\"\\n              placeholder=\\\"添加标签...\\\"\\n              value={localNewTag}\\n              onChange={(e) => setNewTag(e.target.value)}\\n              onKeyDown={handleTagKeyDown}\\n              className={styles.tagInput}\\n            />\\n            <button \\n              className={styles.addTagButton}\\n              onClick={handleAddTag}\\n            >\\n              <Plus size={14} />\\n            </button>\\n          </div>\\n        </div>\\n      );\\n    }\\n    \\n    if (!tags || tags.length === 0) return <span className={styles.emptyText}>-</span>;\\n    \\n    const maxTagsToShow = 3;\\n    const visibleTags = tags.slice(0, maxTagsToShow);\\n    const extraTagsCount = tags.length - maxTagsToShow;\\n    \\n    return (\\n      <div className={styles.tagContainer}>\\n        {visibleTags.map((tag, index) => (\\n          <span key={index} className={styles.tag}>\\n            {tag}\\n          </span>\\n        ))}\\n        {extraTagsCount > 0 && (\\n          <span className={styles.extraTagsCount}>+{extraTagsCount}</span>\\n        )}\\n      </div>\\n    );\\n  };\\n\\n  const isAllSelected = areAllSelected !== undefined \\n    ? areAllSelected \\n    : (files.length > 0 && selectedFiles.length === files.length);\\n\\n  if (!Array.isArray(files) || files.length === 0) {\\n    const getEmptyStateMessage = () => {\\n      if (fileTypeFilter) {\\n        switch(fileTypeFilter) {\\n          case 'image':\\n            return `您的存储空间中没有找到图片文件`;\\n          case 'document':\\n            return `您的存储空间中没有找到文档文件`;\\n          case 'video':\\n            return `您的存储空间中没有找到视频文件`;\\n          case 'audio':\\n            return `您的存储空间中没有找到音频文件`;\\n          case 'other':\\n            return `您的存储空间中没有找到其他类型的文件`;\\n          default:\\n            return `没有找到${fileTypeFilter}类型的文件`;\\n        }\\n      }\\n      return '没有文件';\\n    };\\n\\n    const getEmptyStateIcon = () => {\\n      if (fileTypeFilter) {\\n        return <Filter size={50} stroke=\\\"#CBD5E0\\\" />;\\n      }\\n      return <FileIcon size={50} stroke=\\\"#CBD5E0\\\" />;\\n    };\\n\\n    const getEmptyStateHint = () => {\\n      if (fileTypeFilter) {\\n        return `系统已搜索所有文件夹，未找到${\\n          fileTypeFilter === 'image' ? '图片' : \\n          fileTypeFilter === 'document' ? '文档' : \\n          fileTypeFilter === 'video' ? '视频' :\\n          fileTypeFilter === 'audio' ? '音频' : '该类型'\\n        }文件，您可以上传一些，或选择其他文件类型查看。`;\\n      }\\n      return '上传文件或创建文件夹以开始管理您的文件';\\n    };\\n\\n    return (\\n      <div className={styles.emptyState}>\\n        {getEmptyStateIcon()}\\n        <p className={styles.emptyStateText}>{getEmptyStateMessage()}</p>\\n        <p className={styles.emptyStateHint}>\\n          {getEmptyStateHint()}\\n        </p>\\n      </div>\\n    );\\n  }\\n\\n  return (\\n    <div className={styles.fileListWrapper}>\\n      <div className={styles.fileListContainer}>\\n        <table className={styles.fileTable}>\\n          <thead>\\n            <tr>\\n              <th>\\n                <input\\n                  type=\\\"checkbox\\\"\\n                  checked={isAllSelected}\\n                  onChange={isAllSelected ? \\n                    () => handleDeselectAll && handleDeselectAll() : \\n                    () => handleSelectAll && handleSelectAll()}\\n                  disabled={!showCheckboxes}\\n                />\\n              </th>\\n              <th>名称</th>\\n              <th>类型</th>\\n              <th>大小</th>\\n              <th>标签</th>\\n              <th>修改日期</th>\\n              <th>操作</th>\\n            </tr>\\n          </thead>\\n          <tbody>\\n            {files.map((file) => {\\n              const isSelected = selectedFiles.includes(file.id);\\n              const isEditing = actualEditingFileId === file.id;\\n              \\n              return (\\n                <tr\\n                  key={file.id}\\n                  className={`${styles.fileRow} ${isSelected ? styles.selectedRow : ''} ${isEditing ? styles.editingRow : ''}`}\\n                  onClick={() => !isEditing && onFileClick(file)}\\n                  onDoubleClick={() => {\\n                    if (!isEditing && onStartEdit && !file.isFolder) {\\n                      onStartEdit(file);\\n                    } else if (!isEditing && onFileDoubleClick) {\\n                      onFileDoubleClick(file);\\n                    }\\n                  }}\\n                  onContextMenu={(e) => !isEditing && onFileContextMenu && onFileContextMenu(e, file)}\\n                >\\n                  <td>\\n                    {showCheckboxes && (\\n                      <input\\n                        type=\\\"checkbox\\\"\\n                        checked={isSelected}\\n                        onChange={(e) => handleFileCheckboxChange(file, e.target.checked)}\\n                        onClick={(e) => e.stopPropagation()}\\n                        disabled={isEditing}\\n                      />\\n                    )}\\n                  </td>\\n                  <td className={styles.fileNameCell}>\\n                    <span className={styles.fileIcon}>\\n                      {renderFileIcon(file.type, file.extension, file.isFolder)}\\n                    </span>\\n                    {isEditing ? (\\n                      <input\\n                        ref={editNameInputRef}\\n                        type=\\\"text\\\"\\n                        className={styles.fileNameInput}\\n                        value={editName}\\n                        onChange={(e) => setEditName(e.target.value)}\\n                        onKeyDown={(e) => handleEditKeyDown(e, file.id)}\\n                        onClick={(e) => e.stopPropagation()}\\n                        autoComplete=\\\"off\\\"\\n                      />\\n                    ) : (\\n                      <span className={styles.fileName}>{file.name}</span>\\n                    )}\\n                    {isEditing && (\\n                      <div className={styles.editActions}>\\n                        <button \\n                          className={styles.editActionButton}\\n                          onClick={(e) => {\\n                            e.stopPropagation();\\n                            onConfirmEdit && onConfirmEdit(file.id, editName, editTags);\\n                          }}\\n                        >\\n                          <Check size={16} />\\n                        </button>\\n                        <button \\n                          className={styles.editActionButton}\\n                          onClick={(e) => {\\n                            e.stopPropagation();\\n                            onCancelEdit && onCancelEdit();\\n                          }}\\n                        >\\n                          <X size={16} />\\n                        </button>\\n                      </div>\\n                    )}\\n                  </td>\\n                  <td>{file.isFolder ? '文件夹' : \\n                     file.type === 'document' ? '文档' : \\n                     getFileTypeDisplay(file.type || null, file.extension)}</td>\\n                  <td>{file.size ? `${Math.round(file.size / 1024)} KB` : '-'}</td>\\n                  <td className={styles.tagsCell}>{renderTags(file)}</td>\\n                  <td>\\n                    {file.createdAt \\n                      ? new Date(file.createdAt).toLocaleString() \\n                      : '-'\\n                    }\\n                  </td>\\n                  <td>\\n                    {!isEditing ? (\\n                      <button \\n                        className={styles.actionButton}\\n                        onClick={(e) => {\\n                          e.stopPropagation();\\n                          if (onStartEdit) {\\n                            onStartEdit(file);\\n                          } else if (onFileContextMenu) {\\n                            onFileContextMenu(e, file);\\n                          }\\n                        }}\\n                      >\\n                        <MoreVertical size={16} />\\n                      </button>\\n                    ) : (\\n                      <span className={styles.editingMessage}>编辑中</span>\\n                    )}\\n                  </td>\\n                </tr>\\n              );\\n            })}\\n          </tbody>\\n        </table>\\n      </div>\\n    </div>\\n  );\\n}\"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\index.ts\",\n    \"newContent\": \"export * from './Sidebar';\\nexport * from './Breadcrumb';\\nexport * from './FileList';\\n// export * from './UploadModal'; // 已迁移到 @/app/components/features/file-management/upload/UploadModal\\n// export * from './UploadButton'; // 已迁移到 @/app/components/features/file-management/upload/UploadButton\\nexport * from './Skeleton';\\nexport * from './ErrorDisplay'; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Sidebar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/navigation/Sidebar 组件。\\n */\\n\\nimport React, { useEffect } from 'react';\\nimport { \\n  Folder, Files, Image as ImageIcon, FileText, \\n  Video, Music, File, Search, ChevronDown, \\n  Star, Clock, Tag, Download, Settings,\\n  CheckCircle\\n} from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\n\\nexport type FileType = 'image' | 'document' | 'video' | 'audio' | 'other' | null;\\n\\ninterface SidebarProps {\\n  selectedFileType: FileType;\\n  onTypeClick: (type: FileType) => void;\\n  onSearchClick?: () => void;\\n}\\n\\nexport function Sidebar({ selectedFileType, onTypeClick, onSearchClick }: SidebarProps) {\\n  const fileTypes: { type: FileType; label: string; icon: React.ElementType }[] = [\\n    { type: null, label: '全部文件', icon: Files },\\n    { type: 'image', label: '图片', icon: ImageIcon },\\n    { type: 'document', label: '文档', icon: FileText },\\n    { type: 'video', label: '视频', icon: Video },\\n    { type: 'audio', label: '音频', icon: Music },\\n    { type: 'other', label: '其他', icon: File }\\n  ];\\n\\n  const [quickAccessExpanded, setQuickAccessExpanded] = React.useState(true);\\n  const [myFilesExpanded, setMyFilesExpanded] = React.useState(true);\\n  const [settingsExpanded, setSettingsExpanded] = React.useState(false);\\n\\n  // 监听文件类型变化并记录日志\\n  useEffect(() => {\\n    console.log('侧边栏：当前选择的文件类型:', selectedFileType);\\n  }, [selectedFileType]);\\n\\n  const handleTypeClick = (type: FileType) => {\\n    // 直接调用回调，不需要任何额外逻辑\\n    console.log('Sidebar直接点击类型:', type);\\n    onTypeClick(type);\\n  };\\n\\n  return (\\n    <div className={styles.sidebar}>\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader} \\n          onClick={() => setMyFilesExpanded(!myFilesExpanded)}\\n        >\\n          <Folder className={styles.icon} />\\n          我的文件\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: myFilesExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {myFilesExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            {fileTypes.map(({ type, label, icon: Icon }) => (\\n              <div\\n                key={type || 'all'}\\n                className={`${styles.sidebarItem} ${selectedFileType === type ? styles.active : ''}`}\\n                onClick={() => handleTypeClick(type)}\\n              >\\n                <Icon className={styles.icon} />\\n                {label}\\n                {selectedFileType === type && (\\n                  <CheckCircle \\n                    className={styles.icon} \\n                    style={{ \\n                      marginLeft: 'auto', \\n                      color: 'var(--theme-primary, #3b82f6)',\\n                      fill: 'var(--theme-primary, #3b82f6)',\\n                      stroke: '#fff',\\n                      opacity: 0.9,\\n                    }} \\n                    size={16} \\n                  />\\n                )}\\n              </div>\\n            ))}\\n          </div>\\n        )}\\n      </div>\\n\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader}\\n          onClick={() => setQuickAccessExpanded(!quickAccessExpanded)}\\n        >\\n          <Search className={styles.icon} />\\n          快捷查询\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: quickAccessExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {quickAccessExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            <div \\n              className={styles.sidebarItem}\\n              onClick={onSearchClick}\\n            >\\n              <Search className={styles.icon} />\\n              搜索文件\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Star className={styles.icon} />\\n              收藏文件\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Clock className={styles.icon} />\\n              最近访问\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Tag className={styles.icon} />\\n              按标签查找\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Download className={styles.icon} />\\n              下载记录\\n            </div>\\n          </div>\\n        )}\\n      </div>\\n\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader}\\n          onClick={() => setSettingsExpanded(!settingsExpanded)}\\n        >\\n          <Settings className={styles.icon} />\\n          系统设置\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: settingsExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {settingsExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            <div className={styles.sidebarItem}>\\n              <Settings className={styles.icon} />\\n              存储管理\\n            </div>\\n          </div>\\n        )}\\n      </div>\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Skeleton.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/shared/Skeleton 组件。\\n */\\n\\n'use client';\\n\\nimport React from 'react';\\nimport styles from './Skeleton.module.css';\\n\\ninterface SkeletonProps {\\n  variant?: 'sidebar' | 'file' | 'avatar' | 'text' | 'button' | 'card';\\n  width?: string | number;\\n  height?: string | number;\\n  animation?: 'pulse' | 'wave' | 'none';\\n  count?: number;\\n  className?: string;\\n  borderRadius?: string;\\n}\\n\\nexport const Skeleton: React.FC<SkeletonProps> = ({ \\n  variant = 'text', \\n  width, \\n  height, \\n  animation = 'pulse',\\n  count = 1,\\n  className = '',\\n  borderRadius\\n}) => {\\n  const getVariantStyles = () => {\\n    switch (variant) {\\n      case 'sidebar':\\n        return {\\n          width: width || '100%',\\n          height: height || '40px',\\n          borderRadius: borderRadius || '8px'\\n        };\\n      case 'file':\\n        return {\\n          width: width || '100%',\\n          height: height || '56px',\\n          borderRadius: borderRadius || '8px'\\n        };\\n      case 'avatar':\\n        return {\\n          width: width || '40px',\\n          height: height || '40px',\\n          borderRadius: borderRadius || '50%'\\n        };\\n      case 'text':\\n        return {\\n          width: width || '100%',\\n          height: height || '16px',\\n          borderRadius: borderRadius || '4px'\\n        };\\n      case 'button':\\n        return {\\n          width: width || '120px',\\n          height: height || '36px',\\n          borderRadius: borderRadius || '6px'\\n        };\\n      case 'card':\\n        return {\\n          width: width || '100%',\\n          height: height || '200px',\\n          borderRadius: borderRadius || '12px'\\n        };\\n      default:\\n        return {\\n          width: width || '100%',\\n          height: height || '16px',\\n          borderRadius: borderRadius || '4px'\\n        };\\n    }\\n  };\\n\\n  const renderSkeleton = () => {\\n    const items = [];\\n    const baseStyles = getVariantStyles();\\n    \\n    for (let i = 0; i < count; i++) {\\n      items.push(\\n        <div \\n          key={i}\\n          className={`${styles.skeleton} ${styles[`animation-${animation}`]} ${className}`}\\n          style={{\\n            ...baseStyles,\\n            marginBottom: count > 1 && i < count - 1 ? '8px' : '0'\\n          }}\\n        />\\n      );\\n    }\\n    \\n    return items;\\n  };\\n\\n  return <>{renderSkeleton()}</>;\\n};\\n\\nexport const SkeletonFileList: React.FC = () => {\\n  return (\\n    <div className={styles.fileListSkeleton}>\\n      <div className={styles.fileListHeader}>\\n        <Skeleton variant=\\\"text\\\" width=\\\"15%\\\" height=\\\"24px\\\" />\\n        <div className={styles.headerActions}>\\n          <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n          <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n        </div>\\n      </div>\\n      \\n      <div className={styles.fileItems}>\\n        {[...Array(8)].map((_, index) => (\\n          <div key={index} className={styles.fileItemSkeleton}>\\n            <div className={styles.fileIcon}>\\n              <Skeleton variant=\\\"avatar\\\" width=\\\"32px\\\" height=\\\"32px\\\" borderRadius=\\\"6px\\\" />\\n            </div>\\n            <div className={styles.fileDetails}>\\n              <Skeleton variant=\\\"text\\\" width=\\\"60%\\\" height=\\\"18px\\\" />\\n              <Skeleton variant=\\\"text\\\" width=\\\"40%\\\" height=\\\"14px\\\" />\\n            </div>\\n            <div className={styles.fileActions}>\\n              <Skeleton variant=\\\"button\\\" width=\\\"70px\\\" />\\n            </div>\\n          </div>\\n        ))}\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport const SkeletonSidebar: React.FC = () => {\\n  return (\\n    <div className={styles.sidebarSkeleton}>\\n      <div className={styles.sidebarHeader}>\\n        <Skeleton variant=\\\"text\\\" width=\\\"70%\\\" height=\\\"24px\\\" />\\n      </div>\\n      <div className={styles.sidebarContent}>\\n        <Skeleton variant=\\\"sidebar\\\" count={5} />\\n        <div className={styles.sidebarSection}>\\n          <Skeleton variant=\\\"text\\\" width=\\\"50%\\\" height=\\\"18px\\\" />\\n          <Skeleton variant=\\\"sidebar\\\" count={3} />\\n        </div>\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport const SkeletonPageLayout: React.FC = () => {\\n  return (\\n    <div className={styles.pageLayoutSkeleton}>\\n      <div className={styles.miniSidebarSkeleton}>\\n        <Skeleton variant=\\\"avatar\\\" width=\\\"40px\\\" height=\\\"40px\\\" />\\n        <Skeleton variant=\\\"button\\\" width=\\\"40px\\\" height=\\\"40px\\\" borderRadius=\\\"12px\\\" />\\n        <Skeleton variant=\\\"button\\\" width=\\\"40px\\\" height=\\\"40px\\\" borderRadius=\\\"12px\\\" />\\n      </div>\\n      \\n      <div className={styles.sidebarContainerSkeleton}>\\n        <SkeletonSidebar />\\n      </div>\\n      \\n      <div className={styles.mainContentSkeleton}>\\n        <div className={styles.topBarSkeleton}>\\n          <div className={styles.breadcrumbSkeleton}>\\n            <Skeleton variant=\\\"text\\\" width=\\\"180px\\\" height=\\\"20px\\\" />\\n          </div>\\n          <div className={styles.actionButtonsSkeleton}>\\n            <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n            <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n          </div>\\n        </div>\\n        \\n        <SkeletonFileList />\\n      </div>\\n    </div>\\n  );\\n}; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\UploadButton.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/upload/UploadButton 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport { Upload, Folder, ChevronDown } from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { UploadModal } from './UploadModal';\\n\\ninterface UploadButtonProps {\\n  showDropdown: boolean;\\n  setShowDropdown: (show: boolean) => void;\\n  setIsModalOpen: (open: boolean) => void;\\n  setIsFolderModalOpen: (open: boolean) => void;\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\n}\\n\\nexport function UploadButton({ \\n  showDropdown, \\n  setShowDropdown, \\n  setIsModalOpen, \\n  setIsFolderModalOpen,\\n  uploadDropdownRef \\n}: UploadButtonProps) {\\n  \\n  // 处理上传按钮点击\\n  const handleUploadClick = (type: 'file' | 'folder') => {\\n    if (type === 'file') {\\n      setIsModalOpen(true);\\n    } else {\\n      setIsFolderModalOpen(true);\\n    }\\n    setShowDropdown(false);\\n  };\\n\\n  return (\\n    <div className={styles.uploadOptionsContainer} ref={uploadDropdownRef}>\\n      <button\\n        className={`${styles.uploadButton} ${showDropdown ? styles.activeButton : ''}`}\\n        onClick={() => setShowDropdown(!showDropdown)}\\n      >\\n        <Upload size={18} className={styles.buttonIcon} />\\n        上传文件\\n        <ChevronDown size={16} className={styles.dropdownIcon} />\\n      </button>\\n      \\n      {showDropdown && (\\n        <div className={styles.dropdownMenu}>\\n          <div \\n            className={styles.dropdownItem}\\n            onClick={() => handleUploadClick('file')}\\n          >\\n            <Upload size={16} className=\\\"mr-2\\\" />\\n            <span>上传文件</span>\\n          </div>\\n          <div \\n            className={styles.dropdownItem}\\n            onClick={() => handleUploadClick('folder')}\\n          >\\n            <Folder size={16} className=\\\"mr-2\\\" />\\n            <span>上传文件夹</span>\\n          </div>\\n        </div>\\n      )}\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\UploadModal.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/upload/UploadModal 组件。\\n */\\n\\nimport React, { useState, useEffect, useRef, KeyboardEvent } from 'react';\\nimport { InboxOutlined, CloseCircleOutlined, TagOutlined, CloseOutlined } from '@ant-design/icons';\\nimport { Modal, Upload, Input, message, Button, Tag } from 'antd';\\nimport type { RcFile, UploadFile } from 'antd/es/upload/interface';\\nimport type { UploadProps } from 'antd';\\nimport type { InputRef } from 'antd/es/input';\\nimport { FileInfo, FileResponse } from '@/app/types';\\nimport styles from '../../styles/shared.module.css';\\nimport { useSession } from 'next-auth/react';\\nimport { API_PATHS } from '@/app/lib/api/paths';\\n\\nconst { Dragger } = Upload;\\n\\ninterface UploadModalProps {\\n  isOpen: boolean;\\n  onClose: () => void;\\n  onSuccess: (files?: FileInfo[]) => void;\\n  isFolderUpload?: boolean;\\n  currentFolderId?: string | null;\\n}\\n\\n// 扩展UploadFile类型，添加webkitRelativePath属性\\ninterface ExtendedUploadFile extends UploadFile<any> {\\n  webkitRelativePath?: string;\\n}\\n\\nexport function UploadModal({\\n  isOpen,\\n  onClose,\\n  onSuccess,\\n  isFolderUpload = false,\\n  currentFolderId\\n}: UploadModalProps) {\\n  const [fileList, setFileList] = useState<ExtendedUploadFile[]>([]);\\n  const [tagInput, setTagInput] = useState<string>('');\\n  const [tagList, setTagList] = useState<string[]>([]);\\n  const [uploading, setUploading] = useState(false);\\n  const fileInputRef = useRef<HTMLInputElement>(null);\\n  const tagInputRef = useRef<InputRef>(null);\\n  const { data: session } = useSession();\\n\\n  useEffect(() => {\\n    // 当模态框打开时检查登录状态\\n    if (isOpen && !session) {\\n      message.error('请先登录后再上传文件');\\n      onClose();\\n    }\\n  }, [isOpen, session, onClose]);\\n\\n  // 处理文件选择\\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const selectedFiles = e.target.files;\\n    if (!selectedFiles || selectedFiles.length === 0) return;\\n\\n    const newFiles: ExtendedUploadFile[] = [];\\n    for (let i = 0; i < selectedFiles.length; i++) {\\n      const file = selectedFiles[i];\\n      newFiles.push({\\n        uid: `file-${Date.now()}-${i}`,\\n        name: file.name,\\n        size: file.size,\\n        type: file.type,\\n        originFileObj: file as any,\\n        webkitRelativePath: file.webkitRelativePath, // 添加相对路径\\n      });\\n    }\\n\\n    setFileList(prev => [...prev, ...newFiles]);\\n    \\n    // 清空input以允许再次选择相同的文件\\n    if (fileInputRef.current) {\\n      fileInputRef.current.value = '';\\n    }\\n  };\\n\\n  // 处理标签输入\\n  const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    setTagInput(e.target.value);\\n  };\\n\\n  // 处理标签输入的回车事件\\n  const handleTagInputKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\\n    if (e.key === 'Enter' && tagInput.trim()) {\\n      e.preventDefault();\\n      addTag(tagInput.trim());\\n    }\\n  };\\n\\n  // 添加标签\\n  const addTag = (tag: string) => {\\n    if (!tag) return;\\n    \\n    // 检查标签是否已存在\\n    if (!tagList.includes(tag)) {\\n      setTagList(prev => [...prev, tag]);\\n    }\\n    \\n    // 清空输入框\\n    setTagInput('');\\n    \\n    // 聚焦回输入框，方便继续输入\\n    if (tagInputRef.current) {\\n      setTimeout(() => {\\n        tagInputRef.current?.focus();\\n      }, 0);\\n    }\\n  };\\n\\n  // 删除标签\\n  const removeTag = (tagToRemove: string) => {\\n    setTagList(tagList.filter(tag => tag !== tagToRemove));\\n  };\\n\\n  const handleUpload = async () => {\\n    if (fileList.length === 0) {\\n      message.warning('请选择要上传的文件');\\n      return;\\n    }\\n\\n    setUploading(true);\\n\\n    try {\\n      const formData = new FormData();\\n      \\n      // 添加所有文件到FormData\\n      let filesAdded = 0;\\n      fileList.forEach((file, index) => {\\n        const rawFile = file.originFileObj;\\n        if (rawFile instanceof File) {\\n          // 使用'file'字段名，与后端对应\\n          formData.append('file', rawFile);\\n          \\n          // 如果是文件夹上传，添加相对路径信息\\n          if (isFolderUpload && file.webkitRelativePath) {\\n            // 使用数字索引作为键，确保后端可以正确解析\\n            formData.append(`paths_${index}`, file.webkitRelativePath);\\n            console.log(`文件 ${index}: ${file.name} - 路径: ${file.webkitRelativePath}`);\\n          }\\n          \\n          filesAdded++;\\n          console.log(`添加文件 ${index+1}: ${file.name}, 大小: ${file.size} 字节`);\\n        } else {\\n          console.warn(`无法获取文件 ${index+1}: ${file.name} 的原始File对象`);\\n        }\\n      });\\n      \\n      if (filesAdded === 0) {\\n        throw new Error('无法处理上传文件，请重新选择文件');\\n      }\\n      \\n      // 添加标志表明这是文件夹上传\\n      if (isFolderUpload) {\\n        formData.append('isFolderUpload', 'true');\\n        console.log('文件夹上传模式已启用');\\n      }\\n      \\n      // 将标签数组转换为逗号分隔的字符串\\n      if (tagList.length > 0) {\\n        formData.append('tags', JSON.stringify(tagList));\\n        console.log('添加标签:', tagList);\\n      }\\n\\n      if (currentFolderId) {\\n        formData.append('folderId', currentFolderId);\\n        console.log('当前文件夹ID:', currentFolderId);\\n      }\\n\\n      console.log(`准备上传 ${filesAdded} 个文件...`);\\n      \\n      // 显示上传开始消息\\n      const uploadKey = `upload-${Date.now()}`;\\n      message.loading({ content: '正在上传文件...', key: uploadKey, duration: 0 });\\n\\n      // 使用fetch发送请求\\n      const response = await fetch(API_PATHS.STORAGE.FILES.UPLOAD, {\\n        method: 'POST',\\n        body: formData,\\n      });\\n\\n      // 获取响应\\n      const contentType = response.headers.get(\\\"content-type\\\");\\n      let data;\\n      \\n      if (contentType && contentType.includes(\\\"application/json\\\")) {\\n        data = await response.json();\\n      } else {\\n        // 如果不是JSON响应，尝试获取文本\\n        const text = await response.text();\\n        console.error('服务器返回了非JSON响应:', text);\\n        throw new Error('服务器返回了无效的响应格式');\\n      }\\n      \\n      // 检查响应状态\\n      if (!response.ok) {\\n        console.error('上传响应错误:', data);\\n        \\n        // 显示错误消息\\n        message.error({ \\n          content: `上传失败: ${data.details || data.error || '服务器错误'}`, \\n          key: uploadKey,\\n          duration: 5 \\n        });\\n        \\n        throw new Error(data.details || data.error || '上传失败');\\n      }\\n\\n      // 上传成功处理\\n      console.log('上传成功:', data);\\n      message.success({ content: '上传成功', key: uploadKey, duration: 3 });\\n      \\n      // 关闭模态框并通知父组件\\n      handleClose();\\n      if (typeof onSuccess === 'function') {\\n        onSuccess(data.files || (data.file ? [data.file] : undefined));\\n      } else {\\n        console.warn('onSuccess不是一个函数，无法通知上传成功');\\n      }\\n    } catch (error) {\\n      console.error('上传过程中出错:', error);\\n      message.error(`上传失败: ${error instanceof Error ? error.message : '未知错误'}`);\\n    } finally {\\n      setUploading(false);\\n    }\\n  };\\n\\n  const handleClose = () => {\\n    setFileList([]);\\n    setTagInput('');\\n    setTagList([]);\\n    onClose();\\n  };\\n  \\n  // 直接使用原生文件输入\\n  const triggerFileInput = () => {\\n    if (fileInputRef.current) {\\n      fileInputRef.current.click();\\n    }\\n  };\\n  \\n  const removeFile = (index: number) => {\\n    setFileList(prev => prev.filter((_, i) => i !== index));\\n  };\\n\\n  return (\\n    <Modal\\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\\n      open={isOpen}\\n      onCancel={handleClose}\\n      onOk={handleUpload}\\n      okText=\\\"上传\\\"\\n      cancelText=\\\"取消\\\"\\n      confirmLoading={uploading}\\n      width={600}\\n    >\\n      <div className={styles.uploadContainer || ''}>\\n        <input\\n          type=\\\"file\\\"\\n          ref={fileInputRef}\\n          onChange={handleFileChange}\\n          style={{ display: 'none' }}\\n          multiple={true}\\n          {...(isFolderUpload ? { webkitdirectory: '', directory: '', mozdirectory: '', msdirectory: '' } : {})}\\n        />\\n        \\n        <div \\n          className={styles.dropzone || ''}\\n          onClick={triggerFileInput}\\n          style={{ \\n            border: '2px dashed #d9d9d9',\\n            borderRadius: '4px',\\n            padding: '20px',\\n            textAlign: 'center',\\n            cursor: 'pointer',\\n            marginBottom: '16px'\\n          }}\\n        >\\n          <p><InboxOutlined style={{ fontSize: '48px', color: '#40a9ff' }} /></p>\\n          <p style={{ marginTop: '8px', fontWeight: 'bold' }}>\\n            点击或拖拽{isFolderUpload ? '文件夹' : '文件'}到此区域上传\\n          </p>\\n          <p style={{ color: '#888' }}>\\n            {isFolderUpload\\n              ? '支持上传整个文件夹及其内部文件，保留文件夹结构'\\n              : '支持单个或批量上传文件，最大支持同时选择50个文件'}\\n          </p>\\n          <Button type=\\\"primary\\\" onClick={(e) => { e.stopPropagation(); triggerFileInput(); }}>\\n            选择{isFolderUpload ? '文件夹' : '文件'}\\n          </Button>\\n        </div>\\n        \\n        {fileList.length > 0 && (\\n          <div style={{ marginBottom: '16px' }}>\\n            <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\\n              已选择 {fileList.length} 个文件:\\n            </div>\\n            <ul style={{ maxHeight: '150px', overflowY: 'auto', padding: '0 0 0 20px' }}>\\n              {fileList.map((file, index) => (\\n                <li key={file.uid} style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>\\n                  <span>\\n                    {file.name} \\n                    {isFolderUpload && file.webkitRelativePath && (\\n                      <span style={{ fontSize: '12px', color: '#8c8c8c', marginLeft: '4px' }}>\\n                        (路径: {file.webkitRelativePath.split('/').slice(0, -1).join('/')})\\n                      </span>\\n                    )}\\n                    ({((file.size || 0) / 1024).toFixed(2)} KB)\\n                  </span>\\n                  <Button \\n                    type=\\\"text\\\" \\n                    danger \\n                    onClick={() => removeFile(index)}\\n                    style={{ padding: '0 4px' }}\\n                  >\\n                    删除\\n                  </Button>\\n                </li>\\n              ))}\\n            </ul>\\n          </div>\\n        )}\\n\\n        <div style={{ marginTop: 16 }}>\\n          <div style={{ marginBottom: '8px', display: 'flex', alignItems: 'center' }}>\\n            <span style={{ fontWeight: 'bold', marginRight: '8px' }}>添加标签:</span>\\n            <span style={{ fontSize: '12px', color: '#8c8c8c' }}>\\n              (输入标签后按回车添加)\\n            </span>\\n          </div>\\n          \\n          <div className={styles.tagsInputWrapper}>\\n            <Input\\n              ref={tagInputRef}\\n              placeholder=\\\"输入标签后按回车添加\\\"\\n              value={tagInput}\\n              onChange={handleTagInputChange}\\n              onKeyDown={handleTagInputKeyDown}\\n              prefix={<TagOutlined style={{ color: '#bfbfbf' }} />}\\n              suffix={\\n                <span style={{ color: '#bfbfbf', fontSize: '12px' }}>\\n                  按回车添加\\n                </span>\\n              }\\n            />\\n          </div>\\n          \\n          <div className={styles.tagsContainer}>\\n            {tagList.length > 0 ? (\\n              <div className={styles.tagsList}>\\n                {tagList.map((tag, index) => (\\n                  <Tag\\n                    key={index}\\n                    closable\\n                    onClose={() => removeTag(tag)}\\n                    className={styles.interactiveTag}\\n                  >\\n                    {tag}\\n                  </Tag>\\n                ))}\\n              </div>\\n            ) : (\\n              <div className={styles.emptyTagsHint}>\\n                添加一些标签来帮助管理您的文件\\n              </div>\\n            )}\\n          </div>\\n        </div>\\n\\n        <div style={{ marginTop: '16px', padding: '12px', background: '#f5f5f5', borderRadius: '8px', fontSize: '13px', color: '#555' }}>\\n          <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\\n            {isFolderUpload ? '文件夹上传说明:' : '文件上传说明:'}\\n          </div>\\n          <ul style={{ paddingLeft: '16px', margin: '0' }}>\\n            {isFolderUpload ? (\\n              <>\\n                <li>支持上传整个文件夹及其子文件夹结构</li>\\n                <li>保留完整的文件夹层次结构</li>\\n                <li>目前仅Chrome、Edge等现代浏览器支持文件夹选择</li>\\n                <li>如果您的浏览器不支持文件夹选择，请选择单个文件模式</li>\\n              </>\\n            ) : (\\n              <>\\n                <li>支持批量上传多个文件</li>\\n                <li>支持常见的文件格式（图片、文档、视频等）</li>\\n                <li>每个文件大小限制为50MB</li>\\n                <li>一次最多可选择50个文件</li>\\n              </>\\n            )}\\n            <li>您可以为上传的文件添加标签，以便更好地组织和查找</li>\\n          </ul>\\n        </div>\\n      </div>\\n    </Modal>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\SortDropdown.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/actionBar/SortDropdown 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport styles from '../styles/SortDropdown.module.css';\\nimport { FileSortInterface, SortDirectionEnum } from '@/app/types';\\n\\ninterface SortDropdownProps {\\n  sortOrder: FileSortInterface;\\n  onSortChange: (order: FileSortInterface) => void;\\n}\\n\\nexport const SortDropdown: React.FC<SortDropdownProps> = ({\\n  sortOrder,\\n  onSortChange\\n}) => {\\n  const [showDropdown, setShowDropdown] = useState(false);\\n  const dropdownRef = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\\n        setShowDropdown(false);\\n      }\\n    };\\n\\n    document.addEventListener('mousedown', handleClickOutside);\\n    return () => document.removeEventListener('mousedown', handleClickOutside);\\n  }, []);\\n\\n  // 根据当前排序字段获取显示文本\\n  const getSortFieldText = () => {\\n    switch(sortOrder.field) {\\n      case 'name': return '文件名';\\n      case 'size': return '大小';\\n      case 'createdAt': return '时间';\\n      default: return '默认';\\n    }\\n  };\\n\\n  return (\\n    <div className={styles.sortDropdown} ref={dropdownRef}>\\n      <button \\n        className={styles.topButton}\\n        onClick={() => setShowDropdown(!showDropdown)}\\n        style={{ \\n          background: showDropdown ? '#f0f7ff' : 'white',\\n          borderColor: showDropdown ? '#60a5fa' : '#e8e8e8'\\n        }}\\n      >\\n        <span>↕️</span>\\n        排序: {getSortFieldText()} {sortOrder.direction === SortDirectionEnum.ASC ? '↑' : '↓'}\\n      </button>\\n      {showDropdown && (\\n        <div className={styles.dropdownMenu}>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'name',\\n                direction: sortOrder.field === 'name' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'name' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'name' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>📝</span>\\n            按文件名{sortOrder.field === 'name' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'size',\\n                direction: sortOrder.field === 'size' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'size' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'size' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>📊</span>\\n            按大小{sortOrder.field === 'size' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'createdAt',\\n                direction: sortOrder.field === 'createdAt' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'createdAt' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'createdAt' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>🕒</span>\\n            按时间{sortOrder.field === 'createdAt' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n        </div>\\n      )}\\n    </div>\\n  );\\n};\\n\\nexport default SortDropdown; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\Toolbar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/toolbar/Toolbar 组件。\\n */\\n\\nimport React, { useRef, useState } from 'react';\\nimport { useFileContext } from '../context/FileContext';\\nimport { X, Download, Edit, Move } from 'lucide-react';\\nimport { message } from 'antd';\\nimport styles from './Toolbar.module.css';\\nimport commonStyles from '../styles/common.module.css';\\n\\ninterface ToolbarProps {\\n  onUploadClick: () => void;\\n  onFolderUploadClick: () => void;\\n  onCreateFolderClick: () => void;\\n}\\n\\nexport function Toolbar({ onUploadClick, onFolderUploadClick, onCreateFolderClick }: ToolbarProps) {\\n  const {\\n    selectedFiles,\\n    clearSelection,\\n    files\\n  } = useFileContext();\\n\\n  const [showUploadDropdown, setShowUploadDropdown] = useState(false);\\n  const dropdownRef = useRef<HTMLDivElement>(null);\\n\\n  const handleDownload = () => {\\n    // TODO: 实现文件下载功能\\n    message.info('下载功能开发中');\\n  };\\n\\n  const handleRename = () => {\\n    if (selectedFiles.length !== 1) {\\n      message.warning('请选择一个文件进行重命名');\\n      return;\\n    }\\n    const selectedFile = files.find(file => file.id === selectedFiles[0]);\\n    if (selectedFile) {\\n      // TODO: 实现重命名功能\\n      message.info('重命名功能开发中');\\n    }\\n  };\\n\\n  return (\\n    <div className={styles.topBar}>\\n      <div className={styles.buttonGroup}>\\n        {selectedFiles.length > 0 ? (\\n          <>\\n            <button className={styles.topButton} onClick={() => clearSelection()}>\\n              <X className={commonStyles.icon} />\\n              取消选择\\n            </button>\\n            <button className={styles.topButton} onClick={handleDownload}>\\n              <Download className={commonStyles.icon} />\\n              下载\\n            </button>\\n            <button className={styles.topButton} onClick={handleRename}>\\n              <Edit className={commonStyles.icon} />\\n              重命名\\n            </button>\\n            <button className={styles.topButton}>\\n              <Move className={commonStyles.icon} />\\n              移动\\n            </button>\\n          </>\\n        ) : (\\n          <>\\n            <div className={styles.uploadDropdown} ref={dropdownRef}>\\n              <button\\n                className={styles.topButton}\\n                onClick={() => setShowUploadDropdown(!showUploadDropdown)}\\n              >\\n                <span className={styles.buttonIcon}>⬆️</span>\\n                上传\\n                <span className={styles.dropdownArrow}>▼</span>\\n              </button>\\n              {showUploadDropdown && (\\n                <div className={styles.dropdownMenu}>\\n                  <button\\n                    className={styles.dropdownItem}\\n                    onClick={() => {\\n                      onUploadClick();\\n                      setShowUploadDropdown(false);\\n                    }}\\n                  >\\n                    <span className={styles.buttonIcon}>📄</span>\\n                    上传文件\\n                  </button>\\n                  <button\\n                    className={styles.dropdownItem}\\n                    onClick={() => {\\n                      onFolderUploadClick();\\n                      setShowUploadDropdown(false);\\n                    }}\\n                  >\\n                    <span className={styles.buttonIcon}>📁</span>\\n                    上传文件夹\\n                  </button>\\n                </div>\\n              )}\\n            </div>\\n            <button\\n              className={styles.topButton}\\n              onClick={onCreateFolderClick}\\n            >\\n              <span className={styles.buttonIcon}>📁</span>\\n              新建文件夹\\n            </button>\\n          </>\\n        )}\\n      </div>\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\TopActionBar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/actionBar/TopActionBar 组件。\\n */\\n\\nimport React from 'react';\\nimport { \\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \\n} from 'lucide-react';\\nimport styles from '../styles/shared.module.css';\\nimport SortDropdown from './SortDropdown';\\nimport { UploadButton } from '../components/shared';\\nimport { FileSortInterface } from '@/app/types';\\n\\ninterface TopActionBarProps {\\n  selectedFiles: string[];\\n  onClearSelection: () => void;\\n  onDownload: () => void;\\n  onRename: () => void;\\n  onMove: () => void;\\n  onDelete: () => void;\\n  onClearFilter: () => void;\\n  onCreateFolder: () => void;\\n  selectedFileType: string | null;\\n  showSearchView: boolean;\\n  isInRootFolder: boolean;\\n  sortOrder: FileSortInterface;\\n  setSortOrder: (order: FileSortInterface) => void;\\n  showUploadDropdown: boolean;\\n  setShowUploadDropdown: (show: boolean) => void;\\n  setIsUploadModalOpen: (open: boolean) => void;\\n  setIsFolderUploadModalOpen: (open: boolean) => void;\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\n}\\n\\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\\n  selectedFiles,\\n  onClearSelection,\\n  onDownload,\\n  onRename,\\n  onMove,\\n  onDelete,\\n  onClearFilter,\\n  onCreateFolder,\\n  selectedFileType,\\n  showSearchView,\\n  isInRootFolder,\\n  sortOrder,\\n  setSortOrder,\\n  showUploadDropdown,\\n  setShowUploadDropdown,\\n  setIsUploadModalOpen,\\n  setIsFolderUploadModalOpen,\\n  uploadDropdownRef\\n}) => {\\n  return (\\n    <div className={styles.topBar}>\\n      <div className={styles.buttonGroup}>\\n        {selectedFiles.length > 0 ? (\\n          <>\\n            <button className={styles.topButton} onClick={onClearSelection}>\\n              <X className=\\\"w-4 h-4\\\" />\\n              取消选择\\n            </button>\\n            <button className={styles.topButton} onClick={onDownload}>\\n              <Download className=\\\"w-4 h-4\\\" />\\n              下载\\n            </button>\\n            <button \\n              className={styles.topButton}\\n              onClick={onRename}\\n            >\\n              <Edit className=\\\"w-4 h-4\\\" />\\n              重命名\\n            </button>\\n            <button className={styles.topButton} onClick={onMove}>\\n              <Move className=\\\"w-4 h-4\\\" />\\n              移动\\n            </button>\\n            <button className={styles.topButton} onClick={onDelete}>\\n              <Trash2 className=\\\"w-4 h-4\\\" />\\n              删除\\n            </button>\\n          </>\\n        ) : (\\n          <>\\n            <button \\n              className={styles.topButton}\\n              onClick={onClearFilter}\\n              disabled={isInRootFolder}\\n            >\\n              <span>📁</span>\\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\\n            </button>\\n\\n            {/* 添加当前过滤状态指示器 */}\\n            {selectedFileType && (\\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\\n                {(() => {\\n                  switch(selectedFileType) {\\n                    case 'image': return <ImageIcon className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'document': return <FileText className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'video': return <Video className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'audio': return <Music className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'other': return <File className=\\\"w-4 h-4 mr-2\\\" />;\\n                    default: return null;\\n                  }\\n                })()}\\n                当前浏览：\\n                {selectedFileType === 'image' && '仅图片'}\\n                {selectedFileType === 'document' && '仅文档'}\\n                {selectedFileType === 'video' && '仅视频'}\\n                {selectedFileType === 'audio' && '仅音频'}\\n                {selectedFileType === 'other' && '其他文件'}\\n              </div>\\n            )}\\n\\n            {/* 排序下拉菜单 */}\\n            <SortDropdown \\n              sortOrder={sortOrder}\\n              onSortChange={setSortOrder}\\n            />\\n            \\n            {/* 上传按钮 */}\\n            <UploadButton \\n              showDropdown={showUploadDropdown}\\n              setShowDropdown={setShowUploadDropdown}\\n              setIsModalOpen={setIsUploadModalOpen}\\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\\n              uploadDropdownRef={uploadDropdownRef}\\n            />\\n            \\n            <button \\n              className={styles.folderButton} \\n              onClick={onCreateFolder}\\n            >\\n              <FolderUp className=\\\"w-4 h-4 mr-2\\\" />\\n              新建文件夹\\n            </button>\\n          </>\\n        )}\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default TopActionBar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\upload\\\\UploadModal\\\\UploadModal.tsx\",\n    \"newContent\": \"'use client';\\r\\n\\r\\nimport React, { useState, useRef, useEffect } from 'react';\\r\\nimport { Modal, Button, Space, Tag, Input, message, Progress } from 'antd';\\r\\nimport { UploadOutlined, FolderOutlined } from '@ant-design/icons';\\r\\nimport { UploadModalProps } from '@/app/types/domains/file-management';\\r\\nimport { FileTreeNode } from '@/app/types/domains/fileTypes';\\r\\nimport { formatFileSize } from '@/app/lib/utils/file';\\r\\nimport { uploadFile, uploadFolder, processSelectedFiles } from '@/app/lib/uploadService';\\r\\n\\r\\n// 构建文件树节点\\r\\nfunction createFileTreeNode(name: string, type: 'file' | 'folder', size: number = 0, file?: File): FileTreeNode {\\r\\n  return {\\r\\n    name,\\r\\n    type,\\r\\n    size,\\r\\n    children: type === 'folder' ? [] : undefined,\\r\\n    file: file as any\\r\\n  };\\r\\n}\\r\\n\\r\\n// 更新文件夹大小\\r\\nfunction updateFolderSize(node: FileTreeNode, fileSize: number) {\\r\\n  let currentNode = node;\\r\\n  while (currentNode) {\\r\\n    currentNode.size += fileSize;\\r\\n    currentNode = currentNode.children?.find(child => \\r\\n      child.type === 'folder'\\r\\n    ) as FileTreeNode;\\r\\n  }\\r\\n}\\r\\n\\r\\n// 构建文件树结构\\r\\nfunction buildFileTree(files: File[], rootName: string): FileTreeNode {\\r\\n  const root = createFileTreeNode(rootName, 'folder');\\r\\n  \\r\\n  files.forEach(file => {\\r\\n    const paths = (file as any).webkitRelativePath.split('/');\\r\\n    let currentNode = root;\\r\\n    \\r\\n    for (let i = 1; i < paths.length; i++) {\\r\\n      const pathPart = paths[i];\\r\\n      const isFile = i === paths.length - 1;\\r\\n\\r\\n      if (isFile) {\\r\\n        const fileNode = createFileTreeNode(pathPart, 'file', file.size, file);\\r\\n        currentNode.children?.push(fileNode);\\r\\n        updateFolderSize(currentNode, file.size);\\r\\n      } else {\\r\\n        let folderNode = currentNode.children?.find(\\r\\n          child => child.name === pathPart && child.type === 'folder'\\r\\n        );\\r\\n        \\r\\n        if (!folderNode) {\\r\\n          folderNode = createFileTreeNode(pathPart, 'folder');\\r\\n          currentNode.children?.push(folderNode);\\r\\n        }\\r\\n        currentNode = folderNode;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  return root;\\r\\n}\\r\\n\\r\\n/**\\r\\n * 文件上传模态框组件\\r\\n * 支持文件或文件夹上传，提供拖放和选择界面\\r\\n */\\r\\nconst UploadModal: React.FC<UploadModalProps> = ({\\r\\n  isOpen,\\r\\n  onClose,\\r\\n  onUploadSuccess,\\r\\n  currentFolderId,\\r\\n  isFolderUpload,\\r\\n  withTags\\r\\n}) => {\\r\\n  const [isDragging, setIsDragging] = useState(false);\\r\\n  const [files, setFiles] = useState<File[]>([]);\\r\\n  const [isUploading, setIsUploading] = useState(false);\\r\\n  const [uploadProgress, setUploadProgress] = useState(0);\\r\\n  const [tags, setTags] = useState<string[]>([]);\\r\\n  const [tagInput, setTagInput] = useState('');\\r\\n  const [folderName, setFolderName] = useState<string | null>(null);\\r\\n  const [fileTree, setFileTree] = useState<FileTreeNode | null>(null);\\r\\n  const fileInputRef = useRef<HTMLInputElement>(null);\\r\\n\\r\\n  // 重置所有状态\\r\\n  const resetState = () => {\\r\\n    setFiles([]);\\r\\n    setIsDragging(false);\\r\\n    setTags([]);\\r\\n    setTagInput('');\\r\\n    setFolderName(null);\\r\\n    setFileTree(null);\\r\\n    setUploadProgress(0);\\r\\n  };\\r\\n\\r\\n  // 监听 isOpen 变化，当弹窗关闭时重置状态\\r\\n  useEffect(() => {\\r\\n    if (!isOpen) {\\r\\n      resetState();\\r\\n    }\\r\\n  }, [isOpen]);\\r\\n\\r\\n  const handleClose = () => {\\r\\n    resetState();\\r\\n    onClose();\\r\\n  };\\r\\n\\r\\n  const handleDragOver = (e: React.DragEvent) => {\\r\\n    e.preventDefault();\\r\\n    setIsDragging(true);\\r\\n  };\\r\\n\\r\\n  const handleDragLeave = () => {\\r\\n    setIsDragging(false);\\r\\n  };\\r\\n\\r\\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\\r\\n    e.preventDefault();\\r\\n    setIsDragging(false);\\r\\n    \\r\\n    const droppedFiles = Array.from(e.dataTransfer.files);\\r\\n    if (droppedFiles.length > 0) {\\r\\n      const { files: processedFiles, folderName } = processSelectedFiles(droppedFiles, isFolderUpload);\\r\\n      setFiles(processedFiles);\\r\\n      setFolderName(folderName);\\r\\n      \\r\\n      if (isFolderUpload && folderName) {\\r\\n        setFileTree(buildFileTree(processedFiles, folderName));\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\\r\\n    const selectedFiles = Array.from(e.target.files || []);\\r\\n    if (selectedFiles.length > 0) {\\r\\n      const { files: processedFiles, folderName } = processSelectedFiles(selectedFiles, isFolderUpload);\\r\\n      setFiles(processedFiles);\\r\\n      setFolderName(folderName);\\r\\n      \\r\\n      if (isFolderUpload && folderName) {\\r\\n        setFileTree(buildFileTree(processedFiles, folderName));\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const removeFile = (fileName: string) => {\\r\\n    setFiles(prev => prev.filter(file => file.name !== fileName));\\r\\n  };\\r\\n\\r\\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\\r\\n    if (e.key === 'Enter' && tagInput.trim()) {\\r\\n      e.preventDefault();\\r\\n      const newTag = tagInput.trim();\\r\\n      if (!tags.includes(newTag)) {\\r\\n        setTags([...tags, newTag]);\\r\\n      }\\r\\n      setTagInput('');\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const removeTag = (tagToRemove: string) => {\\r\\n    setTags(tags.filter(tag => tag !== tagToRemove));\\r\\n  };\\r\\n\\r\\n  // 递归渲染文件树组件\\r\\n  const renderFileTree = (node: FileTreeNode, level: number = 0) => {\\r\\n    return (\\r\\n      <div key={node.name} style={{ marginLeft: `${level * 20}px` }}>\\r\\n        <div className=\\\"file-item\\\">\\r\\n          <div className=\\\"file-info\\\">\\r\\n            <span className=\\\"file-type-icon\\\">\\r\\n              {node.type === 'folder' ? '📁' : \\r\\n               node.file?.type.startsWith('image/') ? '🖼️' :\\r\\n               node.file?.type.includes('pdf') ? '📄' :\\r\\n               node.file?.type.includes('word') ? '📝' :\\r\\n               '📄'}\\r\\n            </span>\\r\\n            <div>\\r\\n              <p className=\\\"file-name\\\">{node.name}</p>\\r\\n              <p className=\\\"file-size\\\">\\r\\n                {formatFileSize(node.size)}\\r\\n                {node.type === 'folder' && ` (${node.children?.length || 0} 个文件)`}\\r\\n              </p>\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n        {node.children && node.children.length > 0 && (\\r\\n          <div className=\\\"file-children\\\">\\r\\n            {node.children.map(child => renderFileTree(child, level + 1))}\\r\\n          </div>\\r\\n        )}\\r\\n      </div>\\r\\n    );\\r\\n  };\\r\\n\\r\\n  // 上传处理函数\\r\\n  const handleUpload = async () => {\\r\\n    if (files.length === 0) return;\\r\\n    \\r\\n    setIsUploading(true);\\r\\n    setUploadProgress(0);\\r\\n    \\r\\n    try {\\r\\n      // 处理文件夹上传\\r\\n      if (isFolderUpload && folderName) {\\r\\n        await uploadFolder(files, folderName, {\\r\\n          folderId: currentFolderId || undefined,\\r\\n          tags,\\r\\n          onProgress: (progress) => {\\r\\n            setUploadProgress(progress);\\r\\n          },\\r\\n          onSuccess: (response) => {\\r\\n            message.success(`文件夹 \\\"${folderName}\\\" 上传成功`);\\r\\n            setIsUploading(false);\\r\\n            onUploadSuccess();\\r\\n            handleClose();\\r\\n          },\\r\\n          onError: (error) => {\\r\\n            message.error(`上传失败: ${error.message}`);\\r\\n            setIsUploading(false);\\r\\n          }\\r\\n        });\\r\\n      } else {\\r\\n        // 单文件或多文件上传\\r\\n        let uploadedCount = 0;\\r\\n        const totalFiles = files.length;\\r\\n        \\r\\n        for (const file of files) {\\r\\n          await uploadFile(file, {\\r\\n            folderId: currentFolderId || undefined,\\r\\n            tags,\\r\\n            onProgress: (fileProgress) => {\\r\\n              // 计算总体进度：已完成文件 + 当前文件进度\\r\\n              const totalProgress = Math.round(\\r\\n                (uploadedCount * 100 + fileProgress) / totalFiles\\r\\n              );\\r\\n              setUploadProgress(totalProgress);\\r\\n            },\\r\\n            onSuccess: () => {\\r\\n              uploadedCount++;\\r\\n              \\r\\n              // 所有文件上传完成\\r\\n              if (uploadedCount === totalFiles) {\\r\\n                message.success(totalFiles > 1 \\r\\n                  ? `${totalFiles}个文件上传成功` \\r\\n                  : '文件上传成功');\\r\\n                \\r\\n                setIsUploading(false);\\r\\n                onUploadSuccess();\\r\\n                handleClose();\\r\\n              }\\r\\n            },\\r\\n            onError: (error) => {\\r\\n              message.error(`文件上传失败: ${error.message}`);\\r\\n              setIsUploading(false);\\r\\n            }\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    } catch (error) {\\r\\n      const errorMessage = error instanceof Error ? error.message : '上传失败';\\r\\n      message.error(errorMessage);\\r\\n      setIsUploading(false);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <Modal\\r\\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\\r\\n      open={isOpen}\\r\\n      onCancel={handleClose}\\r\\n      footer={[\\r\\n        <Button key=\\\"cancel\\\" onClick={handleClose} disabled={isUploading}>\\r\\n          取消\\r\\n        </Button>,\\r\\n        <Button \\r\\n          key=\\\"upload\\\" \\r\\n          type=\\\"primary\\\" \\r\\n          onClick={handleUpload} \\r\\n          disabled={files.length === 0 || isUploading}\\r\\n          loading={isUploading}\\r\\n        >\\r\\n          上传\\r\\n        </Button>,\\r\\n      ]}\\r\\n      width={800}\\r\\n    >\\r\\n      {isUploading ? (\\r\\n        <div className=\\\"text-center py-8\\\">\\r\\n          <div className=\\\"my-4\\\">\\r\\n            <Progress percent={uploadProgress} status=\\\"active\\\" />\\r\\n            <div className=\\\"mt-2\\\">{`上传中...${uploadProgress}%`}</div>\\r\\n          </div>\\r\\n        </div>\\r\\n      ) : (\\r\\n        <div className=\\\"upload-content\\\">\\r\\n          {/* 拖放区域 */}\\r\\n          <div\\r\\n            onDragOver={handleDragOver}\\r\\n            onDragLeave={handleDragLeave}\\r\\n            onDrop={handleDrop}\\r\\n            className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${\\r\\n              isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-500'\\r\\n            }`}\\r\\n          >\\r\\n            <div className=\\\"upload-icon mb-4\\\">\\r\\n              {isFolderUpload ? <FolderOutlined style={{ fontSize: 48 }} /> : <UploadOutlined style={{ fontSize: 48 }} />}\\r\\n            </div>\\r\\n            <p className=\\\"text-lg mb-2\\\">\\r\\n              {isDragging\\r\\n                ? isFolderUpload\\r\\n                  ? '放开以上传文件夹'\\r\\n                  : '放开以上传文件'\\r\\n                : isFolderUpload\\r\\n                ? '拖放文件夹至此处，或'\\r\\n                : '拖放文件至此处，或'}\\r\\n            </p>\\r\\n            <Button\\r\\n              onClick={() => fileInputRef.current?.click()}\\r\\n              type=\\\"primary\\\"\\r\\n              icon={isFolderUpload ? <FolderOutlined /> : <UploadOutlined />}\\r\\n            >\\r\\n              {isFolderUpload ? '选择文件夹' : '选择文件'}\\r\\n            </Button>\\r\\n            <input\\r\\n              ref={fileInputRef}\\r\\n              type=\\\"file\\\"\\r\\n              multiple={!isFolderUpload}\\r\\n              style={{ display: 'none' }}\\r\\n              onChange={handleFileSelect}\\r\\n              {...(isFolderUpload ? { webkitdirectory: \\\"\\\", directory: \\\"\\\" } : {})}\\r\\n            />\\r\\n          </div>\\r\\n\\r\\n          {/* 标签输入区域 */}\\r\\n          {withTags && (\\r\\n            <div className=\\\"tags-section mt-6\\\">\\r\\n              <h4 className=\\\"text-base font-medium mb-2\\\">添加标签</h4>\\r\\n              <div className=\\\"tag-input\\\">\\r\\n                <Input\\r\\n                  placeholder=\\\"输入标签并按Enter添加\\\"\\r\\n                  value={tagInput}\\r\\n                  onChange={(e) => setTagInput(e.target.value)}\\r\\n                  onKeyDown={handleTagInputKeyDown}\\r\\n                />\\r\\n              </div>\\r\\n              {tags.length > 0 && (\\r\\n                <div className=\\\"tags-list mt-2 flex flex-wrap gap-1\\\">\\r\\n                  {tags.map((tag) => (\\r\\n                    <Tag\\r\\n                      key={tag}\\r\\n                      closable\\r\\n                      onClose={() => removeTag(tag)}\\r\\n                    >\\r\\n                      {tag}\\r\\n                    </Tag>\\r\\n                  ))}\\r\\n                </div>\\r\\n              )}\\r\\n            </div>\\r\\n          )}\\r\\n\\r\\n          {/* 文件列表或文件树 */}\\r\\n          {files.length > 0 && (\\r\\n            <div className=\\\"file-list mt-6\\\">\\r\\n              <h4 className=\\\"text-base font-medium mb-2\\\">\\r\\n                {isFolderUpload \\r\\n                  ? `文件夹: ${folderName} (${files.length}个文件)` \\r\\n                  : `选择的文件 (${files.length})`}\\r\\n              </h4>\\r\\n              \\r\\n              {isFolderUpload && fileTree ? (\\r\\n                <div className=\\\"folder-tree border rounded p-3\\\">\\r\\n                  {renderFileTree(fileTree)}\\r\\n                </div>\\r\\n              ) : (\\r\\n                <div className=\\\"file-items space-y-2\\\">\\r\\n                  {files.map((file) => (\\r\\n                    <div\\r\\n                      key={file.name}\\r\\n                      className=\\\"file-item flex justify-between items-center border rounded p-2\\\"\\r\\n                    >\\r\\n                      <div className=\\\"file-details flex items-center\\\">\\r\\n                        <span className=\\\"file-icon mr-2\\\">\\r\\n                          {file.type.startsWith('image/') ? '🖼️' :\\r\\n                           file.type.includes('pdf') ? '📄' :\\r\\n                           file.type.includes('word') ? '📝' :\\r\\n                           '📄'}\\r\\n                        </span>\\r\\n                        <div>\\r\\n                          <div className=\\\"file-name font-medium\\\">{file.name}</div>\\r\\n                          <div className=\\\"file-meta text-xs text-gray-500\\\">\\r\\n                            {formatFileSize(file.size)}\\r\\n                          </div>\\r\\n                        </div>\\r\\n                      </div>\\r\\n                      <Button\\r\\n                        type=\\\"text\\\"\\r\\n                        size=\\\"small\\\"\\r\\n                        danger\\r\\n                        onClick={() => removeFile(file.name)}\\r\\n                      >\\r\\n                        移除\\r\\n                      </Button>\\r\\n                    </div>\\r\\n                  ))}\\r\\n                </div>\\r\\n              )}\\r\\n            </div>\\r\\n          )}\\r\\n        </div>\\r\\n      )}\\r\\n    </Modal>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default UploadModal; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\actionBar\\\\TopActionBar\\\\TopActionBar.tsx\",\n    \"newContent\": \"import React from 'react';\\r\\nimport { \\r\\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \\r\\n} from 'lucide-react';\\r\\nimport styles from '@/app/file-management/styles/shared.module.css';\\r\\nimport { SortDropdown } from '@/app/components/features/file-management/actionBar/SortDropdown';\\r\\nimport { UploadButton } from '@/app/components/features/file-management/upload/UploadButton';\\r\\nimport { FileSortInterface } from '@/app/types';\\r\\n\\r\\ninterface TopActionBarProps {\\r\\n  selectedFiles: string[];\\r\\n  onClearSelection: () => void;\\r\\n  onDownload: () => void;\\r\\n  onRename: () => void;\\r\\n  onMove: () => void;\\r\\n  onDelete: () => void;\\r\\n  onClearFilter: () => void;\\r\\n  onCreateFolder: () => void;\\r\\n  selectedFileType: string | null;\\r\\n  showSearchView: boolean;\\r\\n  isInRootFolder: boolean;\\r\\n  sortOrder: FileSortInterface;\\r\\n  setSortOrder: (order: FileSortInterface) => void;\\r\\n  showUploadDropdown: boolean;\\r\\n  setShowUploadDropdown: (show: boolean) => void;\\r\\n  setIsUploadModalOpen: (open: boolean) => void;\\r\\n  setIsFolderUploadModalOpen: (open: boolean) => void;\\r\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\r\\n}\\r\\n\\r\\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\\r\\n  selectedFiles,\\r\\n  onClearSelection,\\r\\n  onDownload,\\r\\n  onRename,\\r\\n  onMove,\\r\\n  onDelete,\\r\\n  onClearFilter,\\r\\n  onCreateFolder,\\r\\n  selectedFileType,\\r\\n  showSearchView,\\r\\n  isInRootFolder,\\r\\n  sortOrder,\\r\\n  setSortOrder,\\r\\n  showUploadDropdown,\\r\\n  setShowUploadDropdown,\\r\\n  setIsUploadModalOpen,\\r\\n  setIsFolderUploadModalOpen,\\r\\n  uploadDropdownRef\\r\\n}) => {\\r\\n  return (\\r\\n    <div className={styles.topBar}>\\r\\n      <div className={styles.buttonGroup}>\\r\\n        {selectedFiles.length > 0 ? (\\r\\n          <>\\r\\n            <button className={styles.topButton} onClick={onClearSelection}>\\r\\n              <X className=\\\"w-4 h-4\\\" />\\r\\n              取消选择\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onDownload}>\\r\\n              <Download className=\\\"w-4 h-4\\\" />\\r\\n              下载\\r\\n            </button>\\r\\n            <button \\r\\n              className={styles.topButton}\\r\\n              onClick={onRename}\\r\\n            >\\r\\n              <Edit className=\\\"w-4 h-4\\\" />\\r\\n              重命名\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onMove}>\\r\\n              <Move className=\\\"w-4 h-4\\\" />\\r\\n              移动\\r\\n            </button>\\r\\n            <button className={styles.topButton} onClick={onDelete}>\\r\\n              <Trash2 className=\\\"w-4 h-4\\\" />\\r\\n              删除\\r\\n            </button>\\r\\n          </>\\r\\n        ) : (\\r\\n          <>\\r\\n            <button \\r\\n              className={styles.topButton}\\r\\n              onClick={onClearFilter}\\r\\n              disabled={isInRootFolder}\\r\\n            >\\r\\n              <span>📁</span>\\r\\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\\r\\n            </button>\\r\\n\\r\\n            {/* 添加当前过滤状态指示器 */}\\r\\n            {selectedFileType && (\\r\\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\\r\\n                {(() => {\\r\\n                  switch(selectedFileType) {\\r\\n                    case 'image': return <ImageIcon className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'document': return <FileText className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'video': return <Video className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'audio': return <Music className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    case 'other': return <File className=\\\"w-4 h-4 mr-2\\\" />;\\r\\n                    default: return null;\\r\\n                  }\\r\\n                })()}\\r\\n                当前浏览：\\r\\n                {selectedFileType === 'image' && '仅图片'}\\r\\n                {selectedFileType === 'document' && '仅文档'}\\r\\n                {selectedFileType === 'video' && '仅视频'}\\r\\n                {selectedFileType === 'audio' && '仅音频'}\\r\\n                {selectedFileType === 'other' && '其他文件'}\\r\\n              </div>\\r\\n            )}\\r\\n\\r\\n            {/* 排序下拉菜单 */}\\r\\n            <SortDropdown \\r\\n              sortOrder={sortOrder}\\r\\n              onSortChange={setSortOrder}\\r\\n            />\\r\\n            \\r\\n            {/* 上传按钮 */}\\r\\n            <UploadButton \\r\\n              showDropdown={showUploadDropdown}\\r\\n              setShowDropdown={setShowUploadDropdown}\\r\\n              setIsModalOpen={setIsUploadModalOpen}\\r\\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\\r\\n              uploadDropdownRef={uploadDropdownRef}\\r\\n            />\\r\\n            \\r\\n            <button \\r\\n              className={styles.folderButton} \\r\\n              onClick={onCreateFolder}\\r\\n            >\\r\\n              <FolderUp className=\\\"w-4 h-4 mr-2\\\" />\\r\\n              新建文件夹\\r\\n            </button>\\r\\n          </>\\r\\n        )}\\r\\n      </div>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default TopActionBar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\MiniSidebar.tsx\",\n    \"newContent\": \"/**\\r\\n * @deprecated 此组件已迁移到新的组件架构中。\\r\\n * 请使用 @/app/components/features/file-management/navigation/MiniSidebar 组件。\\r\\n */\\r\\n\\r\\nimport React from 'react';\\r\\nimport Image from 'next/image';\\r\\nimport { Home, LogOut, Palette } from 'lucide-react';\\r\\nimport styles from '../styles/shared.module.css';\\r\\n\\r\\ninterface MiniSidebarProps {\\r\\n  avatarUrl: string | null;\\r\\n  userName: string | null;\\r\\n  userEmail: string | null;\\r\\n  onHomeClick: () => void;\\r\\n  onLogoutClick: () => void;\\r\\n  onAvatarClick: () => void;\\r\\n  currentTheme?: string | null;\\r\\n  onThemeClick: () => void;\\r\\n}\\r\\n\\r\\nconst MiniSidebar: React.FC<MiniSidebarProps> = ({\\r\\n  avatarUrl,\\r\\n  userName,\\r\\n  userEmail,\\r\\n  onHomeClick,\\r\\n  onLogoutClick,\\r\\n  onAvatarClick,\\r\\n  currentTheme = 'default',\\r\\n  onThemeClick\\r\\n}) => {\\r\\n  return (\\r\\n    <div className={styles.miniSidebar}>\\r\\n      <div className={styles.patternOverlay}></div>\\r\\n      <div className={styles.avatarContainer}>\\r\\n        <button \\r\\n          className={styles.miniSidebarButton}\\r\\n          onClick={onAvatarClick}\\r\\n        >\\r\\n          {avatarUrl ? (\\r\\n            <Image\\r\\n              src={`${avatarUrl}?t=${Date.now()}`}\\r\\n              alt=\\\"用户头像\\\"\\r\\n              width={38}\\r\\n              height={38}\\r\\n              className=\\\"rounded-full ring-1 ring-white/50 transition-all duration-300 hover:ring-2\\\"\\r\\n            />\\r\\n          ) : (\\r\\n            <div \\r\\n              className={styles.avatarPlaceholder}\\r\\n              style={{ width: '38px', height: '38px', fontSize: '16px' }}\\r\\n            >\\r\\n              {userName?.[0]?.toUpperCase() || userEmail?.[0]?.toUpperCase() || '?'}\\r\\n            </div>\\r\\n          )}\\r\\n        </button>\\r\\n      </div>\\r\\n      <div className={styles.miniSidebarDivider}></div>\\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onHomeClick}\\r\\n      >\\r\\n        <Home className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n      \\r\\n      {/* 主题选择按钮 */}\\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onThemeClick}\\r\\n        title=\\\"主题设置\\\"\\r\\n      >\\r\\n        <Palette className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n      \\r\\n      <button \\r\\n        className={styles.miniSidebarButton}\\r\\n        onClick={onLogoutClick}\\r\\n      >\\r\\n        <LogOut className=\\\"w-5 h-5 text-white\\\" />\\r\\n      </button>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default MiniSidebar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\NewFolderForm.tsx\",\n    \"newContent\": \"/**\\r\\n * @deprecated 此组件已迁移到新的组件架构中。\\r\\n * 请使用 @/app/components/features/file-management/folderManagement/NewFolderForm 组件。\\r\\n */\\r\\n\\r\\nimport React, { useRef, useState, useEffect } from 'react';\\r\\nimport { Folder, AlertCircle } from 'lucide-react';\\r\\nimport styles from '../styles/shared.module.css';\\r\\n\\r\\ninterface NewFolderFormProps {\\r\\n  folderName: string;\\r\\n  setFolderName: (name: string) => void;\\r\\n  folderTags: string[];\\r\\n  setFolderTags: (tags: string[]) => void;\\r\\n  onCreateFolder: () => void;\\r\\n  onCancel: () => void;\\r\\n}\\r\\n\\r\\nconst NewFolderForm: React.FC<NewFolderFormProps> = ({\\r\\n  folderName,\\r\\n  setFolderName,\\r\\n  folderTags,\\r\\n  setFolderTags,\\r\\n  onCreateFolder,\\r\\n  onCancel\\r\\n}) => {\\r\\n  const [newTag, setNewTag] = useState('');\\r\\n  const [nameError, setNameError] = useState<string | null>(null);\\r\\n  const inputRef = useRef<HTMLInputElement>(null);\\r\\n\\r\\n  // 检查文件夹名称是否有效\\r\\n  useEffect(() => {\\r\\n    const trimmedName = folderName.trim();\\r\\n    \\r\\n    if (trimmedName === '') {\\r\\n      setNameError(null); // 空名称不显示错误，但创建按钮会处理\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // 检查特殊字符\\r\\n    const invalidChars = /[\\\\/\\\\\\\\:*?\\\"<>|]/;\\r\\n    if (invalidChars.test(trimmedName)) {\\r\\n      setNameError('文件夹名称不能包含下列字符: / \\\\\\\\ : * ? \\\" < > |');\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    setNameError(null);\\r\\n  }, [folderName]);\\r\\n\\r\\n  // 处理回车键创建文件夹\\r\\n  const handleKeyDown = (e: React.KeyboardEvent) => {\\r\\n    if (e.key === 'Enter' && !nameError && folderName.trim()) {\\r\\n      onCreateFolder();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <div className={`${styles.newFolderRow} p-4 border border-gray-200 rounded-lg bg-white shadow-sm mb-4`}>\\r\\n      <div className={`${styles.newFolderForm} flex flex-col space-y-4`}>\\r\\n        <div className={`flex items-center`}>\\r\\n          <Folder className=\\\"w-6 h-6 text-blue-500 flex-shrink-0 mr-3\\\" />\\r\\n          <div className={`${styles.newFolderNameContainer} flex-grow relative`}>\\r\\n            <input\\r\\n              type=\\\"text\\\"\\r\\n              ref={inputRef}\\r\\n              className={`${styles.newFolderInput} h-10 px-3 rounded-md border ${nameError ? 'border-red-500' : 'border-gray-300'} w-full text-base`}\\r\\n              value={folderName}\\r\\n              onChange={(e) => setFolderName(e.target.value)}\\r\\n              placeholder=\\\"新文件夹名称\\\"\\r\\n              autoFocus\\r\\n              onKeyDown={handleKeyDown}\\r\\n            />\\r\\n            {nameError && (\\r\\n              <div className=\\\"text-red-500 text-xs mt-1 flex items-center\\\">\\r\\n                <AlertCircle className=\\\"w-3 h-3 mr-1\\\" />\\r\\n                <span>{nameError}</span>\\r\\n              </div>\\r\\n            )}\\r\\n            {!nameError && (\\r\\n              <div className=\\\"text-gray-500 text-xs mt-1\\\">\\r\\n                相同目录下不能存在同名文件夹\\r\\n              </div>\\r\\n            )}\\r\\n          </div>\\r\\n        </div>\\r\\n        \\r\\n        <div className={`${styles.newFolderTagsContainer} ml-9`}>\\r\\n          <label className=\\\"block text-sm font-medium text-gray-700 mb-1\\\">添加标签</label>\\r\\n          <div className={`${styles.tagsWrapper} h-10 flex items-center flex-wrap gap-2 border border-gray-300 rounded-md px-3 py-1 overflow-y-auto`}>\\r\\n            {folderTags.map((tag, index) => (\\r\\n              <div key={index} className={`${styles.tagItem} h-7 flex items-center bg-blue-100 text-blue-800 px-2 rounded-md`}>\\r\\n                <span className=\\\"text-sm\\\">{tag}</span>\\r\\n                <button\\r\\n                  className={`${styles.removeTagButton} ml-1 text-blue-600 hover:text-blue-800 w-5 h-5 flex items-center justify-center rounded-full hover:bg-blue-200`}\\r\\n                  onClick={() => {\\r\\n                    const updatedTags = [...folderTags];\\r\\n                    updatedTags.splice(index, 1);\\r\\n                    setFolderTags(updatedTags);\\r\\n                  }}\\r\\n                >\\r\\n                  ×\\r\\n                </button>\\r\\n              </div>\\r\\n            ))}\\r\\n            <input\\r\\n              type=\\\"text\\\"\\r\\n              className={`${styles.tagInput} flex-grow h-7 border-0 outline-none text-sm bg-transparent`}\\r\\n              value={newTag}\\r\\n              onChange={(e) => setNewTag(e.target.value)}\\r\\n              onKeyDown={(e) => {\\r\\n                if (e.key === 'Enter' && newTag.trim()) {\\r\\n                  setFolderTags([...folderTags, newTag.trim()]);\\r\\n                  setNewTag('');\\r\\n                  e.preventDefault();\\r\\n                }\\r\\n              }}\\r\\n              placeholder=\\\"添加标签...\\\"\\r\\n            />\\r\\n          </div>\\r\\n        </div>\\r\\n        \\r\\n        <div className={`${styles.newFolderActions} flex items-center gap-3 ml-9`}>\\r\\n          <button \\r\\n            className={`${styles.confirmButton} h-10 px-4 ${nameError || !folderName.trim() ? 'bg-blue-300 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white rounded-md flex items-center justify-center`}\\r\\n            onClick={onCreateFolder}\\r\\n            disabled={!!nameError || !folderName.trim()}\\r\\n          >\\r\\n            创建\\r\\n          </button>\\r\\n          <button \\r\\n            className={`${styles.cancelButton} h-10 px-4 bg-gray-100 hover:bg-gray-200 text-gray-800 rounded-md flex items-center justify-center border border-gray-300`}\\r\\n            onClick={onCancel}\\r\\n          >\\r\\n            取消\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default NewFolderForm; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\RenameModal\\\\index.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/fileOperations/RenameModal 组件。\\n */\\n\\nimport React, { useState, useEffect, useRef } from 'react';\\nimport styles from '@/app/shared/themes/components/renameModal.module.css';\\nimport { CloseOutlined, TagOutlined, PlusOutlined } from '@ant-design/icons';\\n\\ninterface RenameModalProps {\\n  isOpen: boolean;\\n  onClose: () => void;\\n  onRename: (newName: string, tags?: string[]) => void;\\n  initialName: string;\\n  initialTags?: string[];\\n  fileType: 'file' | 'folder';\\n}\\n\\nconst RenameModal: React.FC<RenameModalProps> = ({\\n  isOpen,\\n  onClose,\\n  onRename,\\n  initialName,\\n  initialTags = [],\\n  fileType\\n}) => {\\n  const [newName, setNewName] = useState(initialName);\\n  const [tags, setTags] = useState<string[]>(initialTags);\\n  const [tagInput, setTagInput] = useState('');\\n  \\n  const inputRef = useRef<HTMLInputElement>(null);\\n  const tagInputRef = useRef<HTMLInputElement>(null);\\n  const modalRef = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    setNewName(initialName);\\n    // 确保初始标签不包含重复项\\n    setTags(Array.from(new Set(initialTags)));\\n  }, [initialName, initialTags]);\\n\\n  useEffect(() => {\\n    if (isOpen && inputRef.current) {\\n      // 自动聚焦输入框并选中文件名（不包括扩展名）\\n      inputRef.current.focus();\\n      \\n      const extension = fileType === 'file' ? initialName.lastIndexOf('.') : -1;\\n      if (extension !== -1) {\\n        inputRef.current.setSelectionRange(0, extension);\\n      } else {\\n        inputRef.current.select();\\n      }\\n    }\\n  }, [isOpen, initialName, fileType]);\\n\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (modalRef.current && !modalRef.current.contains(event.target as Node)) {\\n        onClose();\\n      }\\n    };\\n\\n    if (isOpen) {\\n      document.addEventListener('mousedown', handleClickOutside);\\n    }\\n    \\n    return () => {\\n      document.removeEventListener('mousedown', handleClickOutside);\\n    };\\n  }, [isOpen, onClose]);\\n\\n  const handleSubmit = (e: React.FormEvent) => {\\n    e.preventDefault();\\n    // 首先确保新名称是有效的非空字符串\\n    if (newName && typeof newName === 'string' && newName.trim() && \\n        (newName !== initialName || JSON.stringify(tags) !== JSON.stringify(initialTags))) {\\n      onRename(newName, tags);\\n    } else if (!newName || !newName.trim()) {\\n      // 如果名称为空，显示错误信息但不关闭模态框\\n      return;\\n    }\\n    onClose();\\n  };\\n\\n  const handleAddTag = () => {\\n    if (!tagInput.trim()) return;\\n    \\n    // 避免添加重复标签\\n    if (!tags.includes(tagInput.trim())) {\\n      setTags([...tags, tagInput.trim()]);\\n    }\\n    \\n    setTagInput('');\\n    \\n    // 添加后自动聚焦回标签输入框\\n    setTimeout(() => {\\n      if (tagInputRef.current) {\\n        tagInputRef.current.focus();\\n      }\\n    }, 0);\\n  };\\n\\n  const handleRemoveTag = (tagToRemove: string) => {\\n    setTags(tags.filter(tag => tag !== tagToRemove));\\n  };\\n\\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      handleAddTag();\\n    }\\n  };\\n\\n  if (!isOpen) return null;\\n\\n  return (\\n    <div className={styles['modal-overlay']}>\\n      <div ref={modalRef} className={`${styles['modal-content']} ${styles['rename-modal']}`}>\\n        <div className={styles['modal-header']}>\\n          <h3 className={styles['modal-title']}>\\n            {fileType === 'folder' ? '重命名文件夹' : '重命名文件'}\\n          </h3>\\n          <button \\n            className={styles['modal-close']} \\n            onClick={onClose}\\n            aria-label=\\\"关闭\\\"\\n          >\\n            <CloseOutlined />\\n          </button>\\n        </div>\\n        \\n        <form className={styles['rename-form']} onSubmit={handleSubmit}>\\n          <div className={styles['form-group']}>\\n            <label className={styles['form-label']}>名称</label>\\n            <input\\n              ref={inputRef}\\n              type=\\\"text\\\"\\n              className={styles['rename-input']}\\n              value={newName}\\n              onChange={(e) => setNewName(e.target.value)}\\n              placeholder=\\\"输入新名称\\\"\\n              autoFocus\\n            />\\n          </div>\\n          \\n          <div className={styles['form-group']}>\\n            <label className={styles['form-label']}>标签</label>\\n            <div className={styles['tags-container']}>\\n              {tags.map((tag, index) => (\\n                <div key={index} className={styles['tag']}>\\n                  <span>{tag}</span>\\n                  <button \\n                    type=\\\"button\\\"\\n                    className={styles['tag-remove']}\\n                    onClick={() => handleRemoveTag(tag)}\\n                  >\\n                    &times;\\n                  </button>\\n                </div>\\n              ))}\\n            </div>\\n            <div className={styles['tag-input-container']}>\\n              <TagOutlined className={styles['tag-icon']} />\\n              <input\\n                ref={tagInputRef}\\n                type=\\\"text\\\"\\n                className={styles['tag-input']}\\n                value={tagInput}\\n                onChange={(e) => setTagInput(e.target.value)}\\n                onKeyDown={handleTagInputKeyDown}\\n                placeholder=\\\"输入标签，按回车添加\\\"\\n              />\\n              <button\\n                type=\\\"button\\\"\\n                className={styles['tag-add-button']}\\n                onClick={handleAddTag}\\n                disabled={!tagInput.trim()}\\n              >\\n                <PlusOutlined />\\n              </button>\\n            </div>\\n          </div>\\n\\n          <div className={styles['modal-footer']}>\\n            <button \\n              type=\\\"button\\\" \\n              className={`${styles['modal-button']} ${styles.cancel}`}\\n              onClick={onClose}\\n            >\\n              取消\\n            </button>\\n            <button \\n              type=\\\"submit\\\" \\n              className={`${styles['modal-button']} ${styles.confirm}`}\\n              disabled={!newName.trim() || (newName === initialName && JSON.stringify(tags) === JSON.stringify(initialTags))}\\n            >\\n              确认\\n            </button>\\n          </div>\\n        </form>\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default RenameModal; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Breadcrumb.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/navigation/Breadcrumb 组件。\\n */\\n\\nimport React from 'react';\\nimport { Home, ChevronRight, ChevronLeft } from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { FolderPathItem } from '@/app/types';\\n\\ninterface BreadcrumbProps {\\n  folderPath: FolderPathItem[];\\n  showHome?: boolean;\\n  onNavigate?: (folderId: string | null) => void;\\n  onPathClick: (folderId: string | null) => void;\\n  onBackClick?: () => void;\\n}\\n\\nexport function Breadcrumb({ \\n  folderPath, \\n  showHome = true, \\n  onNavigate, \\n  onPathClick,\\n  onBackClick\\n}: BreadcrumbProps) {\\n  // 向下兼容：如果有onNavigate但没有onPathClick，就使用onNavigate\\n  const handlePathClick = onPathClick || onNavigate;\\n\\n  if (!handlePathClick) {\\n    console.error('Breadcrumb组件缺少必要的onPathClick或onNavigate回调函数');\\n    return null;\\n  }\\n\\n  return (\\n    <div className={styles.breadcrumb}>\\n      {onBackClick && folderPath.length > 0 && (\\n        <button \\n          className={styles.breadcrumbBackButton}\\n          onClick={onBackClick}\\n          title=\\\"返回上一级\\\"\\n        >\\n          <ChevronLeft size={16} />\\n        </button>\\n      )}\\n      \\n      {showHome && (\\n        <div className={styles.breadcrumbItem}>\\n          <button\\n            className={styles.breadcrumbLink}\\n            onClick={() => handlePathClick(null)}\\n          >\\n            <Home size={16} className={styles.breadcrumbIcon} />\\n            根目录\\n          </button>\\n        </div>\\n      )}\\n      \\n      {folderPath.map((folder) => (\\n        <React.Fragment key={folder.id}>\\n          <span className={styles.breadcrumbSeparator}>\\n            <ChevronRight size={14} />\\n          </span>\\n          <div className={styles.breadcrumbItem}>\\n            <button\\n              className={styles.breadcrumbLink}\\n              onClick={() => handlePathClick(folder.id)}\\n            >\\n              {folder.name}\\n            </button>\\n          </div>\\n        </React.Fragment>\\n      ))}\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\ErrorDisplay.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/shared/ErrorDisplay 组件。\\n */\\n\\n'use client';\\n\\nimport React from 'react';\\nimport { AlertTriangle, RefreshCw, Wifi, Server, CloudOff } from 'lucide-react';\\nimport styles from '../../../../file-management/styles/shared.module.css';\\n\\ninterface ErrorDisplayProps {\\n  title?: string;\\n  message?: string;\\n  errorType?: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown';\\n  onRetry?: () => void;\\n  retryText?: string;\\n}\\n\\n/**\\n * 显示友好的错误提示，支持不同类型的错误\\n */\\nexport const ErrorDisplay: React.FC<ErrorDisplayProps> = ({\\n  title,\\n  message = '请刷新页面重试或联系管理员',\\n  errorType = 'unknown',\\n  onRetry,\\n  retryText = '重试'\\n}) => {\\n  // 根据错误类型获取图标和标题\\n  const getErrorInfo = () => {\\n    switch (errorType) {\\n      case 'network':\\n        return {\\n          icon: <Wifi className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '网络连接错误'\\n        };\\n      case 'auth':\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '身份验证失败'\\n        };\\n      case 'server':\\n        return {\\n          icon: <Server className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '服务器错误'\\n        };\\n      case 'data':\\n        return {\\n          icon: <CloudOff className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '数据加载失败'\\n        };\\n      case 'timeout':\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '请求超时'\\n        };\\n      default:\\n        return {\\n          icon: <AlertTriangle className=\\\"w-12 h-12 text-red-500\\\" />,\\n          defaultTitle: '加载出错'\\n        };\\n    }\\n  };\\n\\n  const { icon, defaultTitle } = getErrorInfo();\\n  const displayTitle = title || defaultTitle;\\n\\n  return (\\n    <div className={styles.errorContainer}>\\n      <div className={styles.errorCard}>\\n        <div className={styles.errorIcon}>\\n          {icon}\\n        </div>\\n        <h3 className={styles.errorTitle}>{displayTitle}</h3>\\n        <p className={styles.errorText}>{message}</p>\\n        {onRetry && (\\n          <button \\n            className={styles.retryButton}\\n            onClick={onRetry}\\n          >\\n            <RefreshCw className=\\\"w-4 h-4\\\" />\\n            {retryText}\\n          </button>\\n        )}\\n      </div>\\n    </div>\\n  );\\n}; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\FileList.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/fileList/FileList 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport { \\n  File as FileIcon, \\n  Folder, \\n  Image as ImageIcon, \\n  FileText, \\n  Video, \\n  Music, \\n  MoreVertical,\\n  Tag as TagIcon,\\n  SearchX,\\n  Filter,\\n  Check,\\n  X,\\n  Plus\\n} from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { getFileType as getFileTypeDisplay } from '@/app/utils/file/type';\\nimport { getFileNameAndExtension } from '@/app/utils/file/path';\\nimport { FileInfo } from '@/app/types';\\n\\ninterface FileListProps {\\n  files: FileInfo[];\\n  selectedFiles: string[];\\n  onFileClick: (file: FileInfo) => void;\\n  onFileDoubleClick?: (file: FileInfo) => void;\\n  onFileContextMenu?: (event: React.MouseEvent, file: FileInfo) => void;\\n  onSelectFiles?: (fileIds: string[]) => void;\\n  onFileSelect?: (file: FileInfo, checked: boolean) => void;\\n  onSelectAll?: () => void;\\n  onDeselectAll?: () => void;\\n  onSelectAllFiles?: () => void;\\n  onDeselectAllFiles?: () => void;\\n  fileTypeFilter?: string | null;\\n  isLoading?: boolean;\\n  error?: string | null;\\n  onBackClick?: () => void;\\n  editingFileId?: string | null;\\n  editingFile?: string | null;\\n  editingName?: string;\\n  editingTags?: string[];\\n  newTag?: string;\\n  onNewTagChange?: (value: string) => void;\\n  onEditNameChange?: (value: string) => void;\\n  onStartEdit?: (file: FileInfo) => void;\\n  onConfirmEdit?: (fileId: string, newName: string, newTags: string[]) => void;\\n  onCancelEdit?: () => void;\\n  onAddTag?: (tag: string) => void;\\n  onRemoveTag?: (tag: string) => void;\\n  showCheckboxes?: boolean;\\n  areAllSelected?: boolean;\\n}\\n\\nexport function FileList({\\n  files,\\n  selectedFiles,\\n  onFileClick,\\n  onFileDoubleClick,\\n  onFileContextMenu,\\n  onSelectFiles,\\n  onFileSelect,\\n  onSelectAll,\\n  onDeselectAll,\\n  onSelectAllFiles,\\n  onDeselectAllFiles,\\n  fileTypeFilter,\\n  isLoading,\\n  error,\\n  onBackClick,\\n  editingFileId,\\n  editingFile,\\n  editingName: providedEditingName,\\n  editingTags: providedEditingTags,\\n  newTag: providedNewTag,\\n  onNewTagChange,\\n  onEditNameChange,\\n  onStartEdit,\\n  onConfirmEdit,\\n  onCancelEdit,\\n  onAddTag,\\n  onRemoveTag,\\n  showCheckboxes = true,\\n  areAllSelected\\n}: FileListProps) {\\n  const actualEditingFileId = editingFileId || editingFile;\\n\\n  const [localEditName, setLocalEditName] = useState<string>('');\\n  const [localEditTags, setLocalEditTags] = useState<string[]>([]);\\n  const [localNewTag, setLocalNewTag] = useState<string>('');\\n  \\n  const editName = providedEditingName !== undefined ? providedEditingName : localEditName;\\n  const editTags = providedEditingTags !== undefined ? providedEditingTags : localEditTags;\\n  const newTagValue = providedNewTag !== undefined ? providedNewTag : localNewTag;\\n  \\n  const setEditName = (value: string) => {\\n    if (onEditNameChange) {\\n      onEditNameChange(value);\\n    } else {\\n      setLocalEditName(value);\\n    }\\n  };\\n  \\n  const setEditTags = (tags: string[]) => {\\n    setLocalEditTags(tags);\\n  };\\n  \\n  const setNewTag = (value: string) => {\\n    if (onNewTagChange) {\\n      onNewTagChange(value);\\n    } else {\\n      setLocalNewTag(value);\\n    }\\n  };\\n\\n  const editNameInputRef = useRef<HTMLInputElement>(null);\\n  const newTagInputRef = useRef<HTMLInputElement>(null);\\n\\n  useEffect(() => {\\n    if (actualEditingFileId && providedEditingName === undefined) {\\n      const file = files.find(f => f.id === actualEditingFileId);\\n      if (file) {\\n        setLocalEditName(file.name);\\n        setLocalEditTags(file.tags || []);\\n      }\\n    }\\n    \\n    if (actualEditingFileId) {\\n      setTimeout(() => {\\n        if (editNameInputRef.current) {\\n          editNameInputRef.current.focus();\\n          editNameInputRef.current.select();\\n        }\\n      }, 0);\\n    }\\n  }, [actualEditingFileId, files, providedEditingName]);\\n\\n  const handleEditKeyDown = (e: React.KeyboardEvent, fileId: string) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      onConfirmEdit && onConfirmEdit(fileId, editName, editTags);\\n    } else if (e.key === 'Escape') {\\n      e.preventDefault();\\n      onCancelEdit && onCancelEdit();\\n    }\\n  };\\n\\n  const handleAddTag = () => {\\n    const trimmedTag = newTagValue.trim();\\n    if (!trimmedTag) return;\\n    \\n    if (!editTags.includes(trimmedTag)) {\\n      if (onAddTag) {\\n        onAddTag(trimmedTag);\\n      } else {\\n        setEditTags([...editTags, trimmedTag]);\\n      }\\n      setNewTag('');\\n      \\n      setTimeout(() => {\\n        if (newTagInputRef.current) {\\n          newTagInputRef.current.focus();\\n        }\\n      }, 0);\\n    }\\n  };\\n\\n  const handleRemoveTag = (tagToRemove: string) => {\\n    if (onRemoveTag) {\\n      onRemoveTag(tagToRemove);\\n    } else {\\n      setEditTags(editTags.filter(tag => tag !== tagToRemove));\\n    }\\n  };\\n\\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\\n    if (e.key === 'Enter') {\\n      e.preventDefault();\\n      handleAddTag();\\n    }\\n  };\\n\\n  const handleFileCheckboxChange = (file: FileInfo, checked: boolean) => {\\n    if (onFileSelect) {\\n      onFileSelect(file, checked);\\n      return;\\n    }\\n    \\n    if (onSelectFiles) {\\n      if (checked) {\\n        onSelectFiles([...selectedFiles, file.id]);\\n      } else {\\n        onSelectFiles(selectedFiles.filter(id => id !== file.id));\\n      }\\n    } else {\\n      console.error('FileList: 缺少必要的onSelectFiles或onFileSelect回调函数');\\n    }\\n  };\\n\\n  const handleSelectAll = onSelectAll || onSelectAllFiles;\\n  const handleDeselectAll = onDeselectAll || onDeselectAllFiles;\\n\\n  const renderFileIcon = (type?: string, extension?: string, isFolder?: boolean) => {\\n    if (isFolder) return <Folder className={styles.fileIcon} />;\\n    \\n    const getFileIconType = () => {\\n      if (!type) return 'file';\\n      \\n      if (type.includes('image')) return 'image';\\n      if (type.includes('text') || type.includes('document') || extension?.match(/docx?|pdf|txt|md/i)) return 'file-text';\\n      if (type.includes('video')) return 'video';\\n      if (type.includes('audio')) return 'music';\\n      if (extension?.match(/zip|rar|7z|tar|gz/i)) return 'archive';\\n      if (extension?.match(/js|ts|jsx|tsx|py|java|c|cpp|go|rb|php|html|css/i)) return 'code';\\n      \\n      return 'file';\\n    };\\n    \\n    const iconType = getFileIconType();\\n    const IconComponent = {\\n      'folder': Folder,\\n      'file': FileIcon,\\n      'image': ImageIcon,\\n      'file-text': FileText,\\n      'video': Video,\\n      'music': Music,\\n      'archive': FileIcon,\\n      'code': FileIcon\\n    }[iconType] || FileIcon;\\n\\n    return <IconComponent className={styles.fileIcon} />;\\n  };\\n\\n  const renderTags = (file: FileInfo) => {\\n    const tags = file.tags || [];\\n    \\n    if (actualEditingFileId === file.id) {\\n      return (\\n        <div className={styles.tagEditContainer}>\\n          <div className={styles.editTagsList}>\\n            {editTags.map((tag, index) => (\\n              <div key={index} className={styles.editTag}>\\n                <span>{tag}</span>\\n                <button \\n                  className={styles.removeTagButton}\\n                  onClick={() => handleRemoveTag(tag)}\\n                >\\n                  <X size={12} />\\n                </button>\\n              </div>\\n            ))}\\n          </div>\\n          <div className={styles.addTagInput}>\\n            <input\\n              ref={newTagInputRef}\\n              type=\\\"text\\\"\\n              placeholder=\\\"添加标签...\\\"\\n              value={localNewTag}\\n              onChange={(e) => setNewTag(e.target.value)}\\n              onKeyDown={handleTagKeyDown}\\n              className={styles.tagInput}\\n            />\\n            <button \\n              className={styles.addTagButton}\\n              onClick={handleAddTag}\\n            >\\n              <Plus size={14} />\\n            </button>\\n          </div>\\n        </div>\\n      );\\n    }\\n    \\n    if (!tags || tags.length === 0) return <span className={styles.emptyText}>-</span>;\\n    \\n    const maxTagsToShow = 3;\\n    const visibleTags = tags.slice(0, maxTagsToShow);\\n    const extraTagsCount = tags.length - maxTagsToShow;\\n    \\n    return (\\n      <div className={styles.tagContainer}>\\n        {visibleTags.map((tag, index) => (\\n          <span key={index} className={styles.tag}>\\n            {tag}\\n          </span>\\n        ))}\\n        {extraTagsCount > 0 && (\\n          <span className={styles.extraTagsCount}>+{extraTagsCount}</span>\\n        )}\\n      </div>\\n    );\\n  };\\n\\n  const isAllSelected = areAllSelected !== undefined \\n    ? areAllSelected \\n    : (files.length > 0 && selectedFiles.length === files.length);\\n\\n  if (!Array.isArray(files) || files.length === 0) {\\n    const getEmptyStateMessage = () => {\\n      if (fileTypeFilter) {\\n        switch(fileTypeFilter) {\\n          case 'image':\\n            return `您的存储空间中没有找到图片文件`;\\n          case 'document':\\n            return `您的存储空间中没有找到文档文件`;\\n          case 'video':\\n            return `您的存储空间中没有找到视频文件`;\\n          case 'audio':\\n            return `您的存储空间中没有找到音频文件`;\\n          case 'other':\\n            return `您的存储空间中没有找到其他类型的文件`;\\n          default:\\n            return `没有找到${fileTypeFilter}类型的文件`;\\n        }\\n      }\\n      return '没有文件';\\n    };\\n\\n    const getEmptyStateIcon = () => {\\n      if (fileTypeFilter) {\\n        return <Filter size={50} stroke=\\\"#CBD5E0\\\" />;\\n      }\\n      return <FileIcon size={50} stroke=\\\"#CBD5E0\\\" />;\\n    };\\n\\n    const getEmptyStateHint = () => {\\n      if (fileTypeFilter) {\\n        return `系统已搜索所有文件夹，未找到${\\n          fileTypeFilter === 'image' ? '图片' : \\n          fileTypeFilter === 'document' ? '文档' : \\n          fileTypeFilter === 'video' ? '视频' :\\n          fileTypeFilter === 'audio' ? '音频' : '该类型'\\n        }文件，您可以上传一些，或选择其他文件类型查看。`;\\n      }\\n      return '上传文件或创建文件夹以开始管理您的文件';\\n    };\\n\\n    return (\\n      <div className={styles.emptyState}>\\n        {getEmptyStateIcon()}\\n        <p className={styles.emptyStateText}>{getEmptyStateMessage()}</p>\\n        <p className={styles.emptyStateHint}>\\n          {getEmptyStateHint()}\\n        </p>\\n      </div>\\n    );\\n  }\\n\\n  return (\\n    <div className={styles.fileListWrapper}>\\n      <div className={styles.fileListContainer}>\\n        <table className={styles.fileTable}>\\n          <thead>\\n            <tr>\\n              <th>\\n                <input\\n                  type=\\\"checkbox\\\"\\n                  checked={isAllSelected}\\n                  onChange={isAllSelected ? \\n                    () => handleDeselectAll && handleDeselectAll() : \\n                    () => handleSelectAll && handleSelectAll()}\\n                  disabled={!showCheckboxes}\\n                />\\n              </th>\\n              <th>名称</th>\\n              <th>类型</th>\\n              <th>大小</th>\\n              <th>标签</th>\\n              <th>修改日期</th>\\n              <th>操作</th>\\n            </tr>\\n          </thead>\\n          <tbody>\\n            {files.map((file) => {\\n              const isSelected = selectedFiles.includes(file.id);\\n              const isEditing = actualEditingFileId === file.id;\\n              \\n              return (\\n                <tr\\n                  key={file.id}\\n                  className={`${styles.fileRow} ${isSelected ? styles.selectedRow : ''} ${isEditing ? styles.editingRow : ''}`}\\n                  onClick={() => !isEditing && onFileClick(file)}\\n                  onDoubleClick={() => {\\n                    if (!isEditing && onStartEdit && !file.isFolder) {\\n                      onStartEdit(file);\\n                    } else if (!isEditing && onFileDoubleClick) {\\n                      onFileDoubleClick(file);\\n                    }\\n                  }}\\n                  onContextMenu={(e) => !isEditing && onFileContextMenu && onFileContextMenu(e, file)}\\n                >\\n                  <td>\\n                    {showCheckboxes && (\\n                      <input\\n                        type=\\\"checkbox\\\"\\n                        checked={isSelected}\\n                        onChange={(e) => handleFileCheckboxChange(file, e.target.checked)}\\n                        onClick={(e) => e.stopPropagation()}\\n                        disabled={isEditing}\\n                      />\\n                    )}\\n                  </td>\\n                  <td className={styles.fileNameCell}>\\n                    <span className={styles.fileIcon}>\\n                      {renderFileIcon(file.type, file.extension, file.isFolder)}\\n                    </span>\\n                    {isEditing ? (\\n                      <input\\n                        ref={editNameInputRef}\\n                        type=\\\"text\\\"\\n                        className={styles.fileNameInput}\\n                        value={editName}\\n                        onChange={(e) => setEditName(e.target.value)}\\n                        onKeyDown={(e) => handleEditKeyDown(e, file.id)}\\n                        onClick={(e) => e.stopPropagation()}\\n                        autoComplete=\\\"off\\\"\\n                      />\\n                    ) : (\\n                      <span className={styles.fileName}>{file.name}</span>\\n                    )}\\n                    {isEditing && (\\n                      <div className={styles.editActions}>\\n                        <button \\n                          className={styles.editActionButton}\\n                          onClick={(e) => {\\n                            e.stopPropagation();\\n                            onConfirmEdit && onConfirmEdit(file.id, editName, editTags);\\n                          }}\\n                        >\\n                          <Check size={16} />\\n                        </button>\\n                        <button \\n                          className={styles.editActionButton}\\n                          onClick={(e) => {\\n                            e.stopPropagation();\\n                            onCancelEdit && onCancelEdit();\\n                          }}\\n                        >\\n                          <X size={16} />\\n                        </button>\\n                      </div>\\n                    )}\\n                  </td>\\n                  <td>{file.isFolder ? '文件夹' : \\n                     file.type === 'document' ? '文档' : \\n                     getFileTypeDisplay(file.type || null, file.extension)}</td>\\n                  <td>{file.size ? `${Math.round(file.size / 1024)} KB` : '-'}</td>\\n                  <td className={styles.tagsCell}>{renderTags(file)}</td>\\n                  <td>\\n                    {file.createdAt \\n                      ? new Date(file.createdAt).toLocaleString() \\n                      : '-'\\n                    }\\n                  </td>\\n                  <td>\\n                    {!isEditing ? (\\n                      <button \\n                        className={styles.actionButton}\\n                        onClick={(e) => {\\n                          e.stopPropagation();\\n                          if (onStartEdit) {\\n                            onStartEdit(file);\\n                          } else if (onFileContextMenu) {\\n                            onFileContextMenu(e, file);\\n                          }\\n                        }}\\n                      >\\n                        <MoreVertical size={16} />\\n                      </button>\\n                    ) : (\\n                      <span className={styles.editingMessage}>编辑中</span>\\n                    )}\\n                  </td>\\n                </tr>\\n              );\\n            })}\\n          </tbody>\\n        </table>\\n      </div>\\n    </div>\\n  );\\n}\"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\index.ts\",\n    \"newContent\": \"export * from './Sidebar';\\nexport * from './Breadcrumb';\\nexport * from './FileList';\\n// export * from './UploadModal'; // 已迁移到 @/app/components/features/file-management/upload/UploadModal\\n// export * from './UploadButton'; // 已迁移到 @/app/components/features/file-management/upload/UploadButton\\nexport * from './Skeleton';\\nexport * from './ErrorDisplay'; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Sidebar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/navigation/Sidebar 组件。\\n */\\n\\nimport React, { useEffect } from 'react';\\nimport { \\n  Folder, Files, Image as ImageIcon, FileText, \\n  Video, Music, File, Search, ChevronDown, \\n  Star, Clock, Tag, Download, Settings,\\n  CheckCircle\\n} from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\n\\nexport type FileType = 'image' | 'document' | 'video' | 'audio' | 'other' | null;\\n\\ninterface SidebarProps {\\n  selectedFileType: FileType;\\n  onTypeClick: (type: FileType) => void;\\n  onSearchClick?: () => void;\\n}\\n\\nexport function Sidebar({ selectedFileType, onTypeClick, onSearchClick }: SidebarProps) {\\n  const fileTypes: { type: FileType; label: string; icon: React.ElementType }[] = [\\n    { type: null, label: '全部文件', icon: Files },\\n    { type: 'image', label: '图片', icon: ImageIcon },\\n    { type: 'document', label: '文档', icon: FileText },\\n    { type: 'video', label: '视频', icon: Video },\\n    { type: 'audio', label: '音频', icon: Music },\\n    { type: 'other', label: '其他', icon: File }\\n  ];\\n\\n  const [quickAccessExpanded, setQuickAccessExpanded] = React.useState(true);\\n  const [myFilesExpanded, setMyFilesExpanded] = React.useState(true);\\n  const [settingsExpanded, setSettingsExpanded] = React.useState(false);\\n\\n  // 监听文件类型变化并记录日志\\n  useEffect(() => {\\n    console.log('侧边栏：当前选择的文件类型:', selectedFileType);\\n  }, [selectedFileType]);\\n\\n  const handleTypeClick = (type: FileType) => {\\n    // 直接调用回调，不需要任何额外逻辑\\n    console.log('Sidebar直接点击类型:', type);\\n    onTypeClick(type);\\n  };\\n\\n  return (\\n    <div className={styles.sidebar}>\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader} \\n          onClick={() => setMyFilesExpanded(!myFilesExpanded)}\\n        >\\n          <Folder className={styles.icon} />\\n          我的文件\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: myFilesExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {myFilesExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            {fileTypes.map(({ type, label, icon: Icon }) => (\\n              <div\\n                key={type || 'all'}\\n                className={`${styles.sidebarItem} ${selectedFileType === type ? styles.active : ''}`}\\n                onClick={() => handleTypeClick(type)}\\n              >\\n                <Icon className={styles.icon} />\\n                {label}\\n                {selectedFileType === type && (\\n                  <CheckCircle \\n                    className={styles.icon} \\n                    style={{ \\n                      marginLeft: 'auto', \\n                      color: 'var(--theme-primary, #3b82f6)',\\n                      fill: 'var(--theme-primary, #3b82f6)',\\n                      stroke: '#fff',\\n                      opacity: 0.9,\\n                    }} \\n                    size={16} \\n                  />\\n                )}\\n              </div>\\n            ))}\\n          </div>\\n        )}\\n      </div>\\n\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader}\\n          onClick={() => setQuickAccessExpanded(!quickAccessExpanded)}\\n        >\\n          <Search className={styles.icon} />\\n          快捷查询\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: quickAccessExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {quickAccessExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            <div \\n              className={styles.sidebarItem}\\n              onClick={onSearchClick}\\n            >\\n              <Search className={styles.icon} />\\n              搜索文件\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Star className={styles.icon} />\\n              收藏文件\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Clock className={styles.icon} />\\n              最近访问\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Tag className={styles.icon} />\\n              按标签查找\\n            </div>\\n            <div className={styles.sidebarItem}>\\n              <Download className={styles.icon} />\\n              下载记录\\n            </div>\\n          </div>\\n        )}\\n      </div>\\n\\n      <div className={styles.sidebarSection}>\\n        <div \\n          className={styles.sidebarHeader}\\n          onClick={() => setSettingsExpanded(!settingsExpanded)}\\n        >\\n          <Settings className={styles.icon} />\\n          系统设置\\n          <ChevronDown \\n            className={styles.icon} \\n            style={{ \\n              marginLeft: 'auto', \\n              transform: settingsExpanded ? 'rotate(180deg)' : 'rotate(0)', \\n              transition: 'transform 0.3s' \\n            }} \\n            size={16} \\n          />\\n        </div>\\n        {settingsExpanded && (\\n          <div className={styles.sidebarSubmenu}>\\n            <div className={styles.sidebarItem}>\\n              <Settings className={styles.icon} />\\n              存储管理\\n            </div>\\n          </div>\\n        )}\\n      </div>\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\Skeleton.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/shared/Skeleton 组件。\\n */\\n\\n'use client';\\n\\nimport React from 'react';\\nimport styles from './Skeleton.module.css';\\n\\ninterface SkeletonProps {\\n  variant?: 'sidebar' | 'file' | 'avatar' | 'text' | 'button' | 'card';\\n  width?: string | number;\\n  height?: string | number;\\n  animation?: 'pulse' | 'wave' | 'none';\\n  count?: number;\\n  className?: string;\\n  borderRadius?: string;\\n}\\n\\nexport const Skeleton: React.FC<SkeletonProps> = ({ \\n  variant = 'text', \\n  width, \\n  height, \\n  animation = 'pulse',\\n  count = 1,\\n  className = '',\\n  borderRadius\\n}) => {\\n  const getVariantStyles = () => {\\n    switch (variant) {\\n      case 'sidebar':\\n        return {\\n          width: width || '100%',\\n          height: height || '40px',\\n          borderRadius: borderRadius || '8px'\\n        };\\n      case 'file':\\n        return {\\n          width: width || '100%',\\n          height: height || '56px',\\n          borderRadius: borderRadius || '8px'\\n        };\\n      case 'avatar':\\n        return {\\n          width: width || '40px',\\n          height: height || '40px',\\n          borderRadius: borderRadius || '50%'\\n        };\\n      case 'text':\\n        return {\\n          width: width || '100%',\\n          height: height || '16px',\\n          borderRadius: borderRadius || '4px'\\n        };\\n      case 'button':\\n        return {\\n          width: width || '120px',\\n          height: height || '36px',\\n          borderRadius: borderRadius || '6px'\\n        };\\n      case 'card':\\n        return {\\n          width: width || '100%',\\n          height: height || '200px',\\n          borderRadius: borderRadius || '12px'\\n        };\\n      default:\\n        return {\\n          width: width || '100%',\\n          height: height || '16px',\\n          borderRadius: borderRadius || '4px'\\n        };\\n    }\\n  };\\n\\n  const renderSkeleton = () => {\\n    const items = [];\\n    const baseStyles = getVariantStyles();\\n    \\n    for (let i = 0; i < count; i++) {\\n      items.push(\\n        <div \\n          key={i}\\n          className={`${styles.skeleton} ${styles[`animation-${animation}`]} ${className}`}\\n          style={{\\n            ...baseStyles,\\n            marginBottom: count > 1 && i < count - 1 ? '8px' : '0'\\n          }}\\n        />\\n      );\\n    }\\n    \\n    return items;\\n  };\\n\\n  return <>{renderSkeleton()}</>;\\n};\\n\\nexport const SkeletonFileList: React.FC = () => {\\n  return (\\n    <div className={styles.fileListSkeleton}>\\n      <div className={styles.fileListHeader}>\\n        <Skeleton variant=\\\"text\\\" width=\\\"15%\\\" height=\\\"24px\\\" />\\n        <div className={styles.headerActions}>\\n          <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n          <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n        </div>\\n      </div>\\n      \\n      <div className={styles.fileItems}>\\n        {[...Array(8)].map((_, index) => (\\n          <div key={index} className={styles.fileItemSkeleton}>\\n            <div className={styles.fileIcon}>\\n              <Skeleton variant=\\\"avatar\\\" width=\\\"32px\\\" height=\\\"32px\\\" borderRadius=\\\"6px\\\" />\\n            </div>\\n            <div className={styles.fileDetails}>\\n              <Skeleton variant=\\\"text\\\" width=\\\"60%\\\" height=\\\"18px\\\" />\\n              <Skeleton variant=\\\"text\\\" width=\\\"40%\\\" height=\\\"14px\\\" />\\n            </div>\\n            <div className={styles.fileActions}>\\n              <Skeleton variant=\\\"button\\\" width=\\\"70px\\\" />\\n            </div>\\n          </div>\\n        ))}\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport const SkeletonSidebar: React.FC = () => {\\n  return (\\n    <div className={styles.sidebarSkeleton}>\\n      <div className={styles.sidebarHeader}>\\n        <Skeleton variant=\\\"text\\\" width=\\\"70%\\\" height=\\\"24px\\\" />\\n      </div>\\n      <div className={styles.sidebarContent}>\\n        <Skeleton variant=\\\"sidebar\\\" count={5} />\\n        <div className={styles.sidebarSection}>\\n          <Skeleton variant=\\\"text\\\" width=\\\"50%\\\" height=\\\"18px\\\" />\\n          <Skeleton variant=\\\"sidebar\\\" count={3} />\\n        </div>\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport const SkeletonPageLayout: React.FC = () => {\\n  return (\\n    <div className={styles.pageLayoutSkeleton}>\\n      <div className={styles.miniSidebarSkeleton}>\\n        <Skeleton variant=\\\"avatar\\\" width=\\\"40px\\\" height=\\\"40px\\\" />\\n        <Skeleton variant=\\\"button\\\" width=\\\"40px\\\" height=\\\"40px\\\" borderRadius=\\\"12px\\\" />\\n        <Skeleton variant=\\\"button\\\" width=\\\"40px\\\" height=\\\"40px\\\" borderRadius=\\\"12px\\\" />\\n      </div>\\n      \\n      <div className={styles.sidebarContainerSkeleton}>\\n        <SkeletonSidebar />\\n      </div>\\n      \\n      <div className={styles.mainContentSkeleton}>\\n        <div className={styles.topBarSkeleton}>\\n          <div className={styles.breadcrumbSkeleton}>\\n            <Skeleton variant=\\\"text\\\" width=\\\"180px\\\" height=\\\"20px\\\" />\\n          </div>\\n          <div className={styles.actionButtonsSkeleton}>\\n            <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n            <Skeleton variant=\\\"button\\\" width=\\\"100px\\\" />\\n          </div>\\n        </div>\\n        \\n        <SkeletonFileList />\\n      </div>\\n    </div>\\n  );\\n}; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\UploadButton.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/upload/UploadButton 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport { Upload, Folder, ChevronDown } from 'lucide-react';\\nimport styles from '../../styles/shared.module.css';\\nimport { UploadModal } from './UploadModal';\\n\\ninterface UploadButtonProps {\\n  showDropdown: boolean;\\n  setShowDropdown: (show: boolean) => void;\\n  setIsModalOpen: (open: boolean) => void;\\n  setIsFolderModalOpen: (open: boolean) => void;\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\n}\\n\\nexport function UploadButton({ \\n  showDropdown, \\n  setShowDropdown, \\n  setIsModalOpen, \\n  setIsFolderModalOpen,\\n  uploadDropdownRef \\n}: UploadButtonProps) {\\n  \\n  // 处理上传按钮点击\\n  const handleUploadClick = (type: 'file' | 'folder') => {\\n    if (type === 'file') {\\n      setIsModalOpen(true);\\n    } else {\\n      setIsFolderModalOpen(true);\\n    }\\n    setShowDropdown(false);\\n  };\\n\\n  return (\\n    <div className={styles.uploadOptionsContainer} ref={uploadDropdownRef}>\\n      <button\\n        className={`${styles.uploadButton} ${showDropdown ? styles.activeButton : ''}`}\\n        onClick={() => setShowDropdown(!showDropdown)}\\n      >\\n        <Upload size={18} className={styles.buttonIcon} />\\n        上传文件\\n        <ChevronDown size={16} className={styles.dropdownIcon} />\\n      </button>\\n      \\n      {showDropdown && (\\n        <div className={styles.dropdownMenu}>\\n          <div \\n            className={styles.dropdownItem}\\n            onClick={() => handleUploadClick('file')}\\n          >\\n            <Upload size={16} className=\\\"mr-2\\\" />\\n            <span>上传文件</span>\\n          </div>\\n          <div \\n            className={styles.dropdownItem}\\n            onClick={() => handleUploadClick('folder')}\\n          >\\n            <Folder size={16} className=\\\"mr-2\\\" />\\n            <span>上传文件夹</span>\\n          </div>\\n        </div>\\n      )}\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\shared\\\\UploadModal.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/upload/UploadModal 组件。\\n */\\n\\nimport React, { useState, useEffect, useRef, KeyboardEvent } from 'react';\\nimport { InboxOutlined, CloseCircleOutlined, TagOutlined, CloseOutlined } from '@ant-design/icons';\\nimport { Modal, Upload, Input, message, Button, Tag } from 'antd';\\nimport type { RcFile, UploadFile } from 'antd/es/upload/interface';\\nimport type { UploadProps } from 'antd';\\nimport type { InputRef } from 'antd/es/input';\\nimport { FileInfo, FileResponse } from '@/app/types';\\nimport styles from '../../styles/shared.module.css';\\nimport { useSession } from 'next-auth/react';\\nimport { API_PATHS } from '@/app/lib/api/paths';\\n\\nconst { Dragger } = Upload;\\n\\ninterface UploadModalProps {\\n  isOpen: boolean;\\n  onClose: () => void;\\n  onSuccess: (files?: FileInfo[]) => void;\\n  isFolderUpload?: boolean;\\n  currentFolderId?: string | null;\\n}\\n\\n// 扩展UploadFile类型，添加webkitRelativePath属性\\ninterface ExtendedUploadFile extends UploadFile<any> {\\n  webkitRelativePath?: string;\\n}\\n\\nexport function UploadModal({\\n  isOpen,\\n  onClose,\\n  onSuccess,\\n  isFolderUpload = false,\\n  currentFolderId\\n}: UploadModalProps) {\\n  const [fileList, setFileList] = useState<ExtendedUploadFile[]>([]);\\n  const [tagInput, setTagInput] = useState<string>('');\\n  const [tagList, setTagList] = useState<string[]>([]);\\n  const [uploading, setUploading] = useState(false);\\n  const fileInputRef = useRef<HTMLInputElement>(null);\\n  const tagInputRef = useRef<InputRef>(null);\\n  const { data: session } = useSession();\\n\\n  useEffect(() => {\\n    // 当模态框打开时检查登录状态\\n    if (isOpen && !session) {\\n      message.error('请先登录后再上传文件');\\n      onClose();\\n    }\\n  }, [isOpen, session, onClose]);\\n\\n  // 处理文件选择\\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const selectedFiles = e.target.files;\\n    if (!selectedFiles || selectedFiles.length === 0) return;\\n\\n    const newFiles: ExtendedUploadFile[] = [];\\n    for (let i = 0; i < selectedFiles.length; i++) {\\n      const file = selectedFiles[i];\\n      newFiles.push({\\n        uid: `file-${Date.now()}-${i}`,\\n        name: file.name,\\n        size: file.size,\\n        type: file.type,\\n        originFileObj: file as any,\\n        webkitRelativePath: file.webkitRelativePath, // 添加相对路径\\n      });\\n    }\\n\\n    setFileList(prev => [...prev, ...newFiles]);\\n    \\n    // 清空input以允许再次选择相同的文件\\n    if (fileInputRef.current) {\\n      fileInputRef.current.value = '';\\n    }\\n  };\\n\\n  // 处理标签输入\\n  const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    setTagInput(e.target.value);\\n  };\\n\\n  // 处理标签输入的回车事件\\n  const handleTagInputKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\\n    if (e.key === 'Enter' && tagInput.trim()) {\\n      e.preventDefault();\\n      addTag(tagInput.trim());\\n    }\\n  };\\n\\n  // 添加标签\\n  const addTag = (tag: string) => {\\n    if (!tag) return;\\n    \\n    // 检查标签是否已存在\\n    if (!tagList.includes(tag)) {\\n      setTagList(prev => [...prev, tag]);\\n    }\\n    \\n    // 清空输入框\\n    setTagInput('');\\n    \\n    // 聚焦回输入框，方便继续输入\\n    if (tagInputRef.current) {\\n      setTimeout(() => {\\n        tagInputRef.current?.focus();\\n      }, 0);\\n    }\\n  };\\n\\n  // 删除标签\\n  const removeTag = (tagToRemove: string) => {\\n    setTagList(tagList.filter(tag => tag !== tagToRemove));\\n  };\\n\\n  const handleUpload = async () => {\\n    if (fileList.length === 0) {\\n      message.warning('请选择要上传的文件');\\n      return;\\n    }\\n\\n    setUploading(true);\\n\\n    try {\\n      const formData = new FormData();\\n      \\n      // 添加所有文件到FormData\\n      let filesAdded = 0;\\n      fileList.forEach((file, index) => {\\n        const rawFile = file.originFileObj;\\n        if (rawFile instanceof File) {\\n          // 使用'file'字段名，与后端对应\\n          formData.append('file', rawFile);\\n          \\n          // 如果是文件夹上传，添加相对路径信息\\n          if (isFolderUpload && file.webkitRelativePath) {\\n            // 使用数字索引作为键，确保后端可以正确解析\\n            formData.append(`paths_${index}`, file.webkitRelativePath);\\n            console.log(`文件 ${index}: ${file.name} - 路径: ${file.webkitRelativePath}`);\\n          }\\n          \\n          filesAdded++;\\n          console.log(`添加文件 ${index+1}: ${file.name}, 大小: ${file.size} 字节`);\\n        } else {\\n          console.warn(`无法获取文件 ${index+1}: ${file.name} 的原始File对象`);\\n        }\\n      });\\n      \\n      if (filesAdded === 0) {\\n        throw new Error('无法处理上传文件，请重新选择文件');\\n      }\\n      \\n      // 添加标志表明这是文件夹上传\\n      if (isFolderUpload) {\\n        formData.append('isFolderUpload', 'true');\\n        console.log('文件夹上传模式已启用');\\n      }\\n      \\n      // 将标签数组转换为逗号分隔的字符串\\n      if (tagList.length > 0) {\\n        formData.append('tags', JSON.stringify(tagList));\\n        console.log('添加标签:', tagList);\\n      }\\n\\n      if (currentFolderId) {\\n        formData.append('folderId', currentFolderId);\\n        console.log('当前文件夹ID:', currentFolderId);\\n      }\\n\\n      console.log(`准备上传 ${filesAdded} 个文件...`);\\n      \\n      // 显示上传开始消息\\n      const uploadKey = `upload-${Date.now()}`;\\n      message.loading({ content: '正在上传文件...', key: uploadKey, duration: 0 });\\n\\n      // 使用fetch发送请求\\n      const response = await fetch(API_PATHS.STORAGE.FILES.UPLOAD, {\\n        method: 'POST',\\n        body: formData,\\n      });\\n\\n      // 获取响应\\n      const contentType = response.headers.get(\\\"content-type\\\");\\n      let data;\\n      \\n      if (contentType && contentType.includes(\\\"application/json\\\")) {\\n        data = await response.json();\\n      } else {\\n        // 如果不是JSON响应，尝试获取文本\\n        const text = await response.text();\\n        console.error('服务器返回了非JSON响应:', text);\\n        throw new Error('服务器返回了无效的响应格式');\\n      }\\n      \\n      // 检查响应状态\\n      if (!response.ok) {\\n        console.error('上传响应错误:', data);\\n        \\n        // 显示错误消息\\n        message.error({ \\n          content: `上传失败: ${data.details || data.error || '服务器错误'}`, \\n          key: uploadKey,\\n          duration: 5 \\n        });\\n        \\n        throw new Error(data.details || data.error || '上传失败');\\n      }\\n\\n      // 上传成功处理\\n      console.log('上传成功:', data);\\n      message.success({ content: '上传成功', key: uploadKey, duration: 3 });\\n      \\n      // 关闭模态框并通知父组件\\n      handleClose();\\n      if (typeof onSuccess === 'function') {\\n        onSuccess(data.files || (data.file ? [data.file] : undefined));\\n      } else {\\n        console.warn('onSuccess不是一个函数，无法通知上传成功');\\n      }\\n    } catch (error) {\\n      console.error('上传过程中出错:', error);\\n      message.error(`上传失败: ${error instanceof Error ? error.message : '未知错误'}`);\\n    } finally {\\n      setUploading(false);\\n    }\\n  };\\n\\n  const handleClose = () => {\\n    setFileList([]);\\n    setTagInput('');\\n    setTagList([]);\\n    onClose();\\n  };\\n  \\n  // 直接使用原生文件输入\\n  const triggerFileInput = () => {\\n    if (fileInputRef.current) {\\n      fileInputRef.current.click();\\n    }\\n  };\\n  \\n  const removeFile = (index: number) => {\\n    setFileList(prev => prev.filter((_, i) => i !== index));\\n  };\\n\\n  return (\\n    <Modal\\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\\n      open={isOpen}\\n      onCancel={handleClose}\\n      onOk={handleUpload}\\n      okText=\\\"上传\\\"\\n      cancelText=\\\"取消\\\"\\n      confirmLoading={uploading}\\n      width={600}\\n    >\\n      <div className={styles.uploadContainer || ''}>\\n        <input\\n          type=\\\"file\\\"\\n          ref={fileInputRef}\\n          onChange={handleFileChange}\\n          style={{ display: 'none' }}\\n          multiple={true}\\n          {...(isFolderUpload ? { webkitdirectory: '', directory: '', mozdirectory: '', msdirectory: '' } : {})}\\n        />\\n        \\n        <div \\n          className={styles.dropzone || ''}\\n          onClick={triggerFileInput}\\n          style={{ \\n            border: '2px dashed #d9d9d9',\\n            borderRadius: '4px',\\n            padding: '20px',\\n            textAlign: 'center',\\n            cursor: 'pointer',\\n            marginBottom: '16px'\\n          }}\\n        >\\n          <p><InboxOutlined style={{ fontSize: '48px', color: '#40a9ff' }} /></p>\\n          <p style={{ marginTop: '8px', fontWeight: 'bold' }}>\\n            点击或拖拽{isFolderUpload ? '文件夹' : '文件'}到此区域上传\\n          </p>\\n          <p style={{ color: '#888' }}>\\n            {isFolderUpload\\n              ? '支持上传整个文件夹及其内部文件，保留文件夹结构'\\n              : '支持单个或批量上传文件，最大支持同时选择50个文件'}\\n          </p>\\n          <Button type=\\\"primary\\\" onClick={(e) => { e.stopPropagation(); triggerFileInput(); }}>\\n            选择{isFolderUpload ? '文件夹' : '文件'}\\n          </Button>\\n        </div>\\n        \\n        {fileList.length > 0 && (\\n          <div style={{ marginBottom: '16px' }}>\\n            <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\\n              已选择 {fileList.length} 个文件:\\n            </div>\\n            <ul style={{ maxHeight: '150px', overflowY: 'auto', padding: '0 0 0 20px' }}>\\n              {fileList.map((file, index) => (\\n                <li key={file.uid} style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>\\n                  <span>\\n                    {file.name} \\n                    {isFolderUpload && file.webkitRelativePath && (\\n                      <span style={{ fontSize: '12px', color: '#8c8c8c', marginLeft: '4px' }}>\\n                        (路径: {file.webkitRelativePath.split('/').slice(0, -1).join('/')})\\n                      </span>\\n                    )}\\n                    ({((file.size || 0) / 1024).toFixed(2)} KB)\\n                  </span>\\n                  <Button \\n                    type=\\\"text\\\" \\n                    danger \\n                    onClick={() => removeFile(index)}\\n                    style={{ padding: '0 4px' }}\\n                  >\\n                    删除\\n                  </Button>\\n                </li>\\n              ))}\\n            </ul>\\n          </div>\\n        )}\\n\\n        <div style={{ marginTop: 16 }}>\\n          <div style={{ marginBottom: '8px', display: 'flex', alignItems: 'center' }}>\\n            <span style={{ fontWeight: 'bold', marginRight: '8px' }}>添加标签:</span>\\n            <span style={{ fontSize: '12px', color: '#8c8c8c' }}>\\n              (输入标签后按回车添加)\\n            </span>\\n          </div>\\n          \\n          <div className={styles.tagsInputWrapper}>\\n            <Input\\n              ref={tagInputRef}\\n              placeholder=\\\"输入标签后按回车添加\\\"\\n              value={tagInput}\\n              onChange={handleTagInputChange}\\n              onKeyDown={handleTagInputKeyDown}\\n              prefix={<TagOutlined style={{ color: '#bfbfbf' }} />}\\n              suffix={\\n                <span style={{ color: '#bfbfbf', fontSize: '12px' }}>\\n                  按回车添加\\n                </span>\\n              }\\n            />\\n          </div>\\n          \\n          <div className={styles.tagsContainer}>\\n            {tagList.length > 0 ? (\\n              <div className={styles.tagsList}>\\n                {tagList.map((tag, index) => (\\n                  <Tag\\n                    key={index}\\n                    closable\\n                    onClose={() => removeTag(tag)}\\n                    className={styles.interactiveTag}\\n                  >\\n                    {tag}\\n                  </Tag>\\n                ))}\\n              </div>\\n            ) : (\\n              <div className={styles.emptyTagsHint}>\\n                添加一些标签来帮助管理您的文件\\n              </div>\\n            )}\\n          </div>\\n        </div>\\n\\n        <div style={{ marginTop: '16px', padding: '12px', background: '#f5f5f5', borderRadius: '8px', fontSize: '13px', color: '#555' }}>\\n          <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\\n            {isFolderUpload ? '文件夹上传说明:' : '文件上传说明:'}\\n          </div>\\n          <ul style={{ paddingLeft: '16px', margin: '0' }}>\\n            {isFolderUpload ? (\\n              <>\\n                <li>支持上传整个文件夹及其子文件夹结构</li>\\n                <li>保留完整的文件夹层次结构</li>\\n                <li>目前仅Chrome、Edge等现代浏览器支持文件夹选择</li>\\n                <li>如果您的浏览器不支持文件夹选择，请选择单个文件模式</li>\\n              </>\\n            ) : (\\n              <>\\n                <li>支持批量上传多个文件</li>\\n                <li>支持常见的文件格式（图片、文档、视频等）</li>\\n                <li>每个文件大小限制为50MB</li>\\n                <li>一次最多可选择50个文件</li>\\n              </>\\n            )}\\n            <li>您可以为上传的文件添加标签，以便更好地组织和查找</li>\\n          </ul>\\n        </div>\\n      </div>\\n    </Modal>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\SortDropdown.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/actionBar/SortDropdown 组件。\\n */\\n\\nimport React, { useState, useRef, useEffect } from 'react';\\nimport styles from '../styles/SortDropdown.module.css';\\nimport { FileSortInterface, SortDirectionEnum } from '@/app/types';\\n\\ninterface SortDropdownProps {\\n  sortOrder: FileSortInterface;\\n  onSortChange: (order: FileSortInterface) => void;\\n}\\n\\nexport const SortDropdown: React.FC<SortDropdownProps> = ({\\n  sortOrder,\\n  onSortChange\\n}) => {\\n  const [showDropdown, setShowDropdown] = useState(false);\\n  const dropdownRef = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    const handleClickOutside = (event: MouseEvent) => {\\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\\n        setShowDropdown(false);\\n      }\\n    };\\n\\n    document.addEventListener('mousedown', handleClickOutside);\\n    return () => document.removeEventListener('mousedown', handleClickOutside);\\n  }, []);\\n\\n  // 根据当前排序字段获取显示文本\\n  const getSortFieldText = () => {\\n    switch(sortOrder.field) {\\n      case 'name': return '文件名';\\n      case 'size': return '大小';\\n      case 'createdAt': return '时间';\\n      default: return '默认';\\n    }\\n  };\\n\\n  return (\\n    <div className={styles.sortDropdown} ref={dropdownRef}>\\n      <button \\n        className={styles.topButton}\\n        onClick={() => setShowDropdown(!showDropdown)}\\n        style={{ \\n          background: showDropdown ? '#f0f7ff' : 'white',\\n          borderColor: showDropdown ? '#60a5fa' : '#e8e8e8'\\n        }}\\n      >\\n        <span>↕️</span>\\n        排序: {getSortFieldText()} {sortOrder.direction === SortDirectionEnum.ASC ? '↑' : '↓'}\\n      </button>\\n      {showDropdown && (\\n        <div className={styles.dropdownMenu}>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'name',\\n                direction: sortOrder.field === 'name' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'name' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'name' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>📝</span>\\n            按文件名{sortOrder.field === 'name' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'size',\\n                direction: sortOrder.field === 'size' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'size' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'size' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>📊</span>\\n            按大小{sortOrder.field === 'size' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n          <button \\n            className={styles.dropdownItem}\\n            onClick={() => {\\n              const newSortOrder: FileSortInterface = {\\n                field: 'createdAt',\\n                direction: sortOrder.field === 'createdAt' && sortOrder.direction === SortDirectionEnum.ASC ? SortDirectionEnum.DESC : SortDirectionEnum.ASC\\n              };\\n              onSortChange(newSortOrder);\\n              setShowDropdown(false);\\n            }}\\n            style={{ \\n              fontWeight: sortOrder.field === 'createdAt' ? 'bold' : 'normal',\\n              background: sortOrder.field === 'createdAt' ? '#f0f7ff' : 'transparent'\\n            }}\\n          >\\n            <span>🕒</span>\\n            按时间{sortOrder.field === 'createdAt' ? (sortOrder.direction === SortDirectionEnum.ASC ? ' ↑' : ' ↓') : ''}\\n          </button>\\n        </div>\\n      )}\\n    </div>\\n  );\\n};\\n\\nexport default SortDropdown; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\Toolbar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/toolbar/Toolbar 组件。\\n */\\n\\nimport React, { useRef, useState } from 'react';\\nimport { useFileContext } from '../context/FileContext';\\nimport { X, Download, Edit, Move } from 'lucide-react';\\nimport { message } from 'antd';\\nimport styles from './Toolbar.module.css';\\nimport commonStyles from '../styles/common.module.css';\\n\\ninterface ToolbarProps {\\n  onUploadClick: () => void;\\n  onFolderUploadClick: () => void;\\n  onCreateFolderClick: () => void;\\n}\\n\\nexport function Toolbar({ onUploadClick, onFolderUploadClick, onCreateFolderClick }: ToolbarProps) {\\n  const {\\n    selectedFiles,\\n    clearSelection,\\n    files\\n  } = useFileContext();\\n\\n  const [showUploadDropdown, setShowUploadDropdown] = useState(false);\\n  const dropdownRef = useRef<HTMLDivElement>(null);\\n\\n  const handleDownload = () => {\\n    // TODO: 实现文件下载功能\\n    message.info('下载功能开发中');\\n  };\\n\\n  const handleRename = () => {\\n    if (selectedFiles.length !== 1) {\\n      message.warning('请选择一个文件进行重命名');\\n      return;\\n    }\\n    const selectedFile = files.find(file => file.id === selectedFiles[0]);\\n    if (selectedFile) {\\n      // TODO: 实现重命名功能\\n      message.info('重命名功能开发中');\\n    }\\n  };\\n\\n  return (\\n    <div className={styles.topBar}>\\n      <div className={styles.buttonGroup}>\\n        {selectedFiles.length > 0 ? (\\n          <>\\n            <button className={styles.topButton} onClick={() => clearSelection()}>\\n              <X className={commonStyles.icon} />\\n              取消选择\\n            </button>\\n            <button className={styles.topButton} onClick={handleDownload}>\\n              <Download className={commonStyles.icon} />\\n              下载\\n            </button>\\n            <button className={styles.topButton} onClick={handleRename}>\\n              <Edit className={commonStyles.icon} />\\n              重命名\\n            </button>\\n            <button className={styles.topButton}>\\n              <Move className={commonStyles.icon} />\\n              移动\\n            </button>\\n          </>\\n        ) : (\\n          <>\\n            <div className={styles.uploadDropdown} ref={dropdownRef}>\\n              <button\\n                className={styles.topButton}\\n                onClick={() => setShowUploadDropdown(!showUploadDropdown)}\\n              >\\n                <span className={styles.buttonIcon}>⬆️</span>\\n                上传\\n                <span className={styles.dropdownArrow}>▼</span>\\n              </button>\\n              {showUploadDropdown && (\\n                <div className={styles.dropdownMenu}>\\n                  <button\\n                    className={styles.dropdownItem}\\n                    onClick={() => {\\n                      onUploadClick();\\n                      setShowUploadDropdown(false);\\n                    }}\\n                  >\\n                    <span className={styles.buttonIcon}>📄</span>\\n                    上传文件\\n                  </button>\\n                  <button\\n                    className={styles.dropdownItem}\\n                    onClick={() => {\\n                      onFolderUploadClick();\\n                      setShowUploadDropdown(false);\\n                    }}\\n                  >\\n                    <span className={styles.buttonIcon}>📁</span>\\n                    上传文件夹\\n                  </button>\\n                </div>\\n              )}\\n            </div>\\n            <button\\n              className={styles.topButton}\\n              onClick={onCreateFolderClick}\\n            >\\n              <span className={styles.buttonIcon}>📁</span>\\n              新建文件夹\\n            </button>\\n          </>\\n        )}\\n      </div>\\n    </div>\\n  );\\n} \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\TopActionBar.tsx\",\n    \"newContent\": \"/**\\n * @deprecated 此组件已迁移到新的组件架构中。\\n * 请使用 @/app/components/features/file-management/actionBar/TopActionBar 组件。\\n */\\n\\nimport React from 'react';\\nimport { \\n  X, Download, Edit, Move, Trash2, FolderUp, Image as ImageIcon, FileText, Video, Music, File \\n} from 'lucide-react';\\nimport styles from '../styles/shared.module.css';\\nimport SortDropdown from './SortDropdown';\\nimport { UploadButton } from '../components/shared';\\nimport { FileSortInterface } from '@/app/types';\\n\\ninterface TopActionBarProps {\\n  selectedFiles: string[];\\n  onClearSelection: () => void;\\n  onDownload: () => void;\\n  onRename: () => void;\\n  onMove: () => void;\\n  onDelete: () => void;\\n  onClearFilter: () => void;\\n  onCreateFolder: () => void;\\n  selectedFileType: string | null;\\n  showSearchView: boolean;\\n  isInRootFolder: boolean;\\n  sortOrder: FileSortInterface;\\n  setSortOrder: (order: FileSortInterface) => void;\\n  showUploadDropdown: boolean;\\n  setShowUploadDropdown: (show: boolean) => void;\\n  setIsUploadModalOpen: (open: boolean) => void;\\n  setIsFolderUploadModalOpen: (open: boolean) => void;\\n  uploadDropdownRef: React.RefObject<HTMLDivElement>;\\n}\\n\\nexport const TopActionBar: React.FC<TopActionBarProps> = ({\\n  selectedFiles,\\n  onClearSelection,\\n  onDownload,\\n  onRename,\\n  onMove,\\n  onDelete,\\n  onClearFilter,\\n  onCreateFolder,\\n  selectedFileType,\\n  showSearchView,\\n  isInRootFolder,\\n  sortOrder,\\n  setSortOrder,\\n  showUploadDropdown,\\n  setShowUploadDropdown,\\n  setIsUploadModalOpen,\\n  setIsFolderUploadModalOpen,\\n  uploadDropdownRef\\n}) => {\\n  return (\\n    <div className={styles.topBar}>\\n      <div className={styles.buttonGroup}>\\n        {selectedFiles.length > 0 ? (\\n          <>\\n            <button className={styles.topButton} onClick={onClearSelection}>\\n              <X className=\\\"w-4 h-4\\\" />\\n              取消选择\\n            </button>\\n            <button className={styles.topButton} onClick={onDownload}>\\n              <Download className=\\\"w-4 h-4\\\" />\\n              下载\\n            </button>\\n            <button \\n              className={styles.topButton}\\n              onClick={onRename}\\n            >\\n              <Edit className=\\\"w-4 h-4\\\" />\\n              重命名\\n            </button>\\n            <button className={styles.topButton} onClick={onMove}>\\n              <Move className=\\\"w-4 h-4\\\" />\\n              移动\\n            </button>\\n            <button className={styles.topButton} onClick={onDelete}>\\n              <Trash2 className=\\\"w-4 h-4\\\" />\\n              删除\\n            </button>\\n          </>\\n        ) : (\\n          <>\\n            <button \\n              className={styles.topButton}\\n              onClick={onClearFilter}\\n              disabled={isInRootFolder}\\n            >\\n              <span>📁</span>\\n              {showSearchView ? '返回文件列表' : (selectedFileType ? '清除过滤' : '根目录')}\\n            </button>\\n\\n            {/* 添加当前过滤状态指示器 */}\\n            {selectedFileType && (\\n              <div className={styles.topButton} style={{ cursor: 'default', background: '#f0f7ff', borderColor: '#60a5fa' }}>\\n                {(() => {\\n                  switch(selectedFileType) {\\n                    case 'image': return <ImageIcon className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'document': return <FileText className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'video': return <Video className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'audio': return <Music className=\\\"w-4 h-4 mr-2\\\" />;\\n                    case 'other': return <File className=\\\"w-4 h-4 mr-2\\\" />;\\n                    default: return null;\\n                  }\\n                })()}\\n                当前浏览：\\n                {selectedFileType === 'image' && '仅图片'}\\n                {selectedFileType === 'document' && '仅文档'}\\n                {selectedFileType === 'video' && '仅视频'}\\n                {selectedFileType === 'audio' && '仅音频'}\\n                {selectedFileType === 'other' && '其他文件'}\\n              </div>\\n            )}\\n\\n            {/* 排序下拉菜单 */}\\n            <SortDropdown \\n              sortOrder={sortOrder}\\n              onSortChange={setSortOrder}\\n            />\\n            \\n            {/* 上传按钮 */}\\n            <UploadButton \\n              showDropdown={showUploadDropdown}\\n              setShowDropdown={setShowUploadDropdown}\\n              setIsModalOpen={setIsUploadModalOpen}\\n              setIsFolderModalOpen={setIsFolderUploadModalOpen}\\n              uploadDropdownRef={uploadDropdownRef}\\n            />\\n            \\n            <button \\n              className={styles.folderButton} \\n              onClick={onCreateFolder}\\n            >\\n              <FolderUp className=\\\"w-4 h-4 mr-2\\\" />\\n              新建文件夹\\n            </button>\\n          </>\\n        )}\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default TopActionBar; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\file-management\\\\upload\\\\UploadModal\\\\UploadModal.tsx\",\n    \"newContent\": \"'use client';\\r\\n\\r\\nimport React, { useState, useRef, useEffect } from 'react';\\r\\nimport { Modal, Button, Space, Tag, Input, message, Progress } from 'antd';\\r\\nimport { UploadOutlined, FolderOutlined } from '@ant-design/icons';\\r\\nimport { UploadModalProps } from '@/app/types/domains/file-management';\\r\\nimport { FileTreeNode } from '@/app/types/domains/fileTypes';\\r\\nimport { formatFileSize } from '@/app/lib/utils/file';\\r\\nimport { uploadFile, uploadFolder, processSelectedFiles } from '@/app/lib/uploadService';\\r\\n\\r\\n// 构建文件树节点\\r\\nfunction createFileTreeNode(name: string, type: 'file' | 'folder', size: number = 0, file?: File): FileTreeNode {\\r\\n  return {\\r\\n    name,\\r\\n    type,\\r\\n    size,\\r\\n    children: type === 'folder' ? [] : undefined,\\r\\n    file: file as any\\r\\n  };\\r\\n}\\r\\n\\r\\n// 更新文件夹大小\\r\\nfunction updateFolderSize(node: FileTreeNode, fileSize: number) {\\r\\n  let currentNode = node;\\r\\n  while (currentNode) {\\r\\n    currentNode.size += fileSize;\\r\\n    currentNode = currentNode.children?.find(child => \\r\\n      child.type === 'folder'\\r\\n    ) as FileTreeNode;\\r\\n  }\\r\\n}\\r\\n\\r\\n// 构建文件树结构\\r\\nfunction buildFileTree(files: File[], rootName: string): FileTreeNode {\\r\\n  const root = createFileTreeNode(rootName, 'folder');\\r\\n  \\r\\n  files.forEach(file => {\\r\\n    const paths = (file as any).webkitRelativePath.split('/');\\r\\n    let currentNode = root;\\r\\n    \\r\\n    for (let i = 1; i < paths.length; i++) {\\r\\n      const pathPart = paths[i];\\r\\n      const isFile = i === paths.length - 1;\\r\\n\\r\\n      if (isFile) {\\r\\n        const fileNode = createFileTreeNode(pathPart, 'file', file.size, file);\\r\\n        currentNode.children?.push(fileNode);\\r\\n        updateFolderSize(currentNode, file.size);\\r\\n      } else {\\r\\n        let folderNode = currentNode.children?.find(\\r\\n          child => child.name === pathPart && child.type === 'folder'\\r\\n        );\\r\\n        \\r\\n        if (!folderNode) {\\r\\n          folderNode = createFileTreeNode(pathPart, 'folder');\\r\\n          currentNode.children?.push(folderNode);\\r\\n        }\\r\\n        currentNode = folderNode;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  return root;\\r\\n}\\r\\n\\r\\n/**\\r\\n * 文件上传模态框组件\\r\\n * 支持文件或文件夹上传，提供拖放和选择界面\\r\\n */\\r\\nconst UploadModal: React.FC<UploadModalProps> = ({\\r\\n  isOpen,\\r\\n  onClose,\\r\\n  onUploadSuccess,\\r\\n  currentFolderId,\\r\\n  isFolderUpload,\\r\\n  withTags\\r\\n}) => {\\r\\n  const [isDragging, setIsDragging] = useState(false);\\r\\n  const [files, setFiles] = useState<File[]>([]);\\r\\n  const [isUploading, setIsUploading] = useState(false);\\r\\n  const [uploadProgress, setUploadProgress] = useState(0);\\r\\n  const [tags, setTags] = useState<string[]>([]);\\r\\n  const [tagInput, setTagInput] = useState('');\\r\\n  const [folderName, setFolderName] = useState<string | null>(null);\\r\\n  const [fileTree, setFileTree] = useState<FileTreeNode | null>(null);\\r\\n  const fileInputRef = useRef<HTMLInputElement>(null);\\r\\n\\r\\n  // 重置所有状态\\r\\n  const resetState = () => {\\r\\n    setFiles([]);\\r\\n    setIsDragging(false);\\r\\n    setTags([]);\\r\\n    setTagInput('');\\r\\n    setFolderName(null);\\r\\n    setFileTree(null);\\r\\n    setUploadProgress(0);\\r\\n  };\\r\\n\\r\\n  // 监听 isOpen 变化，当弹窗关闭时重置状态\\r\\n  useEffect(() => {\\r\\n    if (!isOpen) {\\r\\n      resetState();\\r\\n    }\\r\\n  }, [isOpen]);\\r\\n\\r\\n  const handleClose = () => {\\r\\n    resetState();\\r\\n    onClose();\\r\\n  };\\r\\n\\r\\n  const handleDragOver = (e: React.DragEvent) => {\\r\\n    e.preventDefault();\\r\\n    setIsDragging(true);\\r\\n  };\\r\\n\\r\\n  const handleDragLeave = () => {\\r\\n    setIsDragging(false);\\r\\n  };\\r\\n\\r\\n  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {\\r\\n    e.preventDefault();\\r\\n    setIsDragging(false);\\r\\n    \\r\\n    const droppedFiles = Array.from(e.dataTransfer.files);\\r\\n    if (droppedFiles.length > 0) {\\r\\n      const { files: processedFiles, folderName } = processSelectedFiles(droppedFiles, isFolderUpload);\\r\\n      setFiles(processedFiles);\\r\\n      setFolderName(folderName);\\r\\n      \\r\\n      if (isFolderUpload && folderName) {\\r\\n        setFileTree(buildFileTree(processedFiles, folderName));\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\\r\\n    const selectedFiles = Array.from(e.target.files || []);\\r\\n    if (selectedFiles.length > 0) {\\r\\n      const { files: processedFiles, folderName } = processSelectedFiles(selectedFiles, isFolderUpload);\\r\\n      setFiles(processedFiles);\\r\\n      setFolderName(folderName);\\r\\n      \\r\\n      if (isFolderUpload && folderName) {\\r\\n        setFileTree(buildFileTree(processedFiles, folderName));\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const removeFile = (fileName: string) => {\\r\\n    setFiles(prev => prev.filter(file => file.name !== fileName));\\r\\n  };\\r\\n\\r\\n  const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\\r\\n    if (e.key === 'Enter' && tagInput.trim()) {\\r\\n      e.preventDefault();\\r\\n      const newTag = tagInput.trim();\\r\\n      if (!tags.includes(newTag)) {\\r\\n        setTags([...tags, newTag]);\\r\\n      }\\r\\n      setTagInput('');\\r\\n    }\\r\\n  };\\r\\n\\r\\n  const removeTag = (tagToRemove: string) => {\\r\\n    setTags(tags.filter(tag => tag !== tagToRemove));\\r\\n  };\\r\\n\\r\\n  // 递归渲染文件树组件\\r\\n  const renderFileTree = (node: FileTreeNode, level: number = 0) => {\\r\\n    return (\\r\\n      <div key={node.name} style={{ marginLeft: `${level * 20}px` }}>\\r\\n        <div className=\\\"file-item\\\">\\r\\n          <div className=\\\"file-info\\\">\\r\\n            <span className=\\\"file-type-icon\\\">\\r\\n              {node.type === 'folder' ? '📁' : \\r\\n               node.file?.type.startsWith('image/') ? '🖼️' :\\r\\n               node.file?.type.includes('pdf') ? '📄' :\\r\\n               node.file?.type.includes('word') ? '📝' :\\r\\n               '📄'}\\r\\n            </span>\\r\\n            <div>\\r\\n              <p className=\\\"file-name\\\">{node.name}</p>\\r\\n              <p className=\\\"file-size\\\">\\r\\n                {formatFileSize(node.size)}\\r\\n                {node.type === 'folder' && ` (${node.children?.length || 0} 个文件)`}\\r\\n              </p>\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n        {node.children && node.children.length > 0 && (\\r\\n          <div className=\\\"file-children\\\">\\r\\n            {node.children.map(child => renderFileTree(child, level + 1))}\\r\\n          </div>\\r\\n        )}\\r\\n      </div>\\r\\n    );\\r\\n  };\\r\\n\\r\\n  // 上传处理函数\\r\\n  const handleUpload = async () => {\\r\\n    if (files.length === 0) return;\\r\\n    \\r\\n    setIsUploading(true);\\r\\n    setUploadProgress(0);\\r\\n    \\r\\n    try {\\r\\n      // 处理文件夹上传\\r\\n      if (isFolderUpload && folderName) {\\r\\n        await uploadFolder(files, folderName, {\\r\\n          folderId: currentFolderId || undefined,\\r\\n          tags,\\r\\n          onProgress: (progress) => {\\r\\n            setUploadProgress(progress);\\r\\n          },\\r\\n          onSuccess: (response) => {\\r\\n            message.success(`文件夹 \\\"${folderName}\\\" 上传成功`);\\r\\n            setIsUploading(false);\\r\\n            onUploadSuccess();\\r\\n            handleClose();\\r\\n          },\\r\\n          onError: (error) => {\\r\\n            message.error(`上传失败: ${error.message}`);\\r\\n            setIsUploading(false);\\r\\n          }\\r\\n        });\\r\\n      } else {\\r\\n        // 单文件或多文件上传\\r\\n        let uploadedCount = 0;\\r\\n        const totalFiles = files.length;\\r\\n        \\r\\n        for (const file of files) {\\r\\n          await uploadFile(file, {\\r\\n            folderId: currentFolderId || undefined,\\r\\n            tags,\\r\\n            onProgress: (fileProgress) => {\\r\\n              // 计算总体进度：已完成文件 + 当前文件进度\\r\\n              const totalProgress = Math.round(\\r\\n                (uploadedCount * 100 + fileProgress) / totalFiles\\r\\n              );\\r\\n              setUploadProgress(totalProgress);\\r\\n            },\\r\\n            onSuccess: () => {\\r\\n              uploadedCount++;\\r\\n              \\r\\n              // 所有文件上传完成\\r\\n              if (uploadedCount === totalFiles) {\\r\\n                message.success(totalFiles > 1 \\r\\n                  ? `${totalFiles}个文件上传成功` \\r\\n                  : '文件上传成功');\\r\\n                \\r\\n                setIsUploading(false);\\r\\n                onUploadSuccess();\\r\\n                handleClose();\\r\\n              }\\r\\n            },\\r\\n            onError: (error) => {\\r\\n              message.error(`文件上传失败: ${error.message}`);\\r\\n              setIsUploading(false);\\r\\n            }\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    } catch (error) {\\r\\n      const errorMessage = error instanceof Error ? error.message : '上传失败';\\r\\n      message.error(errorMessage);\\r\\n      setIsUploading(false);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <Modal\\r\\n      title={isFolderUpload ? '上传文件夹' : '上传文件'}\\r\\n      open={isOpen}\\r\\n      onCancel={handleClose}\\r\\n      footer={[\\r\\n        <Button key=\\\"cancel\\\" onClick={handleClose} disabled={isUploading}>\\r\\n          取消\\r\\n        </Button>,\\r\\n        <Button \\r\\n          key=\\\"upload\\\" \\r\\n          type=\\\"primary\\\" \\r\\n          onClick={handleUpload} \\r\\n          disabled={files.length === 0 || isUploading}\\r\\n          loading={isUploading}\\r\\n        >\\r\\n          上传\\r\\n        </Button>,\\r\\n      ]}\\r\\n      width={800}\\r\\n    >\\r\\n      {isUploading ? (\\r\\n        <div className=\\\"text-center py-8\\\">\\r\\n          <div className=\\\"my-4\\\">\\r\\n            <Progress percent={uploadProgress} status=\\\"active\\\" />\\r\\n            <div className=\\\"mt-2\\\">{`上传中...${uploadProgress}%`}</div>\\r\\n          </div>\\r\\n        </div>\\r\\n      ) : (\\r\\n        <div className=\\\"upload-content\\\">\\r\\n          {/* 拖放区域 */}\\r\\n          <div\\r\\n            onDragOver={handleDragOver}\\r\\n            onDragLeave={handleDragLeave}\\r\\n            onDrop={handleDrop}\\r\\n            className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${\\r\\n              isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-500'\\r\\n            }`}\\r\\n          >\\r\\n            <div className=\\\"upload-icon mb-4\\\">\\r\\n              {isFolderUpload ? <FolderOutlined style={{ fontSize: 48 }} /> : <UploadOutlined style={{ fontSize: 48 }} />}\\r\\n            </div>\\r\\n            <p className=\\\"text-lg mb-2\\\">\\r\\n              {isDragging\\r\\n                ? isFolderUpload\\r\\n                  ? '放开以上传文件夹'\\r\\n                  : '放开以上传文件'\\r\\n                : isFolderUpload\\r\\n                ? '拖放文件夹至此处，或'\\r\\n                : '拖放文件至此处，或'}\\r\\n            </p>\\r\\n            <Button\\r\\n              onClick={() => fileInputRef.current?.click()}\\r\\n              type=\\\"primary\\\"\\r\\n              icon={isFolderUpload ? <FolderOutlined /> : <UploadOutlined />}\\r\\n            >\\r\\n              {isFolderUpload ? '选择文件夹' : '选择文件'}\\r\\n            </Button>\\r\\n            <input\\r\\n              ref={fileInputRef}\\r\\n              type=\\\"file\\\"\\r\\n              multiple={!isFolderUpload}\\r\\n              style={{ display: 'none' }}\\r\\n              onChange={handleFileSelect}\\r\\n              {...(isFolderUpload ? { webkitdirectory: \\\"\\\", directory: \\\"\\\" } : {})}\\r\\n            />\\r\\n          </div>\\r\\n\\r\\n          {/* 标签输入区域 */}\\r\\n          {withTags && (\\r\\n            <div className=\\\"tags-section mt-6\\\">\\r\\n              <h4 className=\\\"text-base font-medium mb-2\\\">添加标签</h4>\\r\\n              <div className=\\\"tag-input\\\">\\r\\n                <Input\\r\\n                  placeholder=\\\"输入标签并按Enter添加\\\"\\r\\n                  value={tagInput}\\r\\n                  onChange={(e) => setTagInput(e.target.value)}\\r\\n                  onKeyDown={handleTagInputKeyDown}\\r\\n                />\\r\\n              </div>\\r\\n              {tags.length > 0 && (\\r\\n                <div className=\\\"tags-list mt-2 flex flex-wrap gap-1\\\">\\r\\n                  {tags.map((tag) => (\\r\\n                    <Tag\\r\\n                      key={tag}\\r\\n                      closable\\r\\n                      onClose={() => removeTag(tag)}\\r\\n                    >\\r\\n                      {tag}\\r\\n                    </Tag>\\r\\n                  ))}\\r\\n                </div>\\r\\n              )}\\r\\n            </div>\\r\\n          )}\\r\\n\\r\\n          {/* 文件列表或文件树 */}\\r\\n          {files.length > 0 && (\\r\\n            <div className=\\\"file-list mt-6\\\">\\r\\n              <h4 className=\\\"text-base font-medium mb-2\\\">\\r\\n                {isFolderUpload \\r\\n                  ? `文件夹: ${folderName} (${files.length}个文件)` \\r\\n                  : `选择的文件 (${files.length})`}\\r\\n              </h4>\\r\\n              \\r\\n              {isFolderUpload && fileTree ? (\\r\\n                <div className=\\\"folder-tree border rounded p-3\\\">\\r\\n                  {renderFileTree(fileTree)}\\r\\n                </div>\\r\\n              ) : (\\r\\n                <div className=\\\"file-items space-y-2\\\">\\r\\n                  {files.map((file) => (\\r\\n                    <div\\r\\n                      key={file.name}\\r\\n                      className=\\\"file-item flex justify-between items-center border rounded p-2\\\"\\r\\n                    >\\r\\n                      <div className=\\\"file-details flex items-center\\\">\\r\\n                        <span className=\\\"file-icon mr-2\\\">\\r\\n                          {file.type.startsWith('image/') ? '🖼️' :\\r\\n                           file.type.includes('pdf') ? '📄' :\\r\\n                           file.type.includes('word') ? '📝' :\\r\\n                           '📄'}\\r\\n                        </span>\\r\\n                        <div>\\r\\n                          <div className=\\\"file-name font-medium\\\">{file.name}</div>\\r\\n                          <div className=\\\"file-meta text-xs text-gray-500\\\">\\r\\n                            {formatFileSize(file.size)}\\r\\n                          </div>\\r\\n                        </div>\\r\\n                      </div>\\r\\n                      <Button\\r\\n                        type=\\\"text\\\"\\r\\n                        size=\\\"small\\\"\\r\\n                        danger\\r\\n                        onClick={() => removeFile(file.name)}\\r\\n                      >\\r\\n                        移除\\r\\n                      </Button>\\r\\n                    </div>\\r\\n                  ))}\\r\\n                </div>\\r\\n              )}\\r\\n            </div>\\r\\n          )}\\r\\n        </div>\\r\\n      )}\\r\\n    </Modal>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default UploadModal; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\index.ts\",\n    \"newContent\": \"// 导出features目录下的所有组件\\r\\nexport * from './home';\\r\\nexport * from './dashboard';\\r\\nexport * from './user-profile';\\r\\nexport * from './file-management'; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\user-profile\\\\index.ts\",\n    \"newContent\": \"// 导出user-profile目录下的所有组件\\r\\nexport * from './avatar';\\r\\nexport * from './profileHeader';\\r\\nexport * from './profileContent';\\r\\nexport * from './completeness';\\r\\nexport * from './passwordForm';\\r\\nexport * from './editForm'; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\user-profile\\\\profileHeader\\\\ProfileHeader.tsx\",\n    \"newContent\": \"import React, { useState, useRef, useEffect } from 'react';\\r\\nimport Image from 'next/image';\\r\\nimport { Session } from 'next-auth';\\r\\nimport { UserInfo } from '@/app/dashboard/page';\\r\\nimport { Camera, Upload, Trash2 } from 'lucide-react';\\r\\nimport styles from './ProfileHeader.module.css';\\r\\nimport { AvatarModal } from '@/app/components/features/user-profile/avatar';\\r\\n\\r\\ninterface ProfileHeaderProps {\\r\\n  session: Session;\\r\\n  userInfo: UserInfo;\\r\\n  onEditClick: () => void;\\r\\n  onPasswordClick: () => void;\\r\\n  isLoading: boolean;\\r\\n  onAvatarChange?: (avatarUrl: string) => void;\\r\\n}\\r\\n\\r\\nconst ProfileHeader = ({ \\r\\n  session, \\r\\n  userInfo,\\r\\n  onEditClick, \\r\\n  onPasswordClick, \\r\\n  isLoading,\\r\\n  onAvatarChange\\r\\n}: ProfileHeaderProps) => {\\r\\n  const [avatarError, setAvatarError] = useState(false);\\r\\n  const [showAvatarModal, setShowAvatarModal] = useState(false);\\r\\n  \\r\\n  // 使用userInfo中的displayName作为首选，如果没有则使用session中的name\\r\\n  const displayName = userInfo.displayName || session.user?.name || '未设置昵称';\\r\\n  \\r\\n  // 获取用于头像占位符的首字母\\r\\n  const nameInitial = displayName[0]?.toUpperCase() || '?';\\r\\n\\r\\n  // 简化头像URL逻辑，直接使用userInfo中的头像或session头像\\r\\n  const effectiveAvatarUrl = userInfo.avatarUrl || session.user?.image;\\r\\n  \\r\\n  // 添加时间戳作为key的一部分，确保每次头像变更都会重新渲染\\r\\n  const [refreshKey, setRefreshKey] = useState(Date.now());\\r\\n  const avatarKey = `${effectiveAvatarUrl || 'fallback'}-${refreshKey}`;\\r\\n\\r\\n  // 添加useEffect监听userInfo.avatarUrl的变化\\r\\n  useEffect(() => {\\r\\n    setRefreshKey(Date.now()); // 强制头像重新渲染\\r\\n    setAvatarError(false); // 重置错误状态\\r\\n  }, [userInfo.avatarUrl]);\\r\\n\\r\\n  // 添加深度调试 - 监控props变化\\r\\n  useEffect(() => {\\r\\n    console.log('ProfileHeader收到新的userInfo:', \\r\\n      { \\r\\n        avatarUrl: userInfo.avatarUrl,\\r\\n        hasAvatar: !!userInfo.avatarUrl,\\r\\n        displayName: userInfo.displayName\\r\\n      }\\r\\n    );\\r\\n  }, [userInfo]);\\r\\n\\r\\n  // 打开头像管理弹窗\\r\\n  const handleAvatarClick = () => {\\r\\n    setShowAvatarModal(true);\\r\\n  };\\r\\n\\r\\n  // 处理头像变更\\r\\n  const handleAvatarChange = (newAvatarUrl: string) => {\\r\\n    if (onAvatarChange) {\\r\\n      onAvatarChange(newAvatarUrl);\\r\\n    }\\r\\n    // 强制刷新\\r\\n    setRefreshKey(Date.now());\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <div className={styles.header}>\\r\\n      <div className={styles.avatarContainer}>\\r\\n        <div className={styles.avatar} onClick={handleAvatarClick}>\\r\\n          {effectiveAvatarUrl && !avatarError ? (\\r\\n            <Image\\r\\n              key={avatarKey}\\r\\n              src={`${effectiveAvatarUrl}?t=${refreshKey}`}\\r\\n              alt=\\\"用户头像\\\"\\r\\n              width={160}\\r\\n              height={160}\\r\\n              className={styles.avatarImage}\\r\\n              priority\\r\\n              unoptimized={true}\\r\\n              onError={() => setAvatarError(true)}\\r\\n            />\\r\\n          ) : (\\r\\n            <div className={styles.avatarFallback}>\\r\\n              <span>{nameInitial}</span>\\r\\n            </div>\\r\\n          )}\\r\\n          \\r\\n          {/* 头像悬停覆盖层 */}\\r\\n          <div className={styles.avatarOverlay}>\\r\\n            <button \\r\\n              className={styles.avatarButton} \\r\\n              onClick={handleAvatarClick}\\r\\n              title=\\\"管理头像\\\"\\r\\n            >\\r\\n              <Camera size={24} />\\r\\n            </button>\\r\\n          </div>\\r\\n        </div>\\r\\n        <p className={styles.avatarHint}>点击更换头像</p>\\r\\n      </div>\\r\\n      \\r\\n      <div className={styles.info}>\\r\\n        <h1 className={styles.name}>{displayName}</h1>\\r\\n        <p className={styles.email}>{session.user?.email || '未设置邮箱'}</p>\\r\\n        <div className={styles.buttons}>\\r\\n          <button\\r\\n            onClick={onEditClick}\\r\\n            className={styles.editButton}\\r\\n            disabled={isLoading}\\r\\n          >\\r\\n            编辑个人信息\\r\\n          </button>\\r\\n          <button\\r\\n            onClick={onPasswordClick}\\r\\n            className={styles.passwordButton}\\r\\n            disabled={isLoading}\\r\\n          >\\r\\n            设置密码\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n      \\r\\n      {/* 头像管理弹窗 */}\\r\\n      <AvatarModal \\r\\n        isOpen={showAvatarModal}\\r\\n        onClose={() => setShowAvatarModal(false)}\\r\\n        currentAvatarUrl={effectiveAvatarUrl || null}\\r\\n        userDisplayName={displayName}\\r\\n        onAvatarChange={handleAvatarChange}\\r\\n      />\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default ProfileHeader; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\user-profile\\\\index.ts\",\n    \"newContent\": \"// 导出user-profile目录下的所有组件\\r\\nexport * from './avatar';\\r\\nexport * from './profileHeader';\\r\\nexport * from './profileContent';\\r\\nexport * from './completeness';\\r\\nexport * from './passwordForm';\\r\\nexport * from './editForm'; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\features\\\\user-profile\\\\profileHeader\\\\ProfileHeader.tsx\",\n    \"newContent\": \"import React, { useState, useRef, useEffect } from 'react';\\r\\nimport Image from 'next/image';\\r\\nimport { Session } from 'next-auth';\\r\\nimport { UserInfo } from '@/app/dashboard/page';\\r\\nimport { Camera, Upload, Trash2 } from 'lucide-react';\\r\\nimport styles from './ProfileHeader.module.css';\\r\\nimport { AvatarModal } from '@/app/components/features/user-profile/avatar';\\r\\n\\r\\ninterface ProfileHeaderProps {\\r\\n  session: Session;\\r\\n  userInfo: UserInfo;\\r\\n  onEditClick: () => void;\\r\\n  onPasswordClick: () => void;\\r\\n  isLoading: boolean;\\r\\n  onAvatarChange?: (avatarUrl: string) => void;\\r\\n}\\r\\n\\r\\nconst ProfileHeader = ({ \\r\\n  session, \\r\\n  userInfo,\\r\\n  onEditClick, \\r\\n  onPasswordClick, \\r\\n  isLoading,\\r\\n  onAvatarChange\\r\\n}: ProfileHeaderProps) => {\\r\\n  const [avatarError, setAvatarError] = useState(false);\\r\\n  const [showAvatarModal, setShowAvatarModal] = useState(false);\\r\\n  \\r\\n  // 使用userInfo中的displayName作为首选，如果没有则使用session中的name\\r\\n  const displayName = userInfo.displayName || session.user?.name || '未设置昵称';\\r\\n  \\r\\n  // 获取用于头像占位符的首字母\\r\\n  const nameInitial = displayName[0]?.toUpperCase() || '?';\\r\\n\\r\\n  // 简化头像URL逻辑，直接使用userInfo中的头像或session头像\\r\\n  const effectiveAvatarUrl = userInfo.avatarUrl || session.user?.image;\\r\\n  \\r\\n  // 添加时间戳作为key的一部分，确保每次头像变更都会重新渲染\\r\\n  const [refreshKey, setRefreshKey] = useState(Date.now());\\r\\n  const avatarKey = `${effectiveAvatarUrl || 'fallback'}-${refreshKey}`;\\r\\n\\r\\n  // 添加useEffect监听userInfo.avatarUrl的变化\\r\\n  useEffect(() => {\\r\\n    setRefreshKey(Date.now()); // 强制头像重新渲染\\r\\n    setAvatarError(false); // 重置错误状态\\r\\n  }, [userInfo.avatarUrl]);\\r\\n\\r\\n  // 添加深度调试 - 监控props变化\\r\\n  useEffect(() => {\\r\\n    console.log('ProfileHeader收到新的userInfo:', \\r\\n      { \\r\\n        avatarUrl: userInfo.avatarUrl,\\r\\n        hasAvatar: !!userInfo.avatarUrl,\\r\\n        displayName: userInfo.displayName\\r\\n      }\\r\\n    );\\r\\n  }, [userInfo]);\\r\\n\\r\\n  // 打开头像管理弹窗\\r\\n  const handleAvatarClick = () => {\\r\\n    setShowAvatarModal(true);\\r\\n  };\\r\\n\\r\\n  // 处理头像变更\\r\\n  const handleAvatarChange = (newAvatarUrl: string) => {\\r\\n    if (onAvatarChange) {\\r\\n      onAvatarChange(newAvatarUrl);\\r\\n    }\\r\\n    // 强制刷新\\r\\n    setRefreshKey(Date.now());\\r\\n  };\\r\\n\\r\\n  return (\\r\\n    <div className={styles.header}>\\r\\n      <div className={styles.avatarContainer}>\\r\\n        <div className={styles.avatar} onClick={handleAvatarClick}>\\r\\n          {effectiveAvatarUrl && !avatarError ? (\\r\\n            <Image\\r\\n              key={avatarKey}\\r\\n              src={`${effectiveAvatarUrl}?t=${refreshKey}`}\\r\\n              alt=\\\"用户头像\\\"\\r\\n              width={160}\\r\\n              height={160}\\r\\n              className={styles.avatarImage}\\r\\n              priority\\r\\n              unoptimized={true}\\r\\n              onError={() => setAvatarError(true)}\\r\\n            />\\r\\n          ) : (\\r\\n            <div className={styles.avatarFallback}>\\r\\n              <span>{nameInitial}</span>\\r\\n            </div>\\r\\n          )}\\r\\n          \\r\\n          {/* 头像悬停覆盖层 */}\\r\\n          <div className={styles.avatarOverlay}>\\r\\n            <button \\r\\n              className={styles.avatarButton} \\r\\n              onClick={handleAvatarClick}\\r\\n              title=\\\"管理头像\\\"\\r\\n            >\\r\\n              <Camera size={24} />\\r\\n            </button>\\r\\n          </div>\\r\\n        </div>\\r\\n        <p className={styles.avatarHint}>点击更换头像</p>\\r\\n      </div>\\r\\n      \\r\\n      <div className={styles.info}>\\r\\n        <h1 className={styles.name}>{displayName}</h1>\\r\\n        <p className={styles.email}>{session.user?.email || '未设置邮箱'}</p>\\r\\n        <div className={styles.buttons}>\\r\\n          <button\\r\\n            onClick={onEditClick}\\r\\n            className={styles.editButton}\\r\\n            disabled={isLoading}\\r\\n          >\\r\\n            编辑个人信息\\r\\n          </button>\\r\\n          <button\\r\\n            onClick={onPasswordClick}\\r\\n            className={styles.passwordButton}\\r\\n            disabled={isLoading}\\r\\n          >\\r\\n            设置密码\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n      \\r\\n      {/* 头像管理弹窗 */}\\r\\n      <AvatarModal \\r\\n        isOpen={showAvatarModal}\\r\\n        onClose={() => setShowAvatarModal(false)}\\r\\n        currentAvatarUrl={effectiveAvatarUrl || null}\\r\\n        userDisplayName={displayName}\\r\\n        onAvatarChange={handleAvatarChange}\\r\\n      />\\r\\n    </div>\\r\\n  );\\r\\n};\\r\\n\\r\\nexport default ProfileHeader; \"\n  },\n  {\n    \"path\": \"app\\\\components\\\\index.ts\",\n    \"newContent\": \"/**\\r\\n * 组件库索引文件\\r\\n * \\r\\n * 所有组件已按照原子设计模式进行重组：\\r\\n * - ui/: 基础UI组件\\r\\n *   - atoms/: 原子级组件（按钮、输入框等）\\r\\n *   - molecules/: 分子级组件（复合UI元素）\\r\\n *   - organisms/: 有机体组件（完整UI区块）\\r\\n * \\r\\n * - common/: 通用功能组件\\r\\n *   - feedback/: 反馈类组件（提示、通知等）\\r\\n *   - form/: 表单相关组件\\r\\n *   - media/: 媒体组件（音视频等）\\r\\n * \\r\\n * - features/: 业务功能组件\\r\\n *   - dashboard/: 仪表盘相关组件\\r\\n *   - file-management/: 文件管理组件\\r\\n *   - home/: 首页相关组件\\r\\n *   - user-profile/: 用户资料组件\\r\\n * \\r\\n * 为保持向后兼容性，所有组件可以从根路径直接导入\\r\\n */\\r\\n\\r\\n// 从新的目录结构中重新导出组件\\r\\n// UI组件\\r\\nexport * from './ui';\\r\\n\\r\\n// 导航组件\\r\\nexport { default as Navbar } from './features/dashboard/navigation/Navbar';\\r\\n\\r\\n// 文件管理组件\\r\\nexport { default as UploadModal } from './features/file-management/upload/UploadModal';\\r\\nexport { default as FileUpload } from './features/file-management/upload/FileUpload';\\r\\nexport { default as TopActionBar } from './features/file-management/actionBar/TopActionBar';\\r\\nexport { default as SortDropdown } from './features/file-management/actionBar/SortDropdown';\\r\\nexport { default as NewFolderForm } from './features/file-management/folderManagement/NewFolderForm';\\r\\nexport { default as Toolbar } from './features/file-management/toolbar/Toolbar';\\r\\n\\r\\n// 分析组件\\r\\nexport { default as StorageUsage } from './features/dashboard/analytics/StorageUsage';\\r\\n\\r\\n// 媒体组件\\r\\nexport { default as AudioVisualizer } from './common/media/AudioVisualizer';\\r\\n\\r\\n// 用户资料组件\\r\\nexport { default as ProfileHeader } from './features/user-profile/profileHeader';\\r\\nexport { default as ProfileCompleteness } from './features/user-profile/completeness';\\r\\nexport { default as PasswordForm } from './features/user-profile/passwordForm';\\r\\nexport { default as EditProfileForm } from './features/user-profile/editForm';\\r\\nexport * from './features/user-profile/avatar';\\r\\n\\r\\n// 表单组件\\r\\nexport * from './common/form';\\r\\n\\r\\n// 反馈组件\\r\\nexport { default as Toaster } from './common/feedback/toast';\\r\\n\\r\\n// 首页组件\\r\\nexport { default as Hero } from './features/home/hero';\\r\\nexport { default as HomeHeader } from './features/home/header';\\r\\nexport { default as Footer } from './features/home/footer';\\r\\nexport { default as Features } from './features/home/features';\\r\\nexport { default as CTA } from './features/home/cta'; \"\n  },\n  {\n    \"path\": \"app\\\\dashboard\\\\page.tsx\",\n    \"newContent\": \"\\\"use client\\\"\\r\\n\\r\\nimport { useSession } from \\\"next-auth/react\\\"\\r\\nimport { useRouter } from 'next/navigation'\\r\\nimport { useState, useEffect, useRef } from \\\"react\\\"\\r\\nimport { ArrowLeft } from 'lucide-react'\\r\\n\\r\\n// 导入自定义钩子\\r\\nimport { useProfile, usePassword, UserProfile, UserProfileInput } from '@/app/hooks'\\r\\nimport { useToast } from '@/app/components/features/dashboard/Toaster'\\r\\nimport { useValidation } from './hooks/useValidation'\\r\\n// 导入主题服务\\r\\nimport { applyTheme as applyThemeService } from '@/app/shared/themes'\\r\\n\\r\\n// 导入组件\\r\\nimport Modal from '@/app/components/features/dashboard/Modal'\\r\\nimport ProfileHeader from '@/app/components/features/dashboard/ProfileHeader'\\r\\nimport ProfileContent from '@/app/components/features/dashboard/ProfileContent'\\r\\nimport EditProfileForm from '@/app/components/features/dashboard/EditProfileForm'\\r\\nimport PasswordForm from '@/app/components/features/dashboard/PasswordForm'\\r\\nimport ProfileCompleteness from '@/app/components/features/dashboard/ProfileCompleteness'\\r\\n\\r\\n// 创建兼容旧组件的UserInfo接口\\r\\nexport interface UserInfo {\\r\\n  displayName: string;\\r\\n  bio: string;\\r\\n  location: string;\\r\\n  website: string;\\r\\n  company: string;\\r\\n  avatarUrl?: string | null; \\r\\n  theme?: string | null;     \\r\\n  createdAt?: string;        \\r\\n}\\r\\n\\r\\n// 导入样式\\r\\nimport styles from './Dashboard.module.css'\\r\\n\\r\\nexport default function DashboardPage() {\\r\\n  const router = useRouter()\\r\\n  const { data: session, status } = useSession({\\r\\n    required: true,\\r\\n    onUnauthenticated() {\\r\\n      router.push('/auth/login')\\r\\n    },\\r\\n  })\\r\\n  \\r\\n  const [isEditModalOpen, setIsEditModalOpen] = useState(false)\\r\\n  const [isPasswordModalOpen, setIsPasswordModalOpen] = useState(false)\\r\\n  \\r\\n  const { \\r\\n    user-profile, \\r\\n    isLoading: profileLoading, \\r\\n    error: profileError, \\r\\n    updateUserProfile,\\r\\n    effectiveAvatarUrl\\r\\n  } = useProfile()\\r\\n  \\r\\n  // 创建一个本地状态用于编辑，兼容旧的UserInfo格式\\r\\n  const [userInfo, setUserInfo] = useState<UserInfo>({\\r\\n    displayName: '',\\r\\n    bio: '',\\r\\n    location: '',\\r\\n    website: '',\\r\\n    company: '',\\r\\n    avatarUrl: null,\\r\\n    theme: null\\r\\n  })\\r\\n  \\r\\n  // 当user-profile更新时，同步更新userInfo\\r\\n  useEffect(() => {\\r\\n    if (user-profile) {\\r\\n      setUserInfo({\\r\\n        displayName: user-profile.name || '',\\r\\n        bio: user-profile.bio || '',\\r\\n        location: user-profile.location || '',\\r\\n        website: user-profile.website || '',\\r\\n        company: user-profile.company || '',\\r\\n        avatarUrl: user-profile.avatarUrl,\\r\\n        theme: user-profile.theme,\\r\\n        createdAt: user-profile.createdAt\\r\\n      })\\r\\n    }\\r\\n  }, [user-profile])\\r\\n  \\r\\n  const {\\r\\n    passwordInfo,\\r\\n    passwordError,\\r\\n    passwordSuccess,\\r\\n    isLoading: passwordLoading,\\r\\n    showPassword,\\r\\n    showConfirmPassword,\\r\\n    setShowPassword,\\r\\n    setShowConfirmPassword,\\r\\n    handlePasswordChange,\\r\\n    updatePassword,\\r\\n    resetPasswordState\\r\\n  } = usePassword()\\r\\n\\r\\n  const [isSaving, setIsSaving] = useState(false)\\r\\n  const toast = useToast()\\r\\n  const { validateForm } = useValidation()\\r\\n\\r\\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, field: string) => {\\r\\n    setUserInfo(prev => ({...prev, [field]: e.target.value}))\\r\\n  }\\r\\n\\r\\n  const handleSave = async () => {\\r\\n    try {\\r\\n      console.log('保存用户资料:', userInfo);\\r\\n      \\r\\n      // 表单验证\\r\\n      if (!validateForm(userInfo)) {\\r\\n        toast.error('请修正表单中的错误后再提交');\\r\\n        return;\\r\\n      }\\r\\n      \\r\\n      // 禁用保存按钮，防止重复提交\\r\\n      setIsSaving(true);\\r\\n      \\r\\n      // 转换为UserProfileInput格式\\r\\n      const profileInput: UserProfileInput = {\\r\\n        displayName: userInfo.displayName,\\r\\n        bio: userInfo.bio,\\r\\n        location: userInfo.location,\\r\\n        website: userInfo.website,\\r\\n        company: userInfo.company,\\r\\n        // 仅在非null时包含avatarUrl\\r\\n        ...(userInfo.avatarUrl && { avatarUrl: userInfo.avatarUrl }),\\r\\n        // 仅在非null时包含theme\\r\\n        ...(userInfo.theme && { theme: userInfo.theme })\\r\\n      };\\r\\n      \\r\\n      const success = await updateUserProfile(profileInput);\\r\\n      \\r\\n      if (success) {\\r\\n        setIsEditModalOpen(false);\\r\\n        // 使用Toast通知替代alert\\r\\n        toast.success('个人信息已成功保存！');\\r\\n      } else {\\r\\n        // 保存失败提示\\r\\n        toast.error('保存失败，请稍后重试');\\r\\n      }\\r\\n    } catch (error) {\\r\\n      console.error('保存用户资料时出错:', error);\\r\\n      toast.error('发生错误，请稍后重试');\\r\\n    } finally {\\r\\n      // 无论成功还是失败，都重新启用保存按钮\\r\\n      setIsSaving(false);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  const handlePasswordSave = async () => {\\r\\n    const success = await updatePassword()\\r\\n    if (success) {\\r\\n      setIsPasswordModalOpen(false)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  const openPasswordModal = () => {\\r\\n    resetPasswordState()\\r\\n    setIsPasswordModalOpen(true)\\r\\n  }\\r\\n\\r\\n  // 应用主题\\r\\n  useEffect(() => {\\r\\n    if (user-profile?.theme) {\\r\\n      applyTheme(user-profile.theme);\\r\\n    }\\r\\n  }, [user-profile?.theme]);\\r\\n\\r\\n  // 处理主题更改\\r\\n  const handleThemeChange = async (themeId: string) => {\\r\\n    // 先立即在本地应用主题，提升用户体验\\r\\n    applyTheme(themeId);\\r\\n    \\r\\n    // 更新用户资料中的主题\\r\\n    try {\\r\\n      const profileInput: UserProfileInput = {\\r\\n        theme: themeId\\r\\n      };\\r\\n      const success = await updateUserProfile(profileInput);\\r\\n      if (success) {\\r\\n        console.log(`主题 ${themeId} 已成功应用并保存到服务器`);\\r\\n      } else {\\r\\n        console.warn(`主题 ${themeId} 已在本地应用，但未能保存到服务器`);\\r\\n      }\\r\\n      return success;\\r\\n    } catch (error) {\\r\\n      console.error(`主题 ${themeId} 应用发生错误:`, error);\\r\\n      // 即使保存失败，本地主题已应用，所以依然返回true让UI保持已选状态\\r\\n      return true;\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // 将主题应用到文档 - 使用统一的主题服务\\r\\n  const applyTheme = (theme: string) => {\\r\\n    applyThemeService(theme);\\r\\n  };\\r\\n\\r\\n  // 引用ProfileHeader中的fileInputRef\\r\\n  const fileInputRef = useRef<HTMLInputElement>(null);\\r\\n\\r\\n  // 触发头像上传功能\\r\\n  const handleAvatarClick = () => {\\r\\n    console.log('资料完整度头像点击被触发');\\r\\n    \\r\\n    // 首先尝试使用特定的class查找\\r\\n    const avatarInput = document.querySelector('.avatar-upload-input');\\r\\n    if (avatarInput && avatarInput instanceof HTMLInputElement) {\\r\\n      console.log('通过class找到头像上传input，触发点击');\\r\\n      avatarInput.click();\\r\\n      return;\\r\\n    }\\r\\n    \\r\\n    // 备用方案1：通过容器class查找\\r\\n    const containerInput = document.querySelector('.avatarContainer input[type=\\\"file\\\"]');\\r\\n    if (containerInput && containerInput instanceof HTMLInputElement) {\\r\\n      console.log('通过容器找到头像上传input，触发点击');\\r\\n      containerInput.click();\\r\\n      return;\\r\\n    }\\r\\n    \\r\\n    // 备用方案2：查找所有文件上传input\\r\\n    console.error('未找到精确的头像上传input元素，尝试查找所有图片上传控件');\\r\\n    const fileInputs = document.querySelectorAll('input[type=\\\"file\\\"]');\\r\\n    let found = false;\\r\\n    fileInputs.forEach(input => {\\r\\n      const fileInput = input as HTMLInputElement;\\r\\n      if (fileInput.accept && fileInput.accept.includes('image')) {\\r\\n        console.log('找到备选图片上传input，触发点击');\\r\\n        fileInput.click();\\r\\n        found = true;\\r\\n        return;\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    if (!found) {\\r\\n      console.error('无法找到任何图片上传控件');\\r\\n      alert('无法找到头像上传控件，请尝试直接点击头像进行上传');\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // 加载状态\\r\\n  if (status === 'loading' || profileLoading) {\\r\\n    return (\\r\\n      <div className={styles.loading}>\\r\\n        <div className={styles.loadingCard}>\\r\\n          <div className={styles.loadingSpinner}></div>\\r\\n          <h2 className={styles.loadingTitle}>加载中...</h2>\\r\\n          <p className={styles.loadingText}>正在获取您的个人信息</p>\\r\\n        </div>\\r\\n      </div>\\r\\n    )\\r\\n  }\\r\\n\\r\\n  // 错误状态\\r\\n  if (profileError) {\\r\\n    return (\\r\\n      <div className={styles.errorContainer}>\\r\\n        <div className={styles.errorCard}>\\r\\n          <div className={styles.errorIcon}>⚠️</div>\\r\\n          <h2 className={styles.errorTitle}>加载失败</h2>\\r\\n          <p className={styles.errorText}>{profileError}</p>\\r\\n          <button\\r\\n            onClick={() => window.location.reload()}\\r\\n            className={styles.retryButton}\\r\\n          >\\r\\n            重试\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n    )\\r\\n  }\\r\\n\\r\\n  // 未登录\\r\\n  if (!session?.user) {\\r\\n    return null\\r\\n  }\\r\\n\\r\\n  // 编辑个人信息弹窗底部按钮\\r\\n  const renderEditFooter = () => (\\r\\n    <div className={styles.modalFooterButtons}>\\r\\n      <button\\r\\n        onClick={() => setIsEditModalOpen(false)}\\r\\n        className={styles.cancelButton}\\r\\n        disabled={isSaving}\\r\\n      >\\r\\n        取消\\r\\n      </button>\\r\\n      <button\\r\\n        onClick={handleSave}\\r\\n        className={styles.saveButton}\\r\\n        disabled={isSaving}\\r\\n      >\\r\\n        {isSaving ? '保存中...' : '保存更改'}\\r\\n      </button>\\r\\n    </div>\\r\\n  );\\r\\n\\r\\n  // 设置密码弹窗底部按钮\\r\\n  const renderPasswordFooter = () => (\\r\\n    <div className={styles.modalFooterButtons}>\\r\\n      <button\\r\\n        onClick={() => setIsPasswordModalOpen(false)}\\r\\n        className={styles.cancelButton}\\r\\n      >\\r\\n        取消\\r\\n      </button>\\r\\n      <button\\r\\n        onClick={handlePasswordSave}\\r\\n        className={styles.saveButton}\\r\\n        disabled={passwordLoading}\\r\\n      >\\r\\n        保存密码\\r\\n      </button>\\r\\n    </div>\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <div className={styles.container}>\\r\\n      <div className={styles.profile}>\\r\\n        {/* 返回按钮 */}\\r\\n        <button \\r\\n          onClick={() => router.push('/file-management/main')}\\r\\n          className={styles.backButton}\\r\\n          title=\\\"返回文件管理\\\"\\r\\n        >\\r\\n          <ArrowLeft className=\\\"w-5 h-5\\\" />\\r\\n        </button>\\r\\n        \\r\\n        <div className={styles.profileHeader}>\\r\\n          {/* 个人资料头部 */}\\r\\n          <ProfileHeader \\r\\n            session={session}\\r\\n            userInfo={userInfo}\\r\\n            onEditClick={() => setIsEditModalOpen(true)}\\r\\n            onPasswordClick={openPasswordModal}\\r\\n            isLoading={profileLoading || passwordLoading}\\r\\n            onAvatarChange={async (avatarUrl) => {\\r\\n              console.log('头像变更被触发，新URL:', avatarUrl);\\r\\n              \\r\\n              try {\\r\\n                // 创建新的userInfo对象\\r\\n                const updatedInfo = {...userInfo, avatarUrl};\\r\\n                console.log('更新后的userInfo:', updatedInfo);\\r\\n                \\r\\n                // 更新本地状态\\r\\n                setUserInfo(updatedInfo);\\r\\n                \\r\\n                // 转换为UserProfileInput格式\\r\\n                const profileInput: UserProfileInput = {\\r\\n                  displayName: updatedInfo.displayName,\\r\\n                  bio: updatedInfo.bio,\\r\\n                  location: updatedInfo.location,\\r\\n                  website: updatedInfo.website,\\r\\n                  company: updatedInfo.company,\\r\\n                  avatarUrl: updatedInfo.avatarUrl,\\r\\n                  // 仅在theme不为null时包含\\r\\n                  ...(updatedInfo.theme && { theme: updatedInfo.theme })\\r\\n                };\\r\\n                \\r\\n                // 保存到数据库并等待完成\\r\\n                const success = await updateUserProfile(profileInput);\\r\\n                console.log('保存头像到数据库结果:', success ? '成功' : '失败');\\r\\n                \\r\\n                // 如果保存失败，强制重新获取用户数据\\r\\n                if (!success) {\\r\\n                  window.location.reload(); // 最后的手段：刷新整个页面\\r\\n                }\\r\\n              } catch (error) {\\r\\n                console.error('处理头像变更时出错:', error);\\r\\n                alert('更新头像失败，请稍后再试');\\r\\n              }\\r\\n            }}\\r\\n          />\\r\\n        </div>\\r\\n        \\r\\n        {/* 资料完整度 */}\\r\\n        <ProfileCompleteness \\r\\n          userInfo={userInfo} \\r\\n          onEditClick={() => setIsEditModalOpen(true)}\\r\\n          onAvatarClick={handleAvatarClick}\\r\\n        />\\r\\n        \\r\\n        {/* 个人资料内容 */}\\r\\n        <ProfileContent \\r\\n          session={session}\\r\\n          userInfo={userInfo}\\r\\n          isLoading={profileLoading || passwordLoading}\\r\\n        />\\r\\n      </div>\\r\\n\\r\\n      {/* 编辑个人信息弹窗 */}\\r\\n      <Modal\\r\\n        isOpen={isEditModalOpen}\\r\\n        onClose={() => setIsEditModalOpen(false)}\\r\\n        title=\\\"编辑个人信息\\\"\\r\\n        footer={renderEditFooter()}\\r\\n      >\\r\\n        <EditProfileForm \\r\\n          userInfo={userInfo}\\r\\n          onInputChange={handleInputChange}\\r\\n        />\\r\\n      </Modal>\\r\\n\\r\\n      {/* 设置密码弹窗 */}\\r\\n      <Modal\\r\\n        isOpen={isPasswordModalOpen}\\r\\n        onClose={() => setIsPasswordModalOpen(false)}\\r\\n        title=\\\"设置密码\\\"\\r\\n        footer={renderPasswordFooter()}\\r\\n      >\\r\\n        <PasswordForm\\r\\n          passwordInfo={passwordInfo}\\r\\n          passwordError={passwordError}\\r\\n          passwordSuccess={passwordSuccess}\\r\\n          showPassword={showPassword}\\r\\n          showConfirmPassword={showConfirmPassword}\\r\\n          setShowPassword={setShowPassword}\\r\\n          setShowConfirmPassword={setShowConfirmPassword}\\r\\n          handlePasswordChange={handlePasswordChange}\\r\\n          userEmail={session.user.email}\\r\\n        />\\r\\n      </Modal>\\r\\n    </div>\\r\\n  )\\r\\n} \"\n  },\n  {\n    \"path\": \"app\\\\file-management\\\\main\\\\page.tsx\",\n    \"newContent\": \"// @ts-nocheck\\n'use client';\\n\\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\\nimport { useSession, signOut } from 'next-auth/react';\\nimport { useRouter } from 'next/navigation';\\nimport { message, Spin } from 'antd';\\nimport Head from 'next/head';\\n\\n// 引入共享组件\\nimport { Sidebar } from '@/app/components/features/file-management/navigation/Sidebar';\\nimport { Breadcrumb } from '@/app/components/features/file-management/navigation/Breadcrumb';\\nimport { FileList } from '@/app/components/features/file-management/fileList/FileList';\\nimport { SkeletonPageLayout } from '@/app/components/features/file-management/shared/Skeleton';\\nimport { ErrorDisplay } from '@/app/components/features/file-management/shared/ErrorDisplay';\\nimport UploadModal from '@/app/components/features/file-management/upload/UploadModal';\\nimport { FilePreview } from '@/app/components/features/file-management/filePreview/FilePreview';\\nimport { RenameModal } from '@/app/components/features/file-management/fileOperations/RenameModal';\\nimport ThemePanel from '@/app/shared/themes/components/ThemePanel';\\n\\n// 导入自定义组件\\nimport MiniSidebar from '@/app/components/features/file-management/navigation/MiniSidebar';\\nimport { TopActionBar } from '@/app/components/features/file-management/actionBar/TopActionBar';\\nimport NewFolderForm from '@/app/components/features/file-management/folderManagement/NewFolderForm';\\nimport { SearchView } from '@/app/components/features/file-management/SearchView';\\n\\n// 导入自定义 hooks\\nimport { \\n  useFiles, \\n  useFileOperations, \\n  useFileUpload, \\n  useFileSearch, \\n  useFilePreview,\\n  useLoadingState, \\n  useUIState, \\n  useThemeManager, \\n  useProfile \\n} from '@/app/hooks';\\n// 导入类型和工具函数\\nimport { SortOrder, FileInfo } from '@/app/types';\\nimport { convertFilesForDisplay } from '@/app/utils/file/converter';\\n\\n// 导入样式\\nimport styles from '../styles/shared.module.css';\\n\\nexport default function FileManagementPage() {\\n  const router = useRouter();\\n  const { data: session, status } = useSession();\\n  \\n  // 获取用户资料相关状态，包括加载状态\\n  const { \\n    user-profile, \\n    isLoading: profileLoading, \\n    error: profileError,\\n    fetchUserProfile, \\n    forceRefreshProfile,\\n    effectiveAvatarUrl\\n  } = useProfile();\\n\\n  // 使用主题管理hook\\n  const { currentTheme, updateTheme } = useThemeManager();\\n\\n  // 使用双状态加载管理\\n  const {\\n    loadingState,\\n    error: loadingError,\\n    isInitialLoading,\\n    isRefreshing,\\n    isError: isLoadingError,\\n    startLoading,\\n    finishLoading\\n  } = useLoadingState({\\n    initialLoad: true,\\n    minLoadingTime: 800\\n  });\\n  \\n  // 使用useFiles钩子获取文件列表和相关操作\\n  const {\\n    files,\\n    isLoading: filesLoading,\\n    error: filesError,\\n    currentFolderId,\\n    folderPath,\\n    selectedFileType,\\n    selectedFiles,\\n    sortOrder,\\n    loadFiles,\\n    toggleSelectFile: handleSelectFile,\\n    toggleSelectAll,\\n    changeSort,\\n    filterByFileType,\\n    openFolder,\\n    refreshCurrentFolder,\\n    handleFileClick,\\n    handleBackClick,\\n    handleFileUpdate,\\n    setCurrentFolderId,\\n    setFolderPath,\\n    setSelectedFileType,\\n    setSelectedFiles,\\n    setSortOrder\\n  } = useFiles();\\n\\n  // UI状态管理\\n  const {\\n    sidebarVisible,\\n    myFilesExpanded,\\n    quickAccessExpanded,\\n    isUploadModalOpen,\\n    isFolderUploadModalOpen,\\n    showUploadDropdown,\\n    setSidebarVisible,\\n    setMyFilesExpanded,\\n    setQuickAccessExpanded,\\n    setIsUploadModalOpen,\\n    setIsFolderUploadModalOpen,\\n    setShowUploadDropdown,\\n    uploadDropdownRef\\n  } = useUIState();\\n\\n  // 添加主题面板状态\\n  const [showThemePanel, setShowThemePanel] = useState(false);\\n\\n  // 文件操作钩子\\n  const {\\n    createFolder: handleCreateFolder,\\n    downloadFiles: handleDownload,\\n    deleteFiles: handleDelete,\\n    renameFile: handleRenameFile,\\n    isLoading: fileOperationsLoading,\\n    error: fileOperationsError\\n  } = useFileOperations([]);\\n\\n  // 先调用文件搜索钩子，确保updateFileInResults可用\\n  const {\\n    searchQuery,\\n    setSearchQuery,\\n    searchResults,\\n    isLoading: searchLoading,\\n    error: searchError,\\n    showSearchView,\\n    setShowSearchView,\\n    searchType,\\n    setSearchType,\\n    enableRealTimeSearch,\\n    setEnableRealTimeSearch,\\n    debounceDelay,\\n    setDebounceDelay,\\n    handleSearch,\\n    updateFileInResults\\n  } = useFileSearch();\\n\\n  // 文件预览和重命名 - 传入selectedFileType参数\\n  const {\\n    previewFile,\\n    setPreviewFile,\\n    handlePreview: handlePreviewFile,\\n    closePreview: handleClosePreview,\\n    isRenameModalOpen,\\n    setIsRenameModalOpen,\\n    fileToRename,\\n    setFileToRename,\\n    openRename: handleRenameButtonClick,\\n    renameFile: handleConfirmEdit\\n  } = useFilePreview({\\n    onRefresh: () => loadFiles(currentFolderId, selectedFileType, true),\\n    onFileUpdate: handleFileUpdate,  // 传入文件更新处理函数\\n    onSearchResultsUpdate: updateFileInResults,  // 传入搜索结果更新函数\\n    selectedFileType  // 传入当前选择的文件类型\\n  });\\n\\n  // 添加创建文件夹相关状态\\n  const [isCreatingFolder, setIsCreatingFolder] = useState(false);\\n  const [newFolderName, setNewFolderName] = useState('');\\n  const [newFolderTags, setNewFolderTags] = useState<string[]>([]);\\n  const [editingFile, setEditingFile] = useState<any>(null);\\n  const [editingName, setEditingName] = useState('');\\n  const [editingTags, setEditingTags] = useState<string[]>([]);\\n  const [newTag, setNewTag] = useState('');\\n  const [selectedFile, setSelectedFile] = useState<FileInfo | null>(null);\\n\\n  // 文件上下文菜单处理 - 移至hooks声明区域\\n  const handleFileContextMenu = useCallback((e, file, setSelectedFile, setSelectedFiles) => {\\n    // 阻止默认右键菜单\\n    e?.preventDefault();\\n    e?.stopPropagation();\\n    \\n    if (file) {\\n      // 设置当前选中的文件\\n      setSelectedFile?.(file);\\n      \\n      // 如果是单击选择，只选择当前文件\\n      if (e?.type === 'contextmenu') {\\n        setSelectedFiles?.([file.id]);\\n      }\\n      \\n      // 如果是文件（不是文件夹），可以设置为要重命名的文件\\n      if (!file.isFolder) {\\n        setFileToRename(file);\\n      }\\n    }\\n  }, [setFileToRename]);\\n\\n  // 标签相关处理函数\\n  const handleAddTag = useCallback((tag: string) => {\\n    if (editingFile) {\\n      setEditingTags(prev => [...prev, tag]);\\n    } else {\\n      setNewFolderTags(prev => [...prev, tag]);\\n    }\\n    setNewTag('');\\n  }, [editingFile]);\\n\\n  const handleRemoveTag = useCallback((tag: string) => {\\n    if (editingFile) {\\n      setEditingTags(prev => prev.filter(t => t !== tag));\\n    } else {\\n      setNewFolderTags(prev => prev.filter(t => t !== tag));\\n    }\\n  }, [editingFile]);\\n\\n  // 状态跟踪引用\\n  const hasLoadedFilesRef = React.useRef(false);\\n  const sessionInitializedRef = React.useRef(false);\\n  // 添加防止重复加载的标志，放在顶层\\n  const loadInProgressRef = useRef(false);\\n\\n  // 在文件上传或文件夹上传成功后触发的函数\\n  const handleUploadSuccess = useCallback(() => {\\n    // 开始刷新加载状态\\n    startLoading(true);\\n    \\n    // 刷新文件列表，保持当前文件类型过滤，并强制刷新\\n    loadFiles(currentFolderId, selectedFileType, true).finally(() => {\\n      finishLoading();\\n    });\\n  }, [currentFolderId, loadFiles, selectedFileType, startLoading, finishLoading]);\\n\\n  // 处理创建文件夹按钮点击\\n  const handleCreateFolderClick = useCallback(() => {\\n    setIsCreatingFolder(true);\\n  }, [setIsCreatingFolder]);\\n\\n  const handleSignOut = useCallback(async () => {\\n    try {\\n      await signOut({ \\n        callbackUrl: '/',\\n        redirect: true \\n      });\\n    } catch (error) {\\n      console.error('退出时发生错误:', error);\\n      // 如果发生错误，尝试强制跳转到首页\\n      window.location.href = '/';\\n    }\\n  }, []);\\n\\n  // Sidebar中\\\"搜索文件\\\"点击处理函数\\n  const handleSearchClick = useCallback(() => {\\n    setShowSearchView(true);\\n  }, [setShowSearchView]);\\n\\n  // 处理文件点击\\n  const handleFileItemClick = useCallback((file) => {\\n    const localFile = files.find(f => f.id === file.id);\\n    if (!localFile) return;\\n\\n    if (localFile.isFolder) {\\n      // 如果是文件夹，继续使用原有的导航逻辑\\n      handleFileClick(localFile);\\n    } else {\\n      // 如果是文件，打开预览\\n      handlePreviewFile(localFile);\\n    }\\n  }, [files, handleFileClick, handlePreviewFile]);\\n\\n  // 处理全选文件\\n  const onSelectAllFiles = useCallback(() => {\\n    setSelectedFiles(files.map(file => file.id));\\n  }, [files, setSelectedFiles]);\\n\\n  // 处理取消全选\\n  const onDeselectAllFiles = useCallback(() => {\\n    setSelectedFiles([]);\\n  }, [setSelectedFiles]);\\n\\n  // 处理文件复选框变化\\n  const onFileCheckboxChange = useCallback((file: FileInfo, checked: boolean) => {\\n    handleSelectFile(file.id, checked);\\n  }, [handleSelectFile]);\\n\\n  // 处理返回根目录/清除过滤器 - 移到这里\\n  const handleClearFilter = useCallback(() => {\\n    setShowSearchView(false);\\n    setSelectedFileType(null);\\n    setCurrentFolderId(null);\\n    setFolderPath([]);\\n    \\n    // 开始刷新加载状态\\n    startLoading(true);\\n    \\n    // 传递null类型参数以确保清除过滤，并强制刷新\\n    loadFiles(null, null, true)\\n      .finally(() => finishLoading());\\n  }, [setShowSearchView, setSelectedFileType, setCurrentFolderId, setFolderPath, startLoading, loadFiles, finishLoading]);\\n\\n  // 处理根目录点击 - 移到这里\\n  const handleRootClick = useCallback(() => {\\n    setCurrentFolderId(null);\\n    setFolderPath([]);\\n    \\n    // 开始刷新加载状态\\n    startLoading(true);\\n    \\n    // 保持当前选中的文件类型，并强制刷新\\n    loadFiles(null, selectedFileType, true)\\n      .finally(() => finishLoading());\\n  }, [setCurrentFolderId, setFolderPath, startLoading, loadFiles, selectedFileType, finishLoading]);\\n\\n  // 重定向逻辑优化\\n  useEffect(() => {\\n    // 只在状态确定时执行，避免初始loading状态触发重定向\\n    if (status === 'unauthenticated') {\\n      console.log('用户未认证，重定向到登录页面');\\n      router.replace('/auth/login');\\n    } else if (status === 'authenticated') {\\n      console.log('用户已认证，确认会话状态');\\n      sessionInitializedRef.current = true;\\n    }\\n  }, [status, router]);\\n\\n  // 文件加载逻辑优化\\n  useEffect(() => {\\n    // 确保session存在且状态为已认证，且文件未加载过\\n    if (status === 'authenticated' && session?.user && !hasLoadedFilesRef.current && !loadInProgressRef.current) {\\n      console.log('初始加载文件列表', { currentFolderId, selectedFileType, session: !!session });\\n      \\n      // 标记已经开始加载\\n      hasLoadedFilesRef.current = true;\\n      loadInProgressRef.current = true;\\n      \\n      // 开始加载，这是初始加载，使用骨架屏\\n      startLoading(false);\\n      \\n      // 添加延迟，确保session完全初始化\\n      setTimeout(() => {\\n        // 修改为先加载用户资料，成功后再加载文件列表\\n        fetchUserProfile()\\n          .then(user-profileData => {\\n            if (user-profileData) {\\n              console.log('用户资料加载成功，继续加载文件列表');\\n              // 只有在用户资料加载成功后才加载文件列表，并强制刷新\\n              return loadFiles(currentFolderId, selectedFileType, true)\\n                .then(() => {\\n                  console.log('文件列表加载成功，完成初始化加载');\\n                  finishLoading(false);\\n                  loadInProgressRef.current = false;\\n                })\\n                .catch(error => {\\n                  console.error('加载文件列表失败:', error);\\n                  finishLoading(true, '加载文件列表失败');\\n                  loadInProgressRef.current = false;\\n                });\\n            } else {\\n              console.log('用户资料为空，尝试重新获取...');\\n              // 增加重试延迟，确保session稳定\\n              return new Promise(resolve => setTimeout(resolve, 1000))\\n                .then(() => fetchUserProfile(true)) // 强制刷新模式\\n                .then(retryProfileData => {\\n                  if (retryProfileData) {\\n                    console.log('重试获取用户资料成功，继续加载文件列表');\\n                    return loadFiles(currentFolderId, selectedFileType, true)\\n                      .then(() => {\\n                        console.log('文件列表加载成功，完成初始化加载');\\n                        finishLoading(false);\\n                        loadInProgressRef.current = false;\\n                      })\\n                      .catch(error => {\\n                        console.error('加载文件列表失败:', error);\\n                        finishLoading(true, '加载文件列表失败');\\n                        loadInProgressRef.current = false;\\n                      });\\n                  } else {\\n                    console.error('重试获取用户资料失败');\\n                    loadInProgressRef.current = false;\\n                    throw new Error(\\\"获取用户资料失败，请刷新页面重试\\\");\\n                  }\\n                });\\n            }\\n          })\\n          .catch((error) => {\\n            console.error('加载过程出错:', error);\\n            // 再次尝试获取用户资料，加强容错性\\n            setTimeout(() => {\\n              console.log('最后一次尝试获取用户资料...');\\n              fetchUserProfile(true)\\n                .then(lastTryProfile => {\\n                  if (lastTryProfile) {\\n                    console.log('最后尝试成功，继续加载文件列表');\\n                    loadFiles(currentFolderId, selectedFileType, true)\\n                      .then(() => {\\n                        finishLoading(false);\\n                        loadInProgressRef.current = false;\\n                      })\\n                      .catch(err => {\\n                        finishLoading(true, '加载文件列表失败');\\n                        loadInProgressRef.current = false;\\n                      });\\n                  } else {\\n                    finishLoading(true, '获取用户资料失败，请刷新页面重试');\\n                    loadInProgressRef.current = false;\\n                  }\\n                })\\n                .catch(err => {\\n                  finishLoading(true, err.message || '加载失败，请重试');\\n                  loadInProgressRef.current = false;\\n                });\\n            }, 1500);\\n          });\\n      }, 500); // 短暂延迟，等待session稳定\\n    }\\n  }, [status, session, currentFolderId, selectedFileType, loadFiles, fetchUserProfile, startLoading, finishLoading]);\\n\\n  // 初始化Lucide图标\\n  useEffect(() => {\\n    // @ts-ignore\\n    window.lucide?.createIcons();\\n  }, []);\\n  \\n  // 计算所有文件是否全部选中\\n  const areAllFilesSelected = files.length > 0 && selectedFiles.length === files.length;\\n\\n  // 使用初始化加载状态显示骨架屏\\n  if (isInitialLoading) {\\n    console.log('显示骨架屏加载状态');\\n    return <SkeletonPageLayout />;\\n  }\\n\\n  // 如果用户状态正在加载，显示更简单的加载提示\\n  if (status === 'loading') {\\n    console.log('显示用户认证加载状态');\\n    return (\\n      <div className={styles.loading}>\\n        <div className={styles.loadingCard}>\\n          <div className={styles.loadingSpinner}></div>\\n          <h3 className={styles.loadingTitle}>正在加载</h3>\\n          <p className={styles.loadingText}>请稍候，正在验证您的身份...</p>\\n        </div>\\n      </div>\\n    );\\n  }\\n\\n  // 修改错误处理逻辑，使用新的ErrorDisplay组件\\n  if (isLoadingError) {\\n    console.log('显示错误状态，原因:', loadingError);\\n    \\n    // 根据错误信息判断错误类型\\n    let errorType: 'network' | 'auth' | 'server' | 'data' | 'timeout' | 'unknown' = 'unknown';\\n    \\n    if (loadingError) {\\n      if (loadingError.includes('网络') || loadingError.includes('连接')) {\\n        errorType = 'network';\\n      } else if (loadingError.includes('超时')) {\\n        errorType = 'timeout';\\n      } else if (loadingError.includes('服务器')) {\\n        errorType = 'server';\\n      } else if (loadingError.includes('数据') || loadingError.includes('资料')) {\\n        errorType = 'data';\\n      } else if (loadingError.includes('认证') || loadingError.includes('登录')) {\\n        errorType = 'auth';\\n      }\\n    }\\n    \\n    return (\\n      <ErrorDisplay \\n        errorType={errorType}\\n        message={loadingError || \\\"请刷新页面重试或联系管理员\\\"}\\n        onRetry={() => {\\n          startLoading(false);\\n          fetchUserProfile(true)\\n            .then(() => {\\n              return loadFiles(currentFolderId, selectedFileType, true);\\n            })\\n            .then(() => finishLoading())\\n            .catch((err) => finishLoading(true, err.message));\\n        }}\\n      />\\n    );\\n  }\\n\\n  // 添加一个额外的检查，如果用户资料仍在加载中，继续显示骨架屏\\n  if (profileLoading) {\\n    console.log('用户资料状态: 仍在加载中', { profileLoading });\\n    return <SkeletonPageLayout />;\\n  }\\n  \\n  // 单独检查用户资料是否存在\\n  if (!user-profile) {\\n    console.log('用户资料状态: 未获取到用户资料', { hasProfile: false });\\n    return <SkeletonPageLayout />;\\n  }\\n\\n  return (\\n    <>\\n      <Head>\\n        <title>文件管理 - 云盘</title>\\n      </Head>\\n      \\n      <div className={styles.file-managementContainer}>\\n        {/* Mini侧边栏 */}\\n        <MiniSidebar \\n          avatarUrl={effectiveAvatarUrl}\\n          userName={user-profile?.name}\\n          userEmail={user-profile?.email}\\n          onHomeClick={handleRootClick}\\n          onLogoutClick={handleSignOut}\\n          onAvatarClick={() => {\\n            router.push('/dashboard');\\n          }}\\n          currentTheme={currentTheme}\\n          onThemeClick={() => {\\n            // 切换主题面板显示状态，同时关闭其他面板\\n            setShowThemePanel(!showThemePanel);\\n            // 如果打开主题面板，关闭搜索和文件预览\\n            if (!showThemePanel) {\\n              setShowSearchView(false);\\n              if (previewFile) {\\n                handleClosePreview();\\n              }\\n            }\\n          }}\\n        />\\n\\n        {/* 侧边栏 - 仅在非主题模式下显示 */}\\n        {sidebarVisible && !showThemePanel && (\\n          <div className={styles.sidebarContainer}>\\n            <Sidebar\\n              selectedFileType={selectedFileType}\\n              onTypeClick={(type) => {\\n                console.log('侧边栏类型点击:', type);\\n                \\n                // 开始刷新加载状态\\n                startLoading(true);\\n                \\n                // 先更新状态\\n                setSelectedFileType(type);\\n                setCurrentFolderId(null);\\n                setFolderPath([]);\\n                \\n                // 使用新的参数传递方式，直接传入点击的类型\\n                loadFiles(null, type)\\n                  .finally(() => finishLoading());\\n              }}\\n              onSearchClick={handleSearchClick}\\n            />\\n          </div>\\n        )}\\n\\n        {/* 根据视图状态显示不同内容 */}\\n        {showThemePanel ? (\\n          /* 主题设置视图 */\\n          <ThemePanel \\n            currentTheme={currentTheme}\\n            onThemeChange={async (themeId) => {\\n              const success = await updateTheme(themeId);\\n              return success;\\n            }}\\n            onClose={() => setShowThemePanel(false)}\\n          />\\n        ) : (\\n          /* 文件管理视图 */\\n          <div className={styles.mainContent}>\\n            {/* 当内容刷新加载时显示局部加载状态 */}\\n            {isRefreshing && (\\n              <div className={styles.refreshingOverlay}>\\n                <Spin tip=\\\"正在刷新...\\\" />\\n              </div>\\n            )}\\n            \\n            {/* 顶部操作栏 */}\\n            <TopActionBar \\n              selectedFiles={selectedFiles}\\n              onClearSelection={() => setSelectedFiles([])}\\n              onDownload={handleDownload}\\n              onRename={() => {\\n                // 如果选中了多个文件，提示用户一次只能重命名一个文件\\n                if (selectedFiles.length > 1) {\\n                  message.warning('一次只能重命名一个文件');\\n                  return;\\n                }\\n                \\n                // 如果选中了一个文件，找到该文件并打开重命名对话框\\n                if (selectedFiles.length === 1) {\\n                  const selectedFile = files.find(file => file.id === selectedFiles[0]);\\n                  if (selectedFile) {\\n                    console.log('打开重命名对话框，文件:', {\\n                      id: selectedFile.id,\\n                      name: selectedFile.name,\\n                      isFolder: selectedFile.isFolder\\n                    });\\n                    handleRenameButtonClick(selectedFile);\\n                  } else {\\n                    message.warning('未找到选中的文件');\\n                  }\\n                } else {\\n                  message.warning('请先选择要重命名的文件');\\n                }\\n              }}\\n              onMove={() => {}}\\n              onDelete={handleDelete}\\n              onClearFilter={handleClearFilter}\\n              onCreateFolder={handleCreateFolderClick}\\n              selectedFileType={selectedFileType}\\n              showSearchView={showSearchView}\\n              isInRootFolder={!currentFolderId && !selectedFileType && !showSearchView}\\n              sortOrder={sortOrder}\\n              setSortOrder={setSortOrder}\\n              showUploadDropdown={showUploadDropdown}\\n              setShowUploadDropdown={setShowUploadDropdown}\\n              setIsUploadModalOpen={setIsUploadModalOpen}\\n              setIsFolderUploadModalOpen={setIsFolderUploadModalOpen}\\n              uploadDropdownRef={uploadDropdownRef}\\n            />\\n            \\n            {/* 面包屑导航栏 */}\\n            <div className={styles.breadcrumbBar}>\\n              <Breadcrumb \\n                folderPath={folderPath} \\n                showHome={true}\\n                onPathClick={(folderId) => {\\n                  if (folderId === null) {\\n                    setCurrentFolderId(null);\\n                    setFolderPath([]);\\n                    \\n                    // 开始刷新加载状态\\n                    startLoading(true);\\n                    \\n                    loadFiles(null, selectedFileType)\\n                      .finally(() => finishLoading());\\n                  } else {\\n                    // 查找用户点击的路径索引\\n                    const index = folderPath.findIndex(p => p.id === folderId);\\n                    if (index !== -1) {\\n                      // 切断索引之后的部分\\n                      const newPath = folderPath.slice(0, index + 1);\\n                      setFolderPath(newPath);\\n                      setCurrentFolderId(folderId);\\n                      \\n                      // 开始刷新加载状态\\n                      startLoading(true);\\n                      \\n                      loadFiles(folderId, selectedFileType)\\n                        .finally(() => finishLoading());\\n                    }\\n                  }\\n                }}\\n                onBackClick={() => {\\n                  if (folderPath.length > 0) {\\n                    handleBackClick();\\n                  }\\n                }}\\n              />\\n            </div>\\n\\n            {/* 搜索视图或文件列表视图 */}\\n            <div className={styles.fileListWrapper}>\\n              {showSearchView ? (\\n                <div className=\\\"search-view-container\\\">\\n                  <SearchView \\n                    searchType={searchType}\\n                    setSearchType={setSearchType}\\n                    searchQuery={searchQuery}\\n                    setSearchQuery={setSearchQuery}\\n                    searchResults={searchResults}\\n                    isLoading={searchLoading}\\n                    error={searchError}\\n                    handleSearch={handleSearch}\\n                    handleFileClick={handleFileItemClick}\\n                    enableRealTimeSearch={enableRealTimeSearch}\\n                    setEnableRealTimeSearch={setEnableRealTimeSearch}\\n                    debounceDelay={debounceDelay}\\n                    setDebounceDelay={setDebounceDelay}\\n                  />\\n                </div>\\n              ) : (\\n                // 文件列表\\n                <>\\n                  {isCreatingFolder && (\\n                    <NewFolderForm \\n                      folderName={newFolderName}\\n                      setFolderName={setNewFolderName}\\n                      folderTags={newFolderTags}\\n                      setFolderTags={setNewFolderTags}\\n                      onCreateFolder={() => {\\n                        // 先判断文件夹名称是否为空\\n                        if (!newFolderName || !newFolderName.trim()) {\\n                          return; // 如果为空，直接返回\\n                        }\\n                        \\n                        console.log('开始创建文件夹:', newFolderName);\\n                        \\n                        // 确保传递名称和标签\\n                        handleCreateFolder(newFolderName, currentFolderId, newFolderTags)\\n                          .then(folderId => {\\n                            console.log('文件夹创建返回ID:', folderId);\\n                            \\n                            // 只要返回值不是null，就认为是成功的\\n                            if (folderId !== null) {\\n                              console.log('文件夹创建成功，准备刷新');\\n                              // 创建成功，关闭表单并刷新\\n                              setIsCreatingFolder(false);\\n                              setNewFolderName('');\\n                              setNewFolderTags([]);\\n                              \\n                              // 刷新当前文件夹\\n                              loadFiles(currentFolderId, selectedFileType, true)\\n                                .then(() => {\\n                                  console.log('文件列表刷新完成');\\n                                })\\n                                .catch(err => {\\n                                  console.error('刷新文件列表失败:', err);\\n                                });\\n                            } else {\\n                              console.error('创建文件夹失败，API返回null');\\n                            }\\n                          })\\n                          .catch(error => {\\n                            console.error('创建文件夹请求出错:', error);\\n                          });\\n                      }}\\n                      onCancel={() => {\\n                        setIsCreatingFolder(false);\\n                        setNewFolderName('');\\n                        setNewFolderTags([]);\\n                      }}\\n                    />\\n                  )}\\n\\n                  {/* 文件列表组件 */}\\n                  <FileList \\n                    files={convertFilesForDisplay(files)}\\n                    onFileClick={handleFileItemClick}\\n                    onFileSelect={(file, checked) => onFileCheckboxChange(file as FileInfo, checked)}\\n                    onSelectAll={onSelectAllFiles}\\n                    onDeselectAll={onDeselectAllFiles}\\n                    selectedFiles={selectedFiles}\\n                    onFileContextMenu={(e, file) => handleFileContextMenu(e, file, setSelectedFile, setSelectedFiles)}\\n                    onBackClick={folderPath.length > 0 ? handleBackClick : undefined}\\n                    isLoading={filesLoading}\\n                    error={filesError}\\n                    editingFile={editingFile}\\n                    editingName={editingName}\\n                    editingTags={editingTags}\\n                    onEditNameChange={setEditingName}\\n                    onConfirmEdit={handleConfirmEdit}\\n                    onCancelEdit={() => setEditingFile(null)}\\n                    onAddTag={handleAddTag}\\n                    onRemoveTag={handleRemoveTag}\\n                    newTag={newTag}\\n                    onNewTagChange={setNewTag}\\n                    showCheckboxes={true}\\n                    areAllSelected={areAllFilesSelected}\\n                  />\\n                </>\\n              )}\\n            </div>\\n          </div>\\n        )}\\n      </div>\\n      \\n      {/* 上传模态窗口 */}\\n      <UploadModal \\n        isOpen={isUploadModalOpen} \\n        onClose={() => setIsUploadModalOpen(false)} \\n        onSuccess={handleUploadSuccess}\\n        currentFolderId={currentFolderId}\\n        isFolderUpload={false}\\n      />\\n      \\n      <UploadModal \\n        isOpen={isFolderUploadModalOpen} \\n        onClose={() => setIsFolderUploadModalOpen(false)} \\n        onSuccess={handleUploadSuccess}\\n        currentFolderId={currentFolderId}\\n        isFolderUpload={true}\\n      />\\n\\n      {/* 重命名模态窗口 */}\\n      <RenameModal\\n        isOpen={isRenameModalOpen}\\n        onClose={() => setIsRenameModalOpen(false)}\\n        onRename={(newName, tags) => {\\n          if (!fileToRename) {\\n            message.warning('未选择要重命名的文件');\\n            return;\\n          }\\n          \\n          console.log('准备重命名文件:', {\\n            id: fileToRename.id,\\n            name: fileToRename.name,\\n            newName: newName,\\n            tagsCount: tags?.length || 0\\n          });\\n          \\n          // 使用useFilePreview的renameFile函数\\n          handleConfirmEdit(newName, tags)\\n            .then(success => {\\n              if (success) {\\n                console.log('重命名成功，刷新文件列表');\\n              } else {\\n                console.error('重命名失败');\\n              }\\n            })\\n            .catch(err => {\\n              console.error('重命名过程出错:', err);\\n            });\\n        }}\\n        initialName={fileToRename?.name || ''}\\n        initialTags={fileToRename?.tags || []}\\n        fileType={fileToRename?.isFolder ? 'folder' : 'file'}\\n      />\\n\\n      {/* 文件预览组件应该位于整个应用的最外层，确保它覆盖其他所有内容 */}\\n      {previewFile && (\\n        <FilePreview\\n          file={previewFile}\\n          onClose={handleClosePreview}\\n          onDownload={handleDownload}\\n        />\\n      )}\\n    </>\\n  );\\n}\\n       \"\n  },\n  {\n    \"path\": \"app\\\\hooks\\\\user\\\\useProfile.ts\",\n    \"newContent\": \"import { useState, useEffect, useRef, useCallback } from \\\"react\\\"\\r\\nimport { useSession } from \\\"next-auth/react\\\"\\r\\nimport { toast } from 'sonner'\\r\\nimport { applyTheme as applyThemeService } from \\\"@/app/shared/themes\\\"\\r\\n\\r\\n/**\\r\\n * 用户资料接口\\r\\n */\\r\\nexport interface UserProfile {\\r\\n  /** 用户ID */\\r\\n  id: string\\r\\n  /** 邮箱 */\\r\\n  email: string\\r\\n  /** 用户名 */\\r\\n  name: string | null\\r\\n  /** 头像URL */\\r\\n  avatarUrl?: string | null\\r\\n  /** 主题 */\\r\\n  theme?: string | null\\r\\n  /** 已使用存储空间（字节） */\\r\\n  storageUsed: number\\r\\n  /** 存储空间限制（字节） */\\r\\n  storageLimit: number\\r\\n  /** 用户简介 */\\r\\n  bio?: string\\r\\n  /** 位置 */\\r\\n  location?: string\\r\\n  /** 网站 */\\r\\n  website?: string\\r\\n  /** 公司 */\\r\\n  company?: string\\r\\n  /** 创建时间 */\\r\\n  createdAt: string\\r\\n  /** 更新时间 */\\r\\n  updatedAt: string\\r\\n}\\r\\n\\r\\n/**\\r\\n * 用户资料更新输入\\r\\n */\\r\\nexport interface UserProfileInput {\\r\\n  /** 显示名称 */\\r\\n  displayName?: string\\r\\n  /** 头像URL */\\r\\n  avatarUrl?: string\\r\\n  /** 主题 */\\r\\n  theme?: string\\r\\n  /** 用户简介 */\\r\\n  bio?: string\\r\\n  /** 位置 */\\r\\n  location?: string\\r\\n  /** 网站 */\\r\\n  website?: string\\r\\n  /** 公司 */\\r\\n  company?: string\\r\\n}\\r\\n\\r\\n/**\\r\\n * 用户资料API响应\\r\\n */\\r\\nexport interface UserProfileResponse {\\r\\n  /** 是否成功 */\\r\\n  success: boolean\\r\\n  /** 用户资料 */\\r\\n  profile?: UserProfile\\r\\n  /** 错误信息 */\\r\\n  error?: string\\r\\n}\\r\\n\\r\\n// 默认离线用户配置，当API不可用时使用\\r\\nconst DEFAULT_OFFLINE_PROFILE: UserProfile = {\\r\\n  id: 'offline-user',\\r\\n  email: 'offline@example.com',\\r\\n  name: '离线模式',\\r\\n  avatarUrl: null,\\r\\n  theme: 'default',\\r\\n  storageUsed: 0,\\r\\n  storageLimit: 1024 * 1024 * 100, // 100MB\\r\\n  createdAt: new Date().toISOString(),\\r\\n  updatedAt: new Date().toISOString()\\r\\n}\\r\\n\\r\\n// 重试配置\\r\\nconst RETRY_DELAY = 3000 // 3秒\\r\\nconst MAX_RETRIES = 2 // 最大重试次数\\r\\nconst MAX_ERROR_COUNT = 3 // 连续错误阈值，超过后进入离线模式\\r\\n\\r\\n/**\\r\\n * 用户资料Hook\\r\\n * 提供用户资料的获取、更新和管理功能\\r\\n * \\r\\n * @returns 用户资料和相关操作方法\\r\\n */\\r\\nexport function useProfile() {\\r\\n  const { data: session } = useSession()\\r\\n  const [user-profile, setUserProfile] = useState<UserProfile | null>(null)\\r\\n  const [isLoading, setIsLoading] = useState(true)\\r\\n  const [error, setError] = useState<string | null>(null)\\r\\n  const [isOfflineMode, setIsOfflineMode] = useState(false)\\r\\n  const [consecutiveErrors, setConsecutiveErrors] = useState(0)\\r\\n  const abortControllerRef = useRef<AbortController | null>(null)\\r\\n  const lastFetchTimeRef = useRef<number>(0)\\r\\n  const sessionChangeRef = useRef<number>(0)\\r\\n\\r\\n  // 有效的头像URL，优先使用用户资料中的，其次是会话中的\\r\\n  const effectiveAvatarUrl = user-profile?.avatarUrl || session?.user?.image || null\\r\\n\\r\\n  /**\\r\\n   * 获取用户资料\\r\\n   * @param showToast 是否显示加载成功的提示\\r\\n   * @param retryCount 重试次数\\r\\n   * @returns 用户资料\\r\\n   */\\r\\n  const fetchUserProfile = useCallback(async (showToast = false, retryCount = 0) => {\\r\\n    // 判断是否在短时间内重复调用，避免频繁请求\\r\\n    const now = Date.now()\\r\\n    const timeSinceLastFetch = now - lastFetchTimeRef.current\\r\\n    \\r\\n    if (retryCount === 0 && timeSinceLastFetch < 2000 && lastFetchTimeRef.current > 0) {\\r\\n      console.log(`距上次请求仅 ${timeSinceLastFetch}ms，跳过此次请求`)\\r\\n      return user-profile\\r\\n    }\\r\\n    \\r\\n    lastFetchTimeRef.current = now\\r\\n\\r\\n    // 添加更详细的 session 检查日志\\r\\n    console.log('获取用户资料检查 session 状态:', { \\r\\n      sessionExists: !!session, \\r\\n      hasUser: !!session?.user, \\r\\n      userEmail: session?.user?.email || 'unknown',\\r\\n      retryCount \\r\\n    })\\r\\n\\r\\n    if (!session || !session.user) {\\r\\n      console.log('未检测到有效会话，无法获取用户资料')\\r\\n      setIsLoading(false)\\r\\n      setError('未检测到有效会话')\\r\\n      return null\\r\\n    }\\r\\n\\r\\n    // 如果已经超过最大错误数，并且已经进入离线模式，则使用离线配置\\r\\n    if (isOfflineMode && retryCount === 0) {\\r\\n      console.log('应用正在离线模式下运行，使用默认配置')\\r\\n      if (!user-profile) {\\r\\n        const offlineProfile = {\\r\\n          ...DEFAULT_OFFLINE_PROFILE,\\r\\n          email: session.user?.email || DEFAULT_OFFLINE_PROFILE.email,\\r\\n          name: session.user?.name || DEFAULT_OFFLINE_PROFILE.name,\\r\\n        }\\r\\n        setUserProfile(offlineProfile)\\r\\n        setIsLoading(false)\\r\\n        return offlineProfile\\r\\n      }\\r\\n      setIsLoading(false)\\r\\n      return user-profile\\r\\n    }\\r\\n\\r\\n    // 如果已经有用户资料且不是重试模式，则直接返回现有资料\\r\\n    if (user-profile && !showToast && retryCount === 0) {\\r\\n      console.log('已有用户资料，直接返回:', user-profile.email)\\r\\n      return user-profile\\r\\n    }\\r\\n\\r\\n    // 取消之前的请求\\r\\n    if (abortControllerRef.current) {\\r\\n      abortControllerRef.current.abort()\\r\\n    }\\r\\n    \\r\\n    // 创建新的AbortController\\r\\n    abortControllerRef.current = new AbortController()\\r\\n    const { signal } = abortControllerRef.current\\r\\n    \\r\\n    let timeoutId: NodeJS.Timeout | null = null\\r\\n\\r\\n    try {\\r\\n      setIsLoading(true)\\r\\n      \\r\\n      if (retryCount === 0) {\\r\\n        setError(null)\\r\\n      }\\r\\n      \\r\\n      console.log(`获取用户资料${retryCount > 0 ? `(重试 ${retryCount}/${MAX_RETRIES})` : ''}...`)\\r\\n      \\r\\n      // 设置请求超时 - 10秒，增强容错性\\r\\n      timeoutId = setTimeout(() => {\\r\\n        if (abortControllerRef.current) {\\r\\n          console.log('用户资料请求超时，中止请求')\\r\\n          abortControllerRef.current.abort()\\r\\n        }\\r\\n      }, 10000) // 10秒超时\\r\\n      \\r\\n      const response = await fetch('/api/user/profile', {\\r\\n        signal,\\r\\n        headers: {\\r\\n          'Cache-Control': 'no-cache',\\r\\n          'Pragma': 'no-cache'\\r\\n        }\\r\\n      })\\r\\n      \\r\\n      if (timeoutId) clearTimeout(timeoutId)\\r\\n      \\r\\n      // 添加更详细的响应日志\\r\\n      console.log('资料请求响应状态:', {\\r\\n        status: response.status,\\r\\n        ok: response.ok,\\r\\n        statusText: response.statusText\\r\\n      })\\r\\n      \\r\\n      if (!response.ok) {\\r\\n        console.error(`资料请求失败, 状态码: ${response.status}`)\\r\\n        throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`)\\r\\n      }\\r\\n      \\r\\n      const data: UserProfileResponse = await response.json()\\r\\n      \\r\\n      console.log('资料请求返回数据:', {\\r\\n        success: data.success,\\r\\n        hasProfile: !!data.profile,\\r\\n        error: data.error || '无'\\r\\n      })\\r\\n      \\r\\n      if (!data.success) {\\r\\n        console.error('资料请求返回失败状态:', data.error)\\r\\n        throw new Error(data.error || '获取用户资料失败')\\r\\n      }\\r\\n      \\r\\n      if (!data.profile) {\\r\\n        console.error('资料请求未返回用户数据')\\r\\n        throw new Error('服务器未返回用户资料数据')\\r\\n      }\\r\\n      \\r\\n      // 请求成功，重置连续错误计数\\r\\n      setConsecutiveErrors(0)\\r\\n      setIsOfflineMode(false)\\r\\n      setUserProfile(data.profile)\\r\\n      // 明确设置加载状态为完成\\r\\n      setIsLoading(false)\\r\\n      console.log('用户资料获取成功:', data.profile.email)\\r\\n      \\r\\n      if (showToast) {\\r\\n        toast.success('用户资料已更新')\\r\\n      }\\r\\n      \\r\\n      return data.profile\\r\\n    } catch (err) {\\r\\n      if (timeoutId) clearTimeout(timeoutId)\\r\\n      \\r\\n      console.error('获取用户资料失败:', err)\\r\\n      setError(err instanceof Error ? err.message : '无法加载用户资料')\\r\\n      \\r\\n      // 增加连续错误计数\\r\\n      setConsecutiveErrors(prev => {\\r\\n        const newCount = prev + 1\\r\\n        console.log(`连续错误计数: ${prev} -> ${newCount}`)\\r\\n        \\r\\n        // 如果超过阈值，进入离线模式\\r\\n        if (newCount >= MAX_ERROR_COUNT) {\\r\\n          setIsOfflineMode(true)\\r\\n          console.log(`错误次数(${newCount})超过阈值(${MAX_ERROR_COUNT})，进入离线模式`)\\r\\n          \\r\\n          // 准备离线用户资料\\r\\n          const offlineProfile = {\\r\\n            ...DEFAULT_OFFLINE_PROFILE,\\r\\n            email: session?.user?.email || DEFAULT_OFFLINE_PROFILE.email,\\r\\n            name: session?.user?.name || DEFAULT_OFFLINE_PROFILE.name,\\r\\n          }\\r\\n          \\r\\n          setUserProfile(offlineProfile)\\r\\n        }\\r\\n        \\r\\n        return newCount\\r\\n      })\\r\\n      \\r\\n      // 在重试次数内进行重试\\r\\n      if (retryCount < MAX_RETRIES) {\\r\\n        console.log(`${RETRY_DELAY}ms后进行第${retryCount + 1}次重试...`)\\r\\n        setTimeout(() => {\\r\\n          fetchUserProfile(showToast, retryCount + 1)\\r\\n        }, RETRY_DELAY)\\r\\n      } else {\\r\\n        setIsLoading(false)\\r\\n      }\\r\\n      \\r\\n      return user-profile\\r\\n    }\\r\\n  }, [session, user-profile, isOfflineMode, consecutiveErrors])\\r\\n\\r\\n  // 监听会话变更，获取用户资料\\r\\n  useEffect(() => {\\r\\n    // 会话变更次数加1\\r\\n    sessionChangeRef.current += 1\\r\\n    const currentSessionChange = sessionChangeRef.current\\r\\n    \\r\\n    console.log(`会话变化(${currentSessionChange})，重新获取用户资料`)\\r\\n    \\r\\n    // 重置离线模式和错误计数\\r\\n    if (session?.user) {\\r\\n      setIsOfflineMode(false)\\r\\n      setConsecutiveErrors(0)\\r\\n    }\\r\\n    \\r\\n    // 延迟获取用户资料，避免在会话初始化过程中频繁请求\\r\\n    const timeoutId = setTimeout(() => {\\r\\n      // 确保在会话状态未变更的情况下执行\\r\\n      if (sessionChangeRef.current === currentSessionChange) {\\r\\n        fetchUserProfile()\\r\\n      }\\r\\n    }, 100)\\r\\n    \\r\\n    return () => clearTimeout(timeoutId)\\r\\n  }, [session, fetchUserProfile])\\r\\n\\r\\n  /**\\r\\n   * 强制刷新用户资料\\r\\n   */\\r\\n  const forceRefreshProfile = useCallback(() => {\\r\\n    return fetchUserProfile(true)\\r\\n  }, [fetchUserProfile])\\r\\n\\r\\n  /**\\r\\n   * 更新用户资料\\r\\n   * @param profileData 更新的资料数据\\r\\n   * @returns 是否更新成功\\r\\n   */\\r\\n  const updateUserProfile = useCallback(async (profileData: UserProfileInput) => {\\r\\n    if (!session?.user) {\\r\\n      console.error('用户未登录，无法更新资料')\\r\\n      return false\\r\\n    }\\r\\n    \\r\\n    setIsLoading(true)\\r\\n    setError(null)\\r\\n    \\r\\n    try {\\r\\n      const response = await fetch('/api/user/profile', {\\r\\n        method: 'PUT',\\r\\n        headers: {\\r\\n          'Content-Type': 'application/json',\\r\\n        },\\r\\n        body: JSON.stringify(profileData),\\r\\n      })\\r\\n      \\r\\n      const data: UserProfileResponse = await response.json()\\r\\n      \\r\\n      if (!response.ok || !data.success) {\\r\\n        throw new Error(data.error || '更新资料失败')\\r\\n      }\\r\\n      \\r\\n      if (data.profile) {\\r\\n        setUserProfile(data.profile)\\r\\n        toast.success('资料更新成功')\\r\\n        return true\\r\\n      } else {\\r\\n        throw new Error('服务器返回的数据无效')\\r\\n      }\\r\\n    } catch (error) {\\r\\n      console.error('更新用户资料失败:', error)\\r\\n      setError(error instanceof Error ? error.message : '更新资料失败')\\r\\n      toast.error(error instanceof Error ? error.message : '更新资料失败')\\r\\n      return false\\r\\n    } finally {\\r\\n      setIsLoading(false)\\r\\n    }\\r\\n  }, [session])\\r\\n\\r\\n  /**\\r\\n   * 更新用户主题\\r\\n   * @param theme 主题ID\\r\\n   * @returns 是否更新成功\\r\\n   */\\r\\n  const updateTheme = useCallback(async (theme: string) => {\\r\\n    return updateUserProfile({ theme })\\r\\n  }, [updateUserProfile])\\r\\n\\r\\n  /**\\r\\n   * 应用主题\\r\\n   * @param theme 主题ID\\r\\n   */\\r\\n  const applyTheme = useCallback((theme: string = 'default') => {\\r\\n    try {\\r\\n      applyThemeService(theme)\\r\\n      return true\\r\\n    } catch (error) {\\r\\n      console.error('应用主题失败:', error)\\r\\n      return false\\r\\n    }\\r\\n  }, [])\\r\\n\\r\\n  return {\\r\\n    user-profile,\\r\\n    isLoading,\\r\\n    error,\\r\\n    isOfflineMode,\\r\\n    effectiveAvatarUrl,\\r\\n    fetchUserProfile,\\r\\n    forceRefreshProfile,\\r\\n    updateUserProfile,\\r\\n    updateTheme,\\r\\n    applyTheme\\r\\n  }\\r\\n} \"\n  },\n  {\n    \"path\": \"scripts\\\\rename-helper.js\",\n    \"newContent\": \"/**\\r\\n * 目录重命名辅助脚本\\r\\n * 用于生成目录重命名和导入路径修复的命令\\r\\n */\\r\\n\\r\\nconst fs = require('fs');\\r\\nconst path = require('path');\\r\\nconst { promisify } = require('util');\\r\\nconst readdir = promisify(fs.readdir);\\r\\nconst stat = promisify(fs.stat);\\r\\nconst readFile = promisify(fs.readFile);\\r\\nconst writeFile = promisify(fs.writeFile);\\r\\n\\r\\n// 需要重命名的目录映射\\r\\nconst RENAME_MAPPINGS = [\\r\\n  {\\r\\n    from: 'app/components/features/file-management',\\r\\n    to: 'app/components/features/file-management',\\r\\n    pattern: /file-management/g,\\r\\n    replacement: 'file-management'\\r\\n  },\\r\\n  {\\r\\n    from: 'app/components/features/user-profile',\\r\\n    to: 'app/components/features/user-profile',\\r\\n    pattern: /user-profile/g,\\r\\n    replacement: 'user-profile'\\r\\n  },\\r\\n  // 添加其他需要重命名的目录\\r\\n];\\r\\n\\r\\n// 需要重命名的文件映射\\r\\nconst FILE_RENAME_MAPPINGS = [\\r\\n  {\\r\\n    from: 'app/services/storage-service.ts',\\r\\n    to: 'app/services/storageService.ts',\\r\\n    pattern: /storage-service/g,\\r\\n    replacement: 'storageService'\\r\\n  },\\r\\n  // 添加其他需要重命名的文件\\r\\n];\\r\\n\\r\\n// 需要创建的文件映射\\r\\nconst CREATE_MAPPINGS = [\\r\\n  {\\r\\n    source: 'app/components/features/user-profile/avatar/AvatarCropper.module.css',\\r\\n    target: 'app/components/features/user-profile/avatar/AvatarModal.module.css',\\r\\n    fileUpdate: {\\r\\n      file: 'app/components/features/user-profile/avatar/AvatarModal.tsx',\\r\\n      pattern: /from\\\\s+['\\\"]\\\\.\\\\/AvatarCropper\\\\.module\\\\.css['\\\"]/g,\\r\\n      replacement: `from './AvatarModal.module.css'`\\r\\n    }\\r\\n  },\\r\\n  // 添加其他需要创建的文件\\r\\n];\\r\\n\\r\\n/**\\r\\n * 生成目录重命名命令\\r\\n */\\r\\nasync function generateDirectoryRenameCommands() {\\r\\n  console.log('\\\\n===== 目录重命名命令 =====\\\\n');\\r\\n  \\r\\n  for (const mapping of RENAME_MAPPINGS) {\\r\\n    const { from, to } = mapping;\\r\\n    \\r\\n    // 检查源目录是否存在\\r\\n    try {\\r\\n      await stat(from);\\r\\n      // 检查目标目录是否已存在\\r\\n      try {\\r\\n        await stat(to);\\r\\n        console.log(`警告: 目标目录 ${to} 已存在`);\\r\\n      } catch (err) {\\r\\n        // 目标目录不存在，可以重命名\\r\\n        if (process.platform === 'win32') {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(to)}\\\"`);\\r\\n          console.log(`Move-Item -Path \\\"${from}\\\" -Destination \\\"${to}\\\"`);\\r\\n        } else {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(to)}\\\"`);\\r\\n          console.log(`mv \\\"${from}\\\" \\\"${to}\\\"`);\\r\\n        }\\r\\n      }\\r\\n    } catch (err) {\\r\\n      console.log(`警告: 源目录 ${from} 不存在`);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * 生成文件重命名命令\\r\\n */\\r\\nasync function generateFileRenameCommands() {\\r\\n  console.log('\\\\n===== 文件重命名命令 =====\\\\n');\\r\\n  \\r\\n  for (const mapping of FILE_RENAME_MAPPINGS) {\\r\\n    const { from, to } = mapping;\\r\\n    \\r\\n    // 检查源文件是否存在\\r\\n    try {\\r\\n      await stat(from);\\r\\n      // 检查目标文件是否已存在\\r\\n      try {\\r\\n        await stat(to);\\r\\n        console.log(`警告: 目标文件 ${to} 已存在`);\\r\\n      } catch (err) {\\r\\n        // 目标文件不存在，可以重命名\\r\\n        if (process.platform === 'win32') {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(to)}\\\"`);\\r\\n          console.log(`Move-Item -Path \\\"${from}\\\" -Destination \\\"${to}\\\"`);\\r\\n        } else {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(to)}\\\"`);\\r\\n          console.log(`mv \\\"${from}\\\" \\\"${to}\\\"`);\\r\\n        }\\r\\n      }\\r\\n    } catch (err) {\\r\\n      console.log(`警告: 源文件 ${from} 不存在`);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * 生成文件创建命令\\r\\n */\\r\\nasync function generateFileCreateCommands() {\\r\\n  console.log('\\\\n===== 文件创建命令 =====\\\\n');\\r\\n  \\r\\n  for (const mapping of CREATE_MAPPINGS) {\\r\\n    const { source, target } = mapping;\\r\\n    \\r\\n    // 检查源文件是否存在\\r\\n    try {\\r\\n      await stat(source);\\r\\n      // 检查目标文件是否已存在\\r\\n      try {\\r\\n        await stat(target);\\r\\n        console.log(`警告: 目标文件 ${target} 已存在`);\\r\\n      } catch (err) {\\r\\n        // 目标文件不存在，可以创建\\r\\n        if (process.platform === 'win32') {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(target)}\\\"`);\\r\\n          console.log(`Copy-Item -Path \\\"${source}\\\" -Destination \\\"${target}\\\"`);\\r\\n        } else {\\r\\n          console.log(`mkdir -p \\\"${path.dirname(target)}\\\"`);\\r\\n          console.log(`cp \\\"${source}\\\" \\\"${target}\\\"`);\\r\\n        }\\r\\n      }\\r\\n    } catch (err) {\\r\\n      console.log(`警告: 源文件 ${source} 不存在`);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * 扫描项目文件查找导入引用路径\\r\\n */\\r\\nasync function scanForImportReferences() {\\r\\n  console.log('\\\\n===== 导入路径引用修复 =====\\\\n');\\r\\n  \\r\\n  // 扫描文件的目录\\r\\n  const dirsToScan = ['app', 'scripts', 'prisma'];\\r\\n  \\r\\n  // 存储需要修改的文件\\r\\n  const filesToFix = [];\\r\\n  \\r\\n  // 创建正则表达式，匹配所有需要替换的模式\\r\\n  const patterns = RENAME_MAPPINGS.map(m => m.pattern);\\r\\n  const replacements = RENAME_MAPPINGS.map(m => m.replacement);\\r\\n  \\r\\n  /**\\r\\n   * 递归检查目录中的文件\\r\\n   */\\r\\n  async function scanDirectory(directory) {\\r\\n    try {\\r\\n      const entries = await readdir(directory);\\r\\n      \\r\\n      for (const entry of entries) {\\r\\n        // 跳过node_modules和.git目录\\r\\n        if (entry === 'node_modules' || entry === '.git' || entry === '.next' || entry === 'dist') {\\r\\n          continue;\\r\\n        }\\r\\n        \\r\\n        const fullPath = path.join(directory, entry);\\r\\n        const stats = await stat(fullPath);\\r\\n        \\r\\n        if (stats.isDirectory()) {\\r\\n          // 递归检查子目录\\r\\n          await scanDirectory(fullPath);\\r\\n        } else if (stats.isFile()) {\\r\\n          // 只检查JavaScript、TypeScript和JSON文件\\r\\n          if (/\\\\.(js|jsx|ts|tsx|json)$/.test(entry)) {\\r\\n            try {\\r\\n              const content = await readFile(fullPath, 'utf8');\\r\\n              \\r\\n              // 检查文件内容中是否包含需要替换的路径\\r\\n              let hasMatch = false;\\r\\n              let updatedContent = content;\\r\\n              \\r\\n              for (let i = 0; i < patterns.length; i++) {\\r\\n                if (patterns[i].test(content)) {\\r\\n                  hasMatch = true;\\r\\n                  updatedContent = updatedContent.replace(patterns[i], replacements[i]);\\r\\n                }\\r\\n              }\\r\\n              \\r\\n              if (hasMatch) {\\r\\n                filesToFix.push({\\r\\n                  path: fullPath,\\r\\n                  oldContent: content,\\r\\n                  newContent: updatedContent\\r\\n                });\\r\\n              }\\r\\n            } catch (err) {\\r\\n              console.error(`读取文件 ${fullPath} 时出错:`, err);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    } catch (error) {\\r\\n      console.error(`扫描目录 ${directory} 时出错:`, error);\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  // 扫描指定的目录\\r\\n  for (const dir of dirsToScan) {\\r\\n    await scanDirectory(dir);\\r\\n  }\\r\\n  \\r\\n  // 输出结果\\r\\n  console.log(`找到 ${filesToFix.length} 个文件需要更新导入路径:`);\\r\\n  \\r\\n  for (const file of filesToFix) {\\r\\n    console.log(`\\\\n文件: ${file.path}`);\\r\\n    \\r\\n    // 生成替换内容的差异\\r\\n    const oldLines = file.oldContent.split('\\\\n');\\r\\n    const newLines = file.newContent.split('\\\\n');\\r\\n    \\r\\n    for (let i = 0; i < oldLines.length; i++) {\\r\\n      if (oldLines[i] !== newLines[i]) {\\r\\n        console.log(`行 ${i + 1}:`);\\r\\n        console.log(`- ${oldLines[i]}`);\\r\\n        console.log(`+ ${newLines[i]}`);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  console.log('\\\\n===== 自动修复命令 =====\\\\n');\\r\\n  \\r\\n  if (filesToFix.length > 0) {\\r\\n    console.log('要自动修复所有文件，请运行以下命令:\\\\n');\\r\\n    console.log('node scripts/fix-imports.js');\\r\\n    \\r\\n    // 创建自动修复脚本\\r\\n    const fixScript = `/**\\r\\n * 自动修复导入路径脚本\\r\\n * 由rename-helper.js自动生成\\r\\n */\\r\\n\\r\\nconst fs = require('fs');\\r\\nconst path = require('path');\\r\\nconst { promisify } = require('util');\\r\\nconst writeFile = promisify(fs.writeFile);\\r\\n\\r\\n// 需要修复的文件\\r\\nconst filesToFix = ${JSON.stringify(filesToFix.map(f => ({ path: f.path, newContent: f.newContent })), null, 2)};\\r\\n\\r\\nasync function fixImports() {\\r\\n  console.log('开始修复导入路径...');\\r\\n  \\r\\n  for (const file of filesToFix) {\\r\\n    try {\\r\\n      await writeFile(file.path, file.newContent, 'utf8');\\r\\n      console.log(\\\\`已修复: \\\\${file.path}\\\\`);\\r\\n    } catch (err) {\\r\\n      console.error(\\\\`修复文件 \\\\${file.path} 时出错:\\\\`, err);\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  console.log('\\\\\\\\n修复完成!');\\r\\n}\\r\\n\\r\\nfixImports().catch(err => {\\r\\n  console.error('修复导入路径时出错:', err);\\r\\n  process.exit(1);\\r\\n});\\r\\n`;\\r\\n    \\r\\n    // 写入修复脚本\\r\\n    await writeFile('scripts/fix-imports.js', fixScript, 'utf8');\\r\\n    console.log('已创建自动修复脚本: scripts/fix-imports.js');\\r\\n  } else {\\r\\n    console.log('没有找到需要修复的文件');\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * 主函数\\r\\n */\\r\\nasync function main() {\\r\\n  console.log('项目命名规范修复辅助工具');\\r\\n  console.log('==========================\\\\n');\\r\\n  \\r\\n  await generateDirectoryRenameCommands();\\r\\n  await generateFileRenameCommands();\\r\\n  await generateFileCreateCommands();\\r\\n  await scanForImportReferences();\\r\\n  \\r\\n  console.log('\\\\n===== 修复建议 =====\\\\n');\\r\\n  console.log('1. 先执行目录重命名命令');\\r\\n  console.log('2. 创建缺失的样式文件');\\r\\n  console.log('3. 重命名问题文件');\\r\\n  console.log('4. 运行自动修复脚本更新导入路径');\\r\\n  console.log('5. 运行项目确认没有错误');\\r\\n}\\r\\n\\r\\n// 运行程序\\r\\nmain().catch(error => {\\r\\n  console.error('脚本执行出错:', error);\\r\\n  process.exit(1);\\r\\n}); \"\n  },\n  {\n    \"path\": \"scripts\\\\reset-db.ts\",\n    \"newContent\": \"import { PrismaClient } from '@prisma/client';\\r\\n\\r\\n/**\\r\\n * 数据库重置脚本\\r\\n * 该脚本会清空数据库中的所有数据，但保留数据库结构\\r\\n * 请谨慎使用！\\r\\n */\\r\\n\\r\\nconst prisma = new PrismaClient();\\r\\n\\r\\nasync function main() {\\r\\n  try {\\r\\n    console.log('开始清空数据库...');\\r\\n    \\r\\n    // 按照关系依赖顺序删除数据\\r\\n    // 首先删除具有外键依赖的表\\r\\n    console.log('删除分享记录...');\\r\\n    await prisma.share.deleteMany();\\r\\n    \\r\\n    console.log('删除文件...');\\r\\n    await prisma.file.deleteMany();\\r\\n    \\r\\n    console.log('删除文件夹...');\\r\\n    await prisma.folder.deleteMany();\\r\\n    \\r\\n    console.log('删除用户资料...');\\r\\n    await prisma.user-profile.deleteMany();\\r\\n    \\r\\n    console.log('删除维护日志...');\\r\\n    await prisma.maintenanceLog.deleteMany();\\r\\n    \\r\\n    console.log('删除用户...');\\r\\n    await prisma.user.deleteMany();\\r\\n    \\r\\n    console.log('数据库清空完成！');\\r\\n  } catch (error) {\\r\\n    console.error('清空数据库过程中出错:', error);\\r\\n    process.exit(1);\\r\\n  } finally {\\r\\n    await prisma.$disconnect();\\r\\n  }\\r\\n}\\r\\n\\r\\nmain(); \"\n  },\n  {\n    \"path\": \"prisma\\\\check-models.ts\",\n    \"newContent\": \"// 这是一个临时文件，用于检查生成的Prisma客户端模型\\r\\nimport { PrismaClient } from '@prisma/client'\\r\\n\\r\\nconst prisma = new PrismaClient()\\r\\n\\r\\n// 输出prisma对象的所有键\\r\\nconsole.log('Prisma client models:')\\r\\nconsole.log(Object.keys(prisma))\\r\\n\\r\\n// 检查user-profile模型\\r\\nconst hasUserProfile = 'user-profile' in prisma\\r\\nconst hasUserProfileCap = 'UserProfile' in prisma\\r\\nconsole.log('Has user-profile model:', hasUserProfile)\\r\\nconsole.log('Has UserProfile model:', hasUserProfileCap)\\r\\n\\r\\n// 直接访问所有模型\\r\\ntry {\\r\\n  console.log('Available models:')\\r\\n  // @ts-ignore\\r\\n  const userModelKeys = Object.keys(prisma.$dmmf.datamodel.models).join(', ')\\r\\n  console.log(userModelKeys)\\r\\n} catch (error) {\\r\\n  console.error('Error accessing model metadata:', error)\\r\\n}\\r\\n\\r\\n// 尝试不同的访问方式\\r\\ntry {\\r\\n  // @ts-ignore\\r\\n  const models = prisma._dmmf.modelMap\\r\\n  console.log('Models from _dmmf:', Object.keys(models))\\r\\n} catch (error) {\\r\\n  console.error('Error accessing _dmmf:', error)\\r\\n} \"\n  }\n];\n\nasync function fixImports() {\n  console.log('开始修复导入路径...');\n  \n  for (const file of filesToFix) {\n    try {\n      await writeFile(file.path, file.newContent, 'utf8');\n      console.log(`已修复: ${file.path}`);\n    } catch (err) {\n      console.error(`修复文件 ${file.path} 时出错:`, err);\n    }\n  }\n  \n  console.log('\\n修复完成!');\n}\n\nfixImports().catch(err => {\n  console.error('修复导入路径时出错:', err);\n  process.exit(1);\n});\n"
  },
  {
    "path": "scripts\\rename-helper.js",
    "newContent": "/**\r\n * 目录重命名辅助脚本\r\n * 用于生成目录重命名和导入路径修复的命令\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { promisify } = require('util');\r\nconst readdir = promisify(fs.readdir);\r\nconst stat = promisify(fs.stat);\r\nconst readFile = promisify(fs.readFile);\r\nconst writeFile = promisify(fs.writeFile);\r\n\r\n// 需要重命名的目录映射\r\nconst RENAME_MAPPINGS = [\r\n  {\r\n    from: 'app/components/features/file-management',\r\n    to: 'app/components/features/file-management',\r\n    pattern: /file-management/g,\r\n    replacement: 'file-management'\r\n  },\r\n  {\r\n    from: 'app/components/features/user-profile',\r\n    to: 'app/components/features/user-profile',\r\n    pattern: /user-profile/g,\r\n    replacement: 'user-profile'\r\n  },\r\n  // 添加其他需要重命名的目录\r\n];\r\n\r\n// 需要重命名的文件映射\r\nconst FILE_RENAME_MAPPINGS = [\r\n  {\r\n    from: 'app/services/storage-service.ts',\r\n    to: 'app/services/storageService.ts',\r\n    pattern: /storage-service/g,\r\n    replacement: 'storageService'\r\n  },\r\n  // 添加其他需要重命名的文件\r\n];\r\n\r\n// 需要创建的文件映射\r\nconst CREATE_MAPPINGS = [\r\n  {\r\n    source: 'app/components/features/user-profile/avatar/AvatarCropper.module.css',\r\n    target: 'app/components/features/user-profile/avatar/AvatarModal.module.css',\r\n    fileUpdate: {\r\n      file: 'app/components/features/user-profile/avatar/AvatarModal.tsx',\r\n      pattern: /from\\s+['\"]\\.\\/AvatarCropper\\.module\\.css['\"]/g,\r\n      replacement: `from './AvatarModal.module.css'`\r\n    }\r\n  },\r\n  // 添加其他需要创建的文件\r\n];\r\n\r\n/**\r\n * 生成目录重命名命令\r\n */\r\nasync function generateDirectoryRenameCommands() {\r\n  console.log('\\n===== 目录重命名命令 =====\\n');\r\n  \r\n  for (const mapping of RENAME_MAPPINGS) {\r\n    const { from, to } = mapping;\r\n    \r\n    // 检查源目录是否存在\r\n    try {\r\n      await stat(from);\r\n      // 检查目标目录是否已存在\r\n      try {\r\n        await stat(to);\r\n        console.log(`警告: 目标目录 ${to} 已存在`);\r\n      } catch (err) {\r\n        // 目标目录不存在，可以重命名\r\n        if (process.platform === 'win32') {\r\n          console.log(`mkdir -p \"${path.dirname(to)}\"`);\r\n          console.log(`Move-Item -Path \"${from}\" -Destination \"${to}\"`);\r\n        } else {\r\n          console.log(`mkdir -p \"${path.dirname(to)}\"`);\r\n          console.log(`mv \"${from}\" \"${to}\"`);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log(`警告: 源目录 ${from} 不存在`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 生成文件重命名命令\r\n */\r\nasync function generateFileRenameCommands() {\r\n  console.log('\\n===== 文件重命名命令 =====\\n');\r\n  \r\n  for (const mapping of FILE_RENAME_MAPPINGS) {\r\n    const { from, to } = mapping;\r\n    \r\n    // 检查源文件是否存在\r\n    try {\r\n      await stat(from);\r\n      // 检查目标文件是否已存在\r\n      try {\r\n        await stat(to);\r\n        console.log(`警告: 目标文件 ${to} 已存在`);\r\n      } catch (err) {\r\n        // 目标文件不存在，可以重命名\r\n        if (process.platform === 'win32') {\r\n          console.log(`mkdir -p \"${path.dirname(to)}\"`);\r\n          console.log(`Move-Item -Path \"${from}\" -Destination \"${to}\"`);\r\n        } else {\r\n          console.log(`mkdir -p \"${path.dirname(to)}\"`);\r\n          console.log(`mv \"${from}\" \"${to}\"`);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log(`警告: 源文件 ${from} 不存在`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 生成文件创建命令\r\n */\r\nasync function generateFileCreateCommands() {\r\n  console.log('\\n===== 文件创建命令 =====\\n');\r\n  \r\n  for (const mapping of CREATE_MAPPINGS) {\r\n    const { source, target } = mapping;\r\n    \r\n    // 检查源文件是否存在\r\n    try {\r\n      await stat(source);\r\n      // 检查目标文件是否已存在\r\n      try {\r\n        await stat(target);\r\n        console.log(`警告: 目标文件 ${target} 已存在`);\r\n      } catch (err) {\r\n        // 目标文件不存在，可以创建\r\n        if (process.platform === 'win32') {\r\n          console.log(`mkdir -p \"${path.dirname(target)}\"`);\r\n          console.log(`Copy-Item -Path \"${source}\" -Destination \"${target}\"`);\r\n        } else {\r\n          console.log(`mkdir -p \"${path.dirname(target)}\"`);\r\n          console.log(`cp \"${source}\" \"${target}\"`);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.log(`警告: 源文件 ${source} 不存在`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 扫描项目文件查找导入引用路径\r\n */\r\nasync function scanForImportReferences() {\r\n  console.log('\\n===== 导入路径引用修复 =====\\n');\r\n  \r\n  // 扫描文件的目录\r\n  const dirsToScan = ['app', 'scripts', 'prisma'];\r\n  \r\n  // 存储需要修改的文件\r\n  const filesToFix = [];\r\n  \r\n  // 创建正则表达式，匹配所有需要替换的模式\r\n  const patterns = RENAME_MAPPINGS.map(m => m.pattern);\r\n  const replacements = RENAME_MAPPINGS.map(m => m.replacement);\r\n  \r\n  /**\r\n   * 递归检查目录中的文件\r\n   */\r\n  async function scanDirectory(directory) {\r\n    try {\r\n      const entries = await readdir(directory);\r\n      \r\n      for (const entry of entries) {\r\n        // 跳过node_modules和.git目录\r\n        if (entry === 'node_modules' || entry === '.git' || entry === '.next' || entry === 'dist') {\r\n          continue;\r\n        }\r\n        \r\n        const fullPath = path.join(directory, entry);\r\n        const stats = await stat(fullPath);\r\n        \r\n        if (stats.isDirectory()) {\r\n          // 递归检查子目录\r\n          await scanDirectory(fullPath);\r\n        } else if (stats.isFile()) {\r\n          // 只检查JavaScript、TypeScript和JSON文件\r\n          if (/\\.(js|jsx|ts|tsx|json)$/.test(entry)) {\r\n            try {\r\n              const content = await readFile(fullPath, 'utf8');\r\n              \r\n              // 检查文件内容中是否包含需要替换的路径\r\n              let hasMatch = false;\r\n              let updatedContent = content;\r\n              \r\n              for (let i = 0; i < patterns.length; i++) {\r\n                if (patterns[i].test(content)) {\r\n                  hasMatch = true;\r\n                  updatedContent = updatedContent.replace(patterns[i], replacements[i]);\r\n                }\r\n              }\r\n              \r\n              if (hasMatch) {\r\n                filesToFix.push({\r\n                  path: fullPath,\r\n                  oldContent: content,\r\n                  newContent: updatedContent\r\n                });\r\n              }\r\n            } catch (err) {\r\n              console.error(`读取文件 ${fullPath} 时出错:`, err);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(`扫描目录 ${directory} 时出错:`, error);\r\n    }\r\n  }\r\n  \r\n  // 扫描指定的目录\r\n  for (const dir of dirsToScan) {\r\n    await scanDirectory(dir);\r\n  }\r\n  \r\n  // 输出结果\r\n  console.log(`找到 ${filesToFix.length} 个文件需要更新导入路径:`);\r\n  \r\n  for (const file of filesToFix) {\r\n    console.log(`\\n文件: ${file.path}`);\r\n    \r\n    // 生成替换内容的差异\r\n    const oldLines = file.oldContent.split('\\n');\r\n    const newLines = file.newContent.split('\\n');\r\n    \r\n    for (let i = 0; i < oldLines.length; i++) {\r\n      if (oldLines[i] !== newLines[i]) {\r\n        console.log(`行 ${i + 1}:`);\r\n        console.log(`- ${oldLines[i]}`);\r\n        console.log(`+ ${newLines[i]}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  console.log('\\n===== 自动修复命令 =====\\n');\r\n  \r\n  if (filesToFix.length > 0) {\r\n    console.log('要自动修复所有文件，请运行以下命令:\\n');\r\n    console.log('node scripts/fix-imports.js');\r\n    \r\n    // 创建自动修复脚本\r\n    const fixScript = `/**\r\n * 自动修复导入路径脚本\r\n * 由rename-helper.js自动生成\r\n */\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { promisify } = require('util');\r\nconst writeFile = promisify(fs.writeFile);\r\n\r\n// 需要修复的文件\r\nconst filesToFix = ${JSON.stringify(filesToFix.map(f => ({ path: f.path, newContent: f.newContent })), null, 2)};\r\n\r\nasync function fixImports() {\r\n  console.log('开始修复导入路径...');\r\n  \r\n  for (const file of filesToFix) {\r\n    try {\r\n      await writeFile(file.path, file.newContent, 'utf8');\r\n      console.log(\\`已修复: \\${file.path}\\`);\r\n    } catch (err) {\r\n      console.error(\\`修复文件 \\${file.path} 时出错:\\`, err);\r\n    }\r\n  }\r\n  \r\n  console.log('\\\\n修复完成!');\r\n}\r\n\r\nfixImports().catch(err => {\r\n  console.error('修复导入路径时出错:', err);\r\n  process.exit(1);\r\n});\r\n`;\r\n    \r\n    // 写入修复脚本\r\n    await writeFile('scripts/fix-imports.js', fixScript, 'utf8');\r\n    console.log('已创建自动修复脚本: scripts/fix-imports.js');\r\n  } else {\r\n    console.log('没有找到需要修复的文件');\r\n  }\r\n}\r\n\r\n/**\r\n * 主函数\r\n */\r\nasync function main() {\r\n  console.log('项目命名规范修复辅助工具');\r\n  console.log('==========================\\n');\r\n  \r\n  await generateDirectoryRenameCommands();\r\n  await generateFileRenameCommands();\r\n  await generateFileCreateCommands();\r\n  await scanForImportReferences();\r\n  \r\n  console.log('\\n===== 修复建议 =====\\n');\r\n  console.log('1. 先执行目录重命名命令');\r\n  console.log('2. 创建缺失的样式文件');\r\n  console.log('3. 重命名问题文件');\r\n  console.log('4. 运行自动修复脚本更新导入路径');\r\n  console.log('5. 运行项目确认没有错误');\r\n}\r\n\r\n// 运行程序\r\nmain().catch(error => {\r\n  console.error('脚本执行出错:', error);\r\n  process.exit(1);\r\n}); "
  },
  {
    "path": "scripts\\reset-db.ts",
    "newContent": "import { PrismaClient } from '@prisma/client';\r\n\r\n/**\r\n * 数据库重置脚本\r\n * 该脚本会清空数据库中的所有数据，但保留数据库结构\r\n * 请谨慎使用！\r\n */\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('开始清空数据库...');\r\n    \r\n    // 按照关系依赖顺序删除数据\r\n    // 首先删除具有外键依赖的表\r\n    console.log('删除分享记录...');\r\n    await prisma.share.deleteMany();\r\n    \r\n    console.log('删除文件...');\r\n    await prisma.file.deleteMany();\r\n    \r\n    console.log('删除文件夹...');\r\n    await prisma.folder.deleteMany();\r\n    \r\n    console.log('删除用户资料...');\r\n    await prisma.user-profile.deleteMany();\r\n    \r\n    console.log('删除维护日志...');\r\n    await prisma.maintenanceLog.deleteMany();\r\n    \r\n    console.log('删除用户...');\r\n    await prisma.user.deleteMany();\r\n    \r\n    console.log('数据库清空完成！');\r\n  } catch (error) {\r\n    console.error('清空数据库过程中出错:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n\r\nmain(); "
  },
  {
    "path": "prisma\\check-models.ts",
    "newContent": "// 这是一个临时文件，用于检查生成的Prisma客户端模型\r\nimport { PrismaClient } from '@prisma/client'\r\n\r\nconst prisma = new PrismaClient()\r\n\r\n// 输出prisma对象的所有键\r\nconsole.log('Prisma client models:')\r\nconsole.log(Object.keys(prisma))\r\n\r\n// 检查user-profile模型\r\nconst hasUserProfile = 'user-profile' in prisma\r\nconst hasUserProfileCap = 'UserProfile' in prisma\r\nconsole.log('Has user-profile model:', hasUserProfile)\r\nconsole.log('Has UserProfile model:', hasUserProfileCap)\r\n\r\n// 直接访问所有模型\r\ntry {\r\n  console.log('Available models:')\r\n  // @ts-ignore\r\n  const userModelKeys = Object.keys(prisma.$dmmf.datamodel.models).join(', ')\r\n  console.log(userModelKeys)\r\n} catch (error) {\r\n  console.error('Error accessing model metadata:', error)\r\n}\r\n\r\n// 尝试不同的访问方式\r\ntry {\r\n  // @ts-ignore\r\n  const models = prisma._dmmf.modelMap\r\n  console.log('Models from _dmmf:', Object.keys(models))\r\n} catch (error) {\r\n  console.error('Error accessing _dmmf:', error)\r\n} "
  }
];

async function fixImports() {
  console.log('开始修复导入路径...');
  
  for (const file of filesToFix) {
    try {
      await writeFile(file.path, file.newContent, 'utf8');
      console.log(`已修复: ${file.path}`);
    } catch (err) {
      console.error(`修复文件 ${file.path} 时出错:`, err);
    }
  }
  
  console.log('\n修复完成!');
}

fixImports().catch(err => {
  console.error('修复导入路径时出错:', err);
  process.exit(1);
});
